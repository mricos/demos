<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Bayesian Linear Regression</title>
  <link rel="stylesheet" href="styles.css">

  <!-- KaTeX for math rendering -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.css">
  <script defer src="https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.js"></script>
</head>
<body>
  <div class="header">
    <h1>Bayesian Linear Regression</h1>
    <p>Probabilistic approach to regression with uncertainty quantification</p>
  </div>

  <!-- Section 1: Bayesian Formulation -->
  <div class="section">
    <div class="section-title">Bayesian Approach to Regression</div>

    <div class="explanation">
      In Bayesian regression, we don't find a single "best" set of weights. Instead, we compute a <strong>probability distribution</strong> over all possible weights given the data. This gives us uncertainty estimates for free.
    </div>

    <div class="math-box">
      <div id="bayesEquation"></div>
    </div>

    <div class="controls">
      <label>
        <span>Prior σ:</span>
        <input type="range" id="priorSigma" min="0.1" max="5" step="0.1" value="1">
        <span id="priorSigmaValue" class="value-display">1.0</span>
      </label>
      <label>
        <span>Likelihood σ:</span>
        <input type="range" id="likelihoodSigma" min="0.1" max="3" step="0.1" value="0.5">
        <span id="likelihoodSigmaValue" class="value-display">0.5</span>
      </label>
      <label>
        <span>Samples:</span>
        <input type="range" id="numSamples" min="10" max="200" step="10" value="50">
        <span id="numSamplesValue" class="value-display">50</span>
      </label>
      <label>
        <span>Data Noise:</span>
        <input type="range" id="dataNoise" min="0.1" max="5" step="0.1" value="1">
        <span id="dataNoiseValue" class="value-display">1.0</span>
      </label>
      <button id="resample">Resample Posterior</button>
      <button id="regenerateData">Regenerate Data</button>
    </div>

    <div class="viz-container">
      <div class="plot-wrapper">
        <div class="plot-title">Posterior Predictive Distribution</div>
        <canvas id="bayesianFit" width="600" height="400"></canvas>
        <div class="plot-caption">"Hairy caterpillar" shows uncertainty in predictions</div>
      </div>
      <div class="plot-wrapper">
        <div class="plot-title">Distribution Evolution</div>
        <canvas id="distributionEvolution" width="600" height="400"></canvas>
        <div class="plot-caption">Prior → Likelihood → Posterior</div>
      </div>
    </div>

    <div class="info">
      <div id="bayesStats"></div>
    </div>

    <div class="explanation">
      <strong>Prior P(w):</strong> Our initial belief about weights before seeing data<br>
      <strong>Likelihood P(D|w):</strong> How well data fits for given weights<br>
      <strong>Posterior P(w|D):</strong> Updated belief after seeing data
    </div>
  </div>

  <!-- Section 2: Components Breakdown -->
  <div class="section">
    <div class="section-title">Bayesian Components Visualization</div>

    <div class="explanation">
      This 1D visualization shows how the prior belief and likelihood combine to form the posterior distribution for a single coefficient (w₁).
    </div>

    <canvas id="componentsViz" width="1200" height="400"></canvas>

    <div class="info">
      <div id="componentsInfo"></div>
    </div>

    <div class="explanation">
      <strong>Key Insight:</strong> The posterior is a compromise between the prior and the likelihood. When we have more data, the likelihood dominates. With little data, the prior has more influence.
    </div>
  </div>

  <script>
    // Utility: Gaussian random number generator
    function gaussianRandom(mean = 0, std = 1) {
      let u = 0, v = 0;
      while(u === 0) u = Math.random();
      while(v === 0) v = Math.random();
      return mean + std * Math.sqrt(-2.0 * Math.log(u)) * Math.cos(2.0 * Math.PI * v);
    }

    // Generate synthetic data
    let dataPoints = [];
    let dataNoise = 1.0;

    function generateData(noise = 1.0) {
      dataPoints = [];
      const trueW0 = 2;
      const trueW1 = 1.5;
      for (let i = 0; i < 50; i++) {
        const x = (Math.random() - 0.5) * 10;
        const y = trueW0 + trueW1 * x + gaussianRandom(0, noise);
        dataPoints.push({x, y});
      }
    }
    generateData(1.0);

    // Bayesian Linear Regression
    let priorSigma = 1.0;
    let likelihoodSigma = 0.5;
    let numSamples = 50;
    let sampledWeights = [];

    function samplePosterior() {
      sampledWeights = [];

      const n = dataPoints.length;
      const X = dataPoints.map(p => [1, p.x]);
      const y = dataPoints.map(p => p.y);

      // Compute posterior mean and covariance
      const sigma2Prior = priorSigma * priorSigma;
      const sigma2Noise = likelihoodSigma * likelihoodSigma;

      // XtX
      const XtX = [[0, 0], [0, 0]];
      for (let i = 0; i < n; i++) {
        for (let j = 0; j < 2; j++) {
          for (let k = 0; k < 2; k++) {
            XtX[j][k] += X[i][j] * X[i][k];
          }
        }
      }

      // Sigma_post^{-1}
      const SigmaPostInv = [
        [XtX[0][0] / sigma2Noise + 1 / sigma2Prior, XtX[0][1] / sigma2Noise],
        [XtX[1][0] / sigma2Noise, XtX[1][1] / sigma2Noise + 1 / sigma2Prior]
      ];

      // Invert to get Sigma_post
      const det = SigmaPostInv[0][0] * SigmaPostInv[1][1] - SigmaPostInv[0][1] * SigmaPostInv[1][0];
      const SigmaPost = [
        [SigmaPostInv[1][1] / det, -SigmaPostInv[0][1] / det],
        [-SigmaPostInv[1][0] / det, SigmaPostInv[0][0] / det]
      ];

      // X^T y
      const Xty = [0, 0];
      for (let i = 0; i < n; i++) {
        for (let j = 0; j < 2; j++) {
          Xty[j] += X[i][j] * y[i];
        }
      }

      // μ_post
      const muPost = [0, 0];
      for (let i = 0; i < 2; i++) {
        for (let j = 0; j < 2; j++) {
          muPost[i] += SigmaPost[i][j] * Xty[j] / sigma2Noise;
        }
      }

      // Cholesky decomposition of SigmaPost for sampling
      const L = [[0, 0], [0, 0]];
      L[0][0] = Math.sqrt(SigmaPost[0][0]);
      L[1][0] = SigmaPost[1][0] / L[0][0];
      L[1][1] = Math.sqrt(SigmaPost[1][1] - L[1][0] * L[1][0]);

      // Sample from posterior
      for (let s = 0; s < numSamples; s++) {
        const z = [gaussianRandom(), gaussianRandom()];
        const w = [
          muPost[0] + L[0][0] * z[0],
          muPost[1] + L[1][0] * z[0] + L[1][1] * z[1]
        ];
        sampledWeights.push(w);
      }

      return {muPost, SigmaPost};
    }

    function drawBayesianFit() {
      const canvas = document.getElementById('bayesianFit');
      const ctx = canvas.getContext('2d');
      const w = canvas.width;
      const h = canvas.height;
      const pad = 60;

      ctx.clearRect(0, 0, w, h);

      const {muPost, SigmaPost} = samplePosterior();

      // Data range
      const xs = dataPoints.map(p => p.x);
      const ys = dataPoints.map(p => p.y);
      const minX = Math.min(...xs) - 1;
      const maxX = Math.max(...xs) + 1;
      const minY = Math.min(...ys) - 5;
      const maxY = Math.max(...ys) + 5;

      const scaleX = (w - 2 * pad) / (maxX - minX);
      const scaleY = (h - 2 * pad) / (maxY - minY);

      function toCanvasX(x) { return pad + (x - minX) * scaleX; }
      function toCanvasY(y) { return h - pad - (y - minY) * scaleY; }

      // Draw axes
      ctx.strokeStyle = '#30363d';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(pad, h - pad);
      ctx.lineTo(w - pad, h - pad);
      ctx.moveTo(pad, pad);
      ctx.lineTo(pad, h - pad);
      ctx.stroke();

      // Draw "hairy caterpillar" - samples from posterior
      ctx.globalAlpha = 0.1;
      for (const weights of sampledWeights) {
        ctx.strokeStyle = '#58a6ff';
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(toCanvasX(minX), toCanvasY(weights[0] + weights[1] * minX));
        ctx.lineTo(toCanvasX(maxX), toCanvasY(weights[0] + weights[1] * maxX));
        ctx.stroke();
      }
      ctx.globalAlpha = 1.0;

      // Draw posterior mean
      ctx.strokeStyle = '#4ecdc4';
      ctx.lineWidth = 3;
      ctx.beginPath();
      ctx.moveTo(toCanvasX(minX), toCanvasY(muPost[0] + muPost[1] * minX));
      ctx.lineTo(toCanvasX(maxX), toCanvasY(muPost[0] + muPost[1] * maxX));
      ctx.stroke();

      // Draw points
      for (const p of dataPoints) {
        ctx.fillStyle = '#ffe66d';
        ctx.beginPath();
        ctx.arc(toCanvasX(p.x), toCanvasY(p.y), 4, 0, 2 * Math.PI);
        ctx.fill();
      }

      // Labels
      ctx.fillStyle = '#8b949e';
      ctx.font = '12px monospace';
      ctx.textAlign = 'center';
      ctx.fillText(`Posterior Mean: w₀ = ${muPost[0].toFixed(2)}, w₁ = ${muPost[1].toFixed(2)}`, w / 2, 30);

      // Update stats
      const postStd0 = Math.sqrt(SigmaPost[0][0]);
      const postStd1 = Math.sqrt(SigmaPost[1][1]);
      document.getElementById('bayesStats').innerHTML = `
        <strong>Posterior Mean:</strong> w₀ = ${muPost[0].toFixed(3)}, w₁ = ${muPost[1].toFixed(3)}<br>
        <strong>Posterior Std:</strong> σ(w₀) = ${postStd0.toFixed(3)}, σ(w₁) = ${postStd1.toFixed(3)}<br>
        <strong>95% CI for w₁:</strong> [${(muPost[1] - 1.96*postStd1).toFixed(3)}, ${(muPost[1] + 1.96*postStd1).toFixed(3)}]
      `;
    }

    function drawDistributionEvolution() {
      const canvas = document.getElementById('distributionEvolution');
      const ctx = canvas.getContext('2d');
      const w = canvas.width;
      const h = canvas.height;
      const pad = 40;

      ctx.clearRect(0, 0, w, h);

      // Draw three panels: Prior, Likelihood, Posterior
      const panelW = (w - 4 * pad) / 3;
      const panelH = h - 2 * pad;

      const panels = [
        {x: pad, label: 'Prior P(w)'},
        {x: pad * 2 + panelW, label: 'Likelihood P(D|w)'},
        {x: pad * 3 + panelW * 2, label: 'Posterior P(w|D)'}
      ];

      // Get posterior stats
      const {muPost, SigmaPost} = samplePosterior();

      // Compute OLS for likelihood visualization
      const n = dataPoints.length;
      let sumX = 0, sumY = 0, sumXY = 0, sumXX = 0;
      for (const p of dataPoints) {
        sumX += p.x;
        sumY += p.y;
        sumXY += p.x * p.y;
        sumXX += p.x * p.x;
      }
      const w1OLS = (n * sumXY - sumX * sumY) / (n * sumXX - sumX * sumX);
      const w0OLS = (sumY - w1OLS * sumX) / n;

      for (let i = 0; i < 3; i++) {
        const px = panels[i].x;
        const py = pad;

        // Draw panel border
        ctx.strokeStyle = '#30363d';
        ctx.lineWidth = 1;
        ctx.strokeRect(px, py, panelW, panelH);

        // Draw label
        ctx.fillStyle = '#8b949e';
        ctx.font = '11px sans-serif';
        ctx.textAlign = 'center';
        ctx.fillText(panels[i].label, px + panelW / 2, py - 10);

        // Draw 2D Gaussian
        const centerX = px + panelW / 2;
        const centerY = py + panelH / 2;

        let sigma, mu;
        if (i === 0) {
          // Prior: N(0, priorSigma^2 I)
          mu = [0, 0];
          sigma = [[priorSigma * priorSigma, 0], [0, priorSigma * priorSigma]];
        } else if (i === 1) {
          // Likelihood (approximated as Gaussian in weight space)
          mu = [w0OLS, w1OLS];
          const s = likelihoodSigma * 3;
          sigma = [[s * s, 0], [0, s * s]];
        } else {
          // Posterior
          mu = muPost;
          sigma = SigmaPost;
        }

        // Draw ellipse (2σ contour)
        const eigenDecomp = (S) => {
          const a = S[0][0], b = S[0][1], d = S[1][1];
          const trace = a + d;
          const det = a * d - b * b;
          const lambda1 = trace / 2 + Math.sqrt(trace * trace / 4 - det);
          const lambda2 = trace / 2 - Math.sqrt(trace * trace / 4 - det);
          const angle = b === 0 ? 0 : Math.atan2(lambda1 - a, b);
          return {lambda1, lambda2, angle};
        };

        const {lambda1, lambda2, angle} = eigenDecomp(sigma);
        const scale = 30;
        const rx = 2 * Math.sqrt(lambda1) * scale;
        const ry = 2 * Math.sqrt(lambda2) * scale;

        ctx.save();
        ctx.translate(centerX, centerY);
        ctx.rotate(angle);

        // Fill
        ctx.fillStyle = i === 0 ? 'rgba(255, 107, 107, 0.2)' : i === 1 ? 'rgba(88, 166, 255, 0.2)' : 'rgba(78, 205, 196, 0.2)';
        ctx.beginPath();
        ctx.ellipse(0, 0, rx, ry, 0, 0, 2 * Math.PI);
        ctx.fill();

        // Stroke
        ctx.strokeStyle = i === 0 ? '#ff6b6b' : i === 1 ? '#58a6ff' : '#4ecdc4';
        ctx.lineWidth = 2;
        ctx.stroke();

        ctx.restore();

        // Draw mean point
        ctx.fillStyle = i === 0 ? '#ff6b6b' : i === 1 ? '#58a6ff' : '#4ecdc4';
        ctx.beginPath();
        ctx.arc(centerX, centerY, 4, 0, 2 * Math.PI);
        ctx.fill();

        // Label mean
        ctx.fillStyle = '#8b949e';
        ctx.font = '9px monospace';
        ctx.textAlign = 'center';
        ctx.fillText(`μ=(${mu[0].toFixed(1)},${mu[1].toFixed(1)})`, centerX, py + panelH - 5);
      }
    }

    function drawComponentsViz() {
      const canvas = document.getElementById('componentsViz');
      const ctx = canvas.getContext('2d');
      const w = canvas.width;
      const h = canvas.height;

      ctx.clearRect(0, 0, w, h);

      // Get stats
      const {muPost, SigmaPost} = samplePosterior();
      const postStd1 = Math.sqrt(SigmaPost[1][1]);

      // Compute OLS
      const n = dataPoints.length;
      let sumX = 0, sumY = 0, sumXY = 0, sumXX = 0;
      for (const p of dataPoints) {
        sumX += p.x;
        sumY += p.y;
        sumXY += p.x * p.y;
        sumXX += p.x * p.x;
      }
      const w1OLS = (n * sumXY - sumX * sumY) / (n * sumXX - sumX * sumX);

      // Draw simplified 1D visualization of components
      const sections = [
        {label: 'Prior P(w₁)', color: '#ff6b6b', mu: 0, sigma: priorSigma},
        {label: 'Likelihood P(D|w₁)', color: '#58a6ff', mu: w1OLS, sigma: likelihoodSigma * 2},
        {label: 'Posterior P(w₁|D)', color: '#4ecdc4', mu: muPost[1], sigma: postStd1}
      ];

      const panelW = w / 3 - 20;
      const panelH = h - 60;
      const pad = 30;

      for (let i = 0; i < 3; i++) {
        const px = 10 + i * (panelW + 20);
        const py = 40;
        const sec = sections[i];

        // Draw Gaussian curve
        const xRange = 10;
        const yScale = panelH * 0.6;

        ctx.strokeStyle = sec.color;
        ctx.lineWidth = 3;
        ctx.beginPath();

        for (let x = -xRange; x <= xRange; x += 0.1) {
          const canvasX = px + panelW / 2 + (x / xRange) * panelW / 2;
          const gaussVal = Math.exp(-0.5 * Math.pow((x - sec.mu) / sec.sigma, 2));
          const canvasY = py + panelH - gaussVal * yScale;

          if (x === -xRange) ctx.moveTo(canvasX, canvasY);
          else ctx.lineTo(canvasX, canvasY);
        }
        ctx.stroke();

        // Fill under curve
        ctx.lineTo(px + panelW, py + panelH);
        ctx.lineTo(px, py + panelH);
        ctx.closePath();
        ctx.fillStyle = sec.color + '30';
        ctx.fill();

        // Label
        ctx.fillStyle = sec.color;
        ctx.font = '14px sans-serif';
        ctx.textAlign = 'center';
        ctx.fillText(sec.label, px + panelW / 2, py - 10);

        // Draw vertical line at mean
        ctx.strokeStyle = sec.color;
        ctx.lineWidth = 2;
        ctx.setLineDash([5, 5]);
        ctx.beginPath();
        const meanX = px + panelW / 2 + (sec.mu / xRange) * panelW / 2;
        ctx.moveTo(meanX, py);
        ctx.lineTo(meanX, py + panelH);
        ctx.stroke();
        ctx.setLineDash([]);

        // Axis
        ctx.strokeStyle = '#30363d';
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(px, py + panelH);
        ctx.lineTo(px + panelW, py + panelH);
        ctx.stroke();
      }

      // Update components info
      document.getElementById('componentsInfo').innerHTML = `
        <strong>Prior:</strong> Centered at 0, spread = ${priorSigma.toFixed(2)} |
        <strong>Likelihood:</strong> Centered at ${w1OLS.toFixed(2)} (MLE) |
        <strong>Posterior:</strong> Compromise at ${muPost[1].toFixed(2)}, spread = ${postStd1.toFixed(2)}
      `;
    }

    // Event Listeners
    document.getElementById('priorSigma').addEventListener('input', (e) => {
      priorSigma = parseFloat(e.target.value);
      document.getElementById('priorSigmaValue').textContent = priorSigma.toFixed(1);
    });

    document.getElementById('likelihoodSigma').addEventListener('input', (e) => {
      likelihoodSigma = parseFloat(e.target.value);
      document.getElementById('likelihoodSigmaValue').textContent = likelihoodSigma.toFixed(1);
    });

    document.getElementById('numSamples').addEventListener('input', (e) => {
      numSamples = parseInt(e.target.value);
      document.getElementById('numSamplesValue').textContent = numSamples;
    });

    document.getElementById('dataNoise').addEventListener('input', (e) => {
      dataNoise = parseFloat(e.target.value);
      document.getElementById('dataNoiseValue').textContent = dataNoise.toFixed(1);
    });

    document.getElementById('resample').addEventListener('click', () => {
      drawBayesianFit();
      drawDistributionEvolution();
      drawComponentsViz();
    });

    document.getElementById('regenerateData').addEventListener('click', () => {
      generateData(dataNoise);
      drawBayesianFit();
      drawDistributionEvolution();
      drawComponentsViz();
    });

    // Render equations with KaTeX
    function renderBayesEquation() {
      const eqDiv = document.getElementById('bayesEquation');
      const latex = String.raw`P(\mathbf{w}|\mathcal{D}) = \frac{P(\mathcal{D}|\mathbf{w})P(\mathbf{w})}{P(\mathcal{D})} = \frac{\text{Likelihood} \times \text{Prior}}{\text{Evidence}}`;

      if (typeof katex !== 'undefined') {
        katex.render(latex, eqDiv, {displayMode: true, throwOnError: false});
      } else {
        setTimeout(renderBayesEquation, 100);
      }
    }

    // Initial render
    setTimeout(() => {
      renderBayesEquation();
      drawBayesianFit();
      drawDistributionEvolution();
      drawComponentsViz();
    }, 100);
  </script>
</body>
</html>
