<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Iris SNN Pedagogy Demo</title>
  <style>
    :root {
      --bg: #101317;
      --panel: #1b1f27;
      --accent: #58a6ff;
      --accent2: #f78166;
      --grid: #30363d;
      --text: #e6edf3;
      --muted: #8b949e;
    }
    * { box-sizing: border-box; }
    body {
      margin: 0;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "SF Mono", monospace;
      background: var(--bg);
      color: var(--text);
    }
    #app {
      display: flex;
      flex-direction: column;
      height: 100vh;
    }
    header {
      padding: 8px 16px;
      border-bottom: 1px solid var(--grid);
      background: #0d1117;
      display: flex;
      align-items: baseline;
      justify-content: space-between;
      gap: 16px;
    }
    header h1 {
      margin: 0;
      font-size: 16px;
      font-weight: 600;
    }
    header .sub {
      font-size: 12px;
      color: var(--muted);
    }
    #main {
      flex: 1;
      display: grid;
      grid-template-columns: 260px 1.2fr 1fr;
      gap: 8px;
      padding: 8px;
      min-height: 0;
    }
    .panel {
      background: var(--panel);
      border-radius: 6px;
      border: 1px solid var(--grid);
      padding: 8px;
      display: flex;
      flex-direction: column;
      min-height: 0;
    }
    .panel h2 {
      margin: 0 0 6px 0;
      font-size: 13px;
      font-weight: 600;
      border-bottom: 1px solid rgba(255,255,255,0.04);
      padding-bottom: 4px;
    }
    .controls-group {
      margin-bottom: 8px;
      font-size: 12px;
    }
    .controls-group label {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      margin-bottom: 4px;
    }
    button {
      font-size: 12px;
      padding: 4px 8px;
      border-radius: 4px;
      border: 1px solid var(--grid);
      background: #161b22;
      color: var(--text);
      cursor: pointer;
      margin: 2px 2px 2px 0;
    }
    button:hover {
      background: #1f2933;
    }
    button:disabled {
      opacity: 0.5;
      cursor: default;
    }
    input[type="checkbox"] { cursor: pointer; }

    #stats {
      font-size: 12px;
      line-height: 1.4;
      margin-top: 4px;
      padding: 4px;
      background: #11151d;
      border-radius: 4px;
      border: 1px solid rgba(255,255,255,0.03);
    }

    /* Network layout */
    #networkPanel {
      position: relative;
      overflow: hidden;
      display: flex;
      justify-content: space-around;
      align-items: stretch;
      padding-bottom: 12px;
    }
    .layer {
      display: flex;
      flex-direction: column;
      justify-content: space-around;
      align-items: center;
      gap: 6px;
      padding: 4px 2px;
      flex: 0 0 auto;
    }
    .layer-title {
      font-size: 11px;
      color: var(--muted);
      margin-bottom: 4px;
    }
    .neuron {
      position: relative;
      width: 44px;
      height: 96px;
      border-radius: 4px;
      border: 1px solid var(--grid);
      background: #0d1117;
      overflow: hidden;
      display: flex;
      align-items: flex-end;
      justify-content: center;
    }
    .neuron-fill {
      position: absolute;
      left: 0;
      right: 0;
      bottom: 16px;
      height: 0%;
      background: linear-gradient(180deg, rgba(88,166,255,0.9), rgba(88,166,255,0.1));
      transition: height 0.25s ease, background 0.25s ease;
    }
    .neuron-label {
      position: absolute;
      top: 2px;
      left: 2px;
      right: 2px;
      font-size: 9px;
      color: var(--muted);
      text-align: left;
      pointer-events: none;
    }
    .neuron-level {
      position: absolute;
      bottom: 18px;
      right: 2px;
      font-size: 9px;
      color: var(--muted);
      background: rgba(0,0,0,0.4);
      padding: 1px 3px;
      border-radius: 2px;
    }
    .neuron-raster {
      position: absolute;
      left: 2px;
      right: 2px;
      bottom: 2px;
      height: 12px;
      display: grid;
      grid-template-columns: repeat(16, 1fr);
      gap: 1px;
    }
    .neuron-raster-cell {
      background: #080c12;
      border-radius: 1px;
      transition: background 0.15s ease;
    }
    .neuron-raster-cell.on {
      background: #f0f6fc;
      box-shadow: 0 0 3px rgba(240,246,252,0.8);
    }
    .connection {
      position: absolute;
      border-top: 1px solid rgba(80,80,80,0.6);
      transform-origin: left center;
      pointer-events: none;
      transition: border-top-width 0.25s ease, border-top-color 0.25s ease;
    }

    /* Metrics panel */
    #lossCanvas {
      width: 100%;
      height: 160px;
      border-radius: 4px;
      border: 1px solid var(--grid);
      background: #0d1117;
    }
    .metrics-section-title {
      font-size: 11px;
      color: var(--muted);
      margin: 6px 0 2px;
    }
    #confusionContainer {
      display: flex;
      gap: 8px;
      margin-top: 4px;
      font-size: 11px;
    }
    .conf-panel {
      flex: 1;
      min-width: 0;
    }
    table.confusion {
      width: 100%;
      border-collapse: collapse;
    }
    table.confusion th,
    table.confusion td {
      border: 1px solid var(--grid);
      padding: 2px 3px;
      text-align: center;
      font-size: 10px;
    }
    table.confusion th {
      background: #11151d;
      font-weight: 500;
    }
    table.confusion td.diag {
      background: rgba(80, 184, 60, 0.3);
    }
    table.confusion td.off {
      background: rgba(184, 60, 60, 0.15);
    }

    /* Sample / spot check */
    #samplePanel {
      font-size: 11px;
      margin-top: 8px;
      padding: 4px;
      background: #11151d;
      border-radius: 4px;
      border: 1px solid rgba(255,255,255,0.03);
    }
    #sampleInfo {
      margin-top: 4px;
      line-height: 1.4;
    }
    .prob-bars {
      margin-top: 4px;
      display: flex;
      flex-direction: column;
      gap: 2px;
    }
    .prob-row {
      display: grid;
      grid-template-columns: 70px 1fr 38px;
      align-items: center;
      gap: 4px;
    }
    .prob-label {
      text-align: right;
      color: var(--muted);
    }
    .prob-bar-track {
      height: 10px;
      background: #0d1117;
      border-radius: 10px;
      overflow: hidden;
      border: 1px solid var(--grid);
    }
    .prob-bar-fill {
      height: 100%;
      width: 0%;
      background: linear-gradient(90deg, var(--accent), #3fb950);
      transition: width 0.25s ease;
    }
    .prob-val {
      text-align: right;
      font-variant-numeric: tabular-nums;
    }

    /* FAB and modal */
    .fab {
      position: fixed;
      right: 20px;
      bottom: 20px;
      width: 56px;
      height: 56px;
      border-radius: 50%;
      background: var(--accent);
      color: #0d1117;
      border: none;
      cursor: pointer;
      box-shadow: 0 4px 12px rgba(0,0,0,0.3);
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 24px;
      font-weight: 600;
      z-index: 1000;
      transition: transform 0.2s, box-shadow 0.2s;
    }
    .fab:hover {
      transform: scale(1.1);
      box-shadow: 0 6px 16px rgba(0,0,0,0.4);
    }
    .docs-modal {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0,0,0,0.6);
      backdrop-filter: blur(3px);
      z-index: 2000;
      align-items: center;
      justify-content: center;
    }
    .docs-modal.active {
      display: flex;
    }
    .docs-content {
      max-width: 700px;
      max-height: 80vh;
      background: var(--panel);
      border: 1px solid var(--grid);
      border-radius: 8px;
      box-shadow: 0 8px 32px rgba(0,0,0,0.5);
      overflow-y: auto;
      margin: 20px;
    }
    .docs-header {
      padding: 16px 20px;
      border-bottom: 1px solid var(--grid);
      display: flex;
      align-items: center;
      justify-content: space-between;
      position: sticky;
      top: 0;
      background: var(--panel);
      z-index: 1;
    }
    .docs-header h2 {
      margin: 0;
      font-size: 18px;
      font-weight: 600;
    }
    .close-btn {
      width: 32px;
      height: 32px;
      border-radius: 50%;
      border: 1px solid var(--grid);
      background: var(--bg);
      color: var(--muted);
      font-size: 20px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.2s;
    }
    .close-btn:hover {
      background: var(--grid);
      color: var(--text);
    }
    .docs-body {
      padding: 20px;
    }
    .docs-body h3 {
      margin: 16px 0 8px 0;
      font-size: 15px;
      font-weight: 600;
      color: var(--accent);
    }
    .docs-body h3:first-child {
      margin-top: 0;
    }
    .docs-body p {
      margin: 8px 0;
      line-height: 1.6;
      color: var(--muted);
    }
    .docs-body ul {
      margin: 8px 0;
      padding-left: 20px;
      color: var(--muted);
    }
    .docs-body li {
      margin: 4px 0;
      line-height: 1.5;
    }
    .docs-body code {
      background: var(--bg);
      padding: 2px 6px;
      border-radius: 3px;
      font-family: monospace;
      font-size: 12px;
      color: var(--accent2);
    }

    /* Scroll for narrow windows */
    @media (max-width: 1100px) {
      #main {
        grid-template-columns: 1fr;
        grid-auto-rows: minmax(0, auto);
      }
      .controls-group label {
        display: block;
        margin-bottom: 8px;
      }
      .controls-group select,
      .controls-group input {
        width: 100%;
      }
    }
  </style>
</head>
<body>
<div id="app">
  <header>
    <div>
      <h1>Iris Rate-coded SNN Demo</h1>
      <div class="sub">4 → hidden → 3 network, 16 time bins with spike rasters, rate-coded interpretation</div>
    </div>
    <div class="sub">Pedagogical view: loss, confusion matrices, random vs trained, spot check</div>
  </header>

  <div id="main">
    <!-- Controls -->
    <div class="panel" id="controlsPanel">
      <h2>Controls</h2>
      <div class="controls-group">
        <button id="btnInit">Reset weights</button>
        <button id="btnTrainToggle">Start training</button>
        <button id="btnStep">Single step</button>
      </div>
      <div class="controls-group">
        <label>
          <input type="checkbox" id="slowMode" checked>
          Slow mode (visual, 1 step / tick)
        </label>
        <label>
          Learning rate:
          <select id="lrSelect">
            <option value="0.02">0.02</option>
            <option value="0.05" selected>0.05</option>
            <option value="0.1">0.10</option>
          </select>
        </label>
        <label>
          Batch size:
          <select id="batchSelect">
            <option value="8">8</option>
            <option value="16" selected>16</option>
            <option value="32">32</option>
          </select>
        </label>
      </div>
      <div class="controls-group">
        <div style="font-size:11px;color:var(--muted);line-height:1.5;">
          <strong>SNN Interpretation:</strong> Each rate bar shows spike count over a 16-bin time window.
          The raster below each neuron shows one possible spike train consistent with that rate (Bernoulli sampling).
          Training uses the rate model (backprop on expected spike counts).
          In a true SNN, we would unroll time, simulate LIF dynamics, and use surrogate gradients through spikes (BPTT).
        </div>
      </div>
      <div class="controls-group">
        <div style="font-size:11px;color:var(--muted);">
          This demo uses a small synthetic Iris-like dataset (3 Gaussian clusters in ℝ⁴) for clarity.
          Swap the generator with real Iris data if desired.
        </div>
      </div>
      <div id="stats"></div>

      <div id="samplePanel">
        <div style="display:flex;align-items:center;justify-content:space-between;">
          <div>Spot check sample</div>
          <button id="btnNextSample">Next sample</button>
        </div>
        <div id="sampleInfo"></div>
        <div class="prob-bars" id="sampleProbs"></div>
      </div>
    </div>

    <!-- Network -->
    <div class="panel">
      <h2>SNN view (rate bars + spike rasters)</h2>
      <div id="networkPanel"></div>
    </div>

    <!-- Metrics -->
    <div class="panel">
      <h2>Training metrics</h2>
      <div class="metrics-section-title">Loss curve (cross-entropy)</div>
      <canvas id="lossCanvas" width="400" height="180"></canvas>

      <div class="metrics-section-title">Confusion matrices (3 classes)</div>
      <div id="confusionContainer">
        <div class="conf-panel">
          <div style="font-size:11px;margin-bottom:2px;">Random baseline (uniform guess)</div>
          <table id="confRandom" class="confusion"></table>
        </div>
        <div class="conf-panel">
          <div style="font-size:11px;margin-bottom:2px;">Current model</div>
          <table id="confModel" class="confusion"></table>
        </div>
      </div>
    </div>
  </div>
</div>

<!-- Documentation FAB and Modal -->
<button class="fab" id="docsFab" title="Documentation">?</button>

<div class="docs-modal" id="docsModal">
  <div class="docs-content">
    <div class="docs-header">
      <h2>SNN Demo Documentation</h2>
      <button class="close-btn" id="closeDocsModal">×</button>
    </div>
    <div class="docs-body" id="docsBody">
      <h3>SNN Interpretation</h3>
      <p>
        Each <strong>rate bar</strong> shows spike count over a 16-bin time window.
        The <strong>raster</strong> below each neuron shows one possible spike train consistent
        with that rate (Bernoulli sampling).
      </p>
      <p>
        <strong>Training</strong> uses the rate model (backprop on expected spike counts).
        In a true SNN, we would unroll time, simulate LIF dynamics, and use surrogate
        gradients through spikes (BPTT).
      </p>

      <h3>Rate-Coded vs. True SNN</h3>
      <ul>
        <li><strong>Rate Model (this demo):</strong> Neurons encode information as firing rates
          averaged over time. Training uses standard backpropagation on these rates.</li>
        <li><strong>True SNN:</strong> Would simulate discrete time steps with Leaky Integrate-and-Fire
          (LIF) dynamics, generate actual spikes, and use surrogate gradient descent through
          non-differentiable spike events.</li>
        <li><strong>Spike Rasters:</strong> The 16-cell visualization below each neuron shows
          one possible realization of spikes drawn from a Bernoulli distribution with probability
          equal to the firing rate.</li>
      </ul>

      <h3>Dataset</h3>
      <p>
        This demo uses a <strong>small synthetic Iris-like dataset</strong> (3 Gaussian clusters in ℝ⁴)
        for clarity. The three classes represent:
      </p>
      <ul>
        <li><code>Setosa</code> — Compact cluster with small feature values</li>
        <li><code>Versicolor</code> — Medium spread, intermediate values</li>
        <li><code>Virginica</code> — Larger spread, higher feature values</li>
      </ul>
      <p>
        Each sample has 4 features: Sepal Length, Sepal Width, Petal Length, Petal Width.
        You can swap the generator with real Iris data if desired.
      </p>

      <h3>Network Architecture</h3>
      <p>
        <strong>4 inputs → 6 hidden → 3 outputs</strong>
      </p>
      <ul>
        <li><strong>Input layer:</strong> 4 neurons encoding normalized features</li>
        <li><strong>Hidden layer:</strong> 6 neurons with sigmoid activation</li>
        <li><strong>Output layer:</strong> 3 neurons with softmax (class probabilities)</li>
        <li><strong>Training:</strong> Cross-entropy loss, mini-batch SGD</li>
      </ul>

      <h3>Confusion Matrix</h3>
      <p>
        The <strong>random baseline</strong> shows performance of a uniform random classifier
        (33.3% accuracy for 3 classes). The <strong>current model</strong> matrix updates
        in real-time as the network trains.
      </p>
      <p>
        Diagonal cells (green) are correct predictions; off-diagonal cells (red) are errors.
      </p>
    </div>
  </div>
</div>

<script>
  // ----- configuration -----
  const CONFIG = {
    NUM_INPUT: 4,
    NUM_HIDDEN: 6,
    NUM_OUTPUT: 3,
    RATE_LEVELS: 16,
    MAX_LOSS_POINTS: 500,
    LEARNING_RATE: 0.05,
    BATCH_SIZE: 16
  };

  const LAYOUT = {
    NEURON_HEIGHT: 96,
    NEURON_WIDTH: 44,
    RASTER_HEIGHT: 12,
    RASTER_BOTTOM: 2,
    LABEL_BOTTOM: 18,
    FILL_BOTTOM: 16
  };

  const NEURON_STYLES = {
    input: { baseHue: 210, hueRange: 0, saturation: 80, lightness: 55 },
    hidden: { baseHue: 210, hueRange: 150, saturation: 80, lightness: 55 },
    output: { baseHue: 40, hueRange: 40, saturation: 80, lightness: 55 }
  };

  const LABELS = {
    input: ['Sepal L', 'Sepal W', 'Petal L', 'Petal W'],
    output: ['Setosa', 'Versicolor', 'Virginica']
  };

  // State objects
  const network = {
    W1: null,
    b1: null,
    W2: null,
    b2: null
  };

  const dataset = {
    samples: [],
    featureMin: new Array(CONFIG.NUM_INPUT).fill(Infinity),
    featureMax: new Array(CONFIG.NUM_INPUT).fill(-Infinity)
  };

  const training = {
    lossHistory: [],
    stepCount: 0,
    timer: null,
    isTraining: false,
    randomConfusion: null
  };

  const ui = {
    neuronLayers: { input: [], hidden: [], output: [] },
    connections: [],
    currentSampleIndex: 0
  };

  // ----- Helper functions -----

  // DOM helpers
  function createElement(tag, className, content = '') {
    const el = document.createElement(tag);
    if (className) el.className = className;
    if (content) el.textContent = content;
    return el;
  }

  function createNeuronRasterCell() {
    return createElement('div', 'neuron-raster-cell');
  }

  // Color and gradient helpers
  function makeGradient(hue, sat = 80, light = 55) {
    return `linear-gradient(180deg, hsla(${hue},${sat}%,${light}%,0.9), hsla(${hue},${sat}%,${light - 20}%,0.15))`;
  }

  function getRGBAGradient(r, g, b) {
    return `linear-gradient(180deg, rgba(${r},${g},${b},0.9), rgba(${r},${g},${b},0.1))`;
  }

  function getNeuronColor(layerType, frac) {
    const style = NEURON_STYLES[layerType];
    if (!style) return getRGBAGradient(88, 166, 255);

    if (layerType === 'input') {
      return getRGBAGradient(88, 166, 255);
    }

    const hue = style.baseHue - frac * style.hueRange;
    return makeGradient(hue, style.saturation, style.lightness);
  }

  // Gaussian RNG for synthetic clusters
  let _gaussSpare = null;
  function gaussianRandom() {
    if (_gaussSpare !== null) {
      const v = _gaussSpare;
      _gaussSpare = null;
      return v;
    }
    let u = 0, v = 0;
    while (u === 0) u = Math.random();
    while (v === 0) v = Math.random();
    const mag = Math.sqrt(-2.0 * Math.log(u));
    const z0 = mag * Math.cos(2 * Math.PI * v);
    const z1 = mag * Math.sin(2 * Math.PI * v);
    _gaussSpare = z1;
    return z0;
  }

  function generateSyntheticIris() {
    // Approximate class centers and spreads in original Iris ranges
    const centers = [
      [5.0, 3.4, 1.5, 0.2], // setosa
      [6.0, 2.8, 4.5, 1.3], // versicolor
      [6.7, 3.1, 5.5, 2.1]  // virginica
    ];
    const spreads = [
      [0.2, 0.2, 0.2, 0.05],
      [0.4, 0.3, 0.4, 0.2],
      [0.5, 0.3, 0.6, 0.25]
    ];
    const nPerClass = 50;
    const data = [];
    dataset.featureMin.fill(Infinity);
    dataset.featureMax.fill(-Infinity);
    for (let c = 0; c < CONFIG.NUM_OUTPUT; c++) {
      for (let n = 0; n < nPerClass; n++) {
        const raw = [];
        for (let d = 0; d < CONFIG.NUM_INPUT; d++) {
          const val = centers[c][d] + spreads[c][d] * gaussianRandom();
          raw.push(val);
          if (val < dataset.featureMin[d]) dataset.featureMin[d] = val;
          if (val > dataset.featureMax[d]) dataset.featureMax[d] = val;
        }
        data.push({ raw, y: c });
      }
    }
    // z-score normalization for training
    const mean = new Array(CONFIG.NUM_INPUT).fill(0);
    const std = new Array(CONFIG.NUM_INPUT).fill(0);
    const N = data.length;
    for (const s of data) {
      for (let d = 0; d < CONFIG.NUM_INPUT; d++) {
        mean[d] += s.raw[d];
      }
    }
    for (let d = 0; d < CONFIG.NUM_INPUT; d++) {
      mean[d] /= N;
    }
    for (const s of data) {
      for (let d = 0; d < CONFIG.NUM_INPUT; d++) {
        const diff = s.raw[d] - mean[d];
        std[d] += diff * diff;
      }
    }
    for (let d = 0; d < CONFIG.NUM_INPUT; d++) {
      std[d] = Math.sqrt(std[d] / N) || 1.0;
    }
    for (const s of data) {
      const x = new Array(CONFIG.NUM_INPUT);
      for (let d = 0; d < CONFIG.NUM_INPUT; d++) {
        x[d] = (s.raw[d] - mean[d]) / std[d];
      }
      s.x = x;
    }
    return data;
  }

  // ----- network math -----
  function initNetwork() {
    network.W1 = new Array(CONFIG.NUM_HIDDEN);
    network.b1 = new Array(CONFIG.NUM_HIDDEN);
    network.W2 = new Array(CONFIG.NUM_OUTPUT);
    network.b2 = new Array(CONFIG.NUM_OUTPUT);
    for (let j = 0; j < CONFIG.NUM_HIDDEN; j++) {
      network.W1[j] = new Array(CONFIG.NUM_INPUT);
      for (let i = 0; i < CONFIG.NUM_INPUT; i++) {
        network.W1[j][i] = (Math.random() - 0.5) * 0.5;
      }
      network.b1[j] = 0;
    }
    for (let k = 0; k < CONFIG.NUM_OUTPUT; k++) {
      network.W2[k] = new Array(CONFIG.NUM_HIDDEN);
      for (let j = 0; j < CONFIG.NUM_HIDDEN; j++) {
        network.W2[k][j] = (Math.random() - 0.5) * 0.5;
      }
      network.b2[k] = 0;
    }
    training.lossHistory = [];
    training.stepCount = 0;
  }

  function sigmoid(x) {
    return 1 / (1 + Math.exp(-x));
  }
  function softmax(logits) {
    let maxLogit = -Infinity;
    for (let i = 0; i < logits.length; i++) {
      if (logits[i] > maxLogit) maxLogit = logits[i];
    }
    const exps = new Array(logits.length);
    let sum = 0;
    for (let i = 0; i < logits.length; i++) {
      const e = Math.exp(logits[i] - maxLogit);
      exps[i] = e;
      sum += e;
    }
    const probs = new Array(logits.length);
    for (let i = 0; i < logits.length; i++) {
      probs[i] = exps[i] / sum;
    }
    return probs;
  }
  function forwardSingle(x) {
    const z1 = new Array(CONFIG.NUM_HIDDEN);
    const h = new Array(CONFIG.NUM_HIDDEN);
    for (let j = 0; j < CONFIG.NUM_HIDDEN; j++) {
      let sum = network.b1[j];
      for (let i = 0; i < CONFIG.NUM_INPUT; i++) {
        sum += network.W1[j][i] * x[i];
      }
      z1[j] = sum;
      h[j] = sigmoid(sum);
    }
    const z2 = new Array(CONFIG.NUM_OUTPUT);
    for (let k = 0; k < CONFIG.NUM_OUTPUT; k++) {
      let sum = network.b2[k];
      for (let j = 0; j < CONFIG.NUM_HIDDEN; j++) {
        sum += network.W2[k][j] * h[j];
      }
      z2[k] = sum;
    }
    const probs = softmax(z2);
    return { z1, h, z2, probs };
  }
  function argmax(arr) {
    let best = 0;
    let bestVal = arr[0];
    for (let i = 1; i < arr.length; i++) {
      if (arr[i] > bestVal) {
        bestVal = arr[i];
        best = i;
      }
    }
    return best;
  }

  function trainStep() {
    if (!dataset.samples || dataset.samples.length === 0) return;
    const batchSize = CONFIG.BATCH_SIZE;
    const n = dataset.samples.length;
    const z1Batch = new Array(batchSize);
    const hBatch = new Array(batchSize);
    const z2Batch = new Array(batchSize);
    const pBatch = new Array(batchSize);
    const yBatch = new Array(batchSize);
    const xBatch = new Array(batchSize);

    // sample batch
    for (let s = 0; s < batchSize; s++) {
      const idx = Math.floor(Math.random() * n);
      const sample = dataset.samples[idx];
      xBatch[s] = sample.x.slice();
      yBatch[s] = sample.y;
    }

    // forward
    let loss = 0;
    for (let s = 0; s < batchSize; s++) {
      const x = xBatch[s];
      const { z1, h, z2, probs } = forwardSingle(x);
      z1Batch[s] = z1;
      hBatch[s] = h;
      z2Batch[s] = z2;
      pBatch[s] = probs;
      loss += -Math.log(probs[yBatch[s]] + 1e-9);
    }
    loss /= batchSize;

    // backward
    const dW2 = new Array(CONFIG.NUM_OUTPUT);
    const db2 = new Array(CONFIG.NUM_OUTPUT).fill(0);
    const dW1 = new Array(CONFIG.NUM_HIDDEN);
    const db1 = new Array(CONFIG.NUM_HIDDEN).fill(0);
    for (let k = 0; k < CONFIG.NUM_OUTPUT; k++) {
      dW2[k] = new Array(CONFIG.NUM_HIDDEN).fill(0);
    }
    for (let j = 0; j < CONFIG.NUM_HIDDEN; j++) {
      dW1[j] = new Array(CONFIG.NUM_INPUT).fill(0);
    }

    for (let s = 0; s < batchSize; s++) {
      const probs = pBatch[s];
      const h = hBatch[s];
      const x = xBatch[s];
      const y = yBatch[s];

      const dZ2 = new Array(CONFIG.NUM_OUTPUT);
      for (let k = 0; k < CONFIG.NUM_OUTPUT; k++) {
        dZ2[k] = probs[k] - (k === y ? 1 : 0);
      }
      // output layer grads
      for (let k = 0; k < CONFIG.NUM_OUTPUT; k++) {
        db2[k] += dZ2[k];
        for (let j = 0; j < CONFIG.NUM_HIDDEN; j++) {
          dW2[k][j] += dZ2[k] * h[j];
        }
      }
      // hidden layer
      const dH = new Array(CONFIG.NUM_HIDDEN).fill(0);
      for (let j = 0; j < CONFIG.NUM_HIDDEN; j++) {
        let sum = 0;
        for (let k = 0; k < CONFIG.NUM_OUTPUT; k++) {
          sum += dZ2[k] * network.W2[k][j];
        }
        dH[j] = sum;
      }
      for (let j = 0; j < CONFIG.NUM_HIDDEN; j++) {
        const sig = h[j];
        const dZ1 = dH[j] * sig * (1 - sig);
        db1[j] += dZ1;
        for (let i = 0; i < CONFIG.NUM_INPUT; i++) {
          dW1[j][i] += dZ1 * x[i];
        }
      }
    }

    const scale = CONFIG.LEARNING_RATE / batchSize;
    for (let k = 0; k < CONFIG.NUM_OUTPUT; k++) {
      network.b2[k] -= scale * db2[k];
      for (let j = 0; j < CONFIG.NUM_HIDDEN; j++) {
        network.W2[k][j] -= scale * dW2[k][j];
      }
    }
    for (let j = 0; j < CONFIG.NUM_HIDDEN; j++) {
      network.b1[j] -= scale * db1[j];
      for (let i = 0; i < CONFIG.NUM_INPUT; i++) {
        network.W1[j][i] -= scale * dW1[j][i];
      }
    }

    if (training.lossHistory.length >= CONFIG.MAX_LOSS_POINTS) training.lossHistory.shift();
    training.lossHistory.push({ step: training.stepCount, loss });
    training.stepCount++;
  }

  // ----- visualization helpers -----
  function createNeuron(labelText, layerKey) {
    const wrapper = createElement('div', 'neuron');
    const fill = createElement('div', 'neuron-fill');
    const label = createElement('div', 'neuron-label', labelText);
    const level = createElement('div', 'neuron-level', `0/${CONFIG.RATE_LEVELS - 1}`);

    // Create spike raster (16 time bins)
    const raster = createElement('div', 'neuron-raster');
    const rasterCells = [];
    for (let t = 0; t < CONFIG.RATE_LEVELS; t++) {
      const cell = createNeuronRasterCell();
      raster.appendChild(cell);
      rasterCells.push(cell);
    }

    wrapper.appendChild(fill);
    wrapper.appendChild(label);
    wrapper.appendChild(level);
    wrapper.appendChild(raster);
    ui.neuronLayers[layerKey].push({ wrapper, fill, level, rasterCells });
    return wrapper;
  }

  function buildNetworkDiagram() {
    const panel = document.getElementById('networkPanel');
    panel.innerHTML = '';
    ui.neuronLayers.input.length = 0;
    ui.neuronLayers.hidden.length = 0;
    ui.neuronLayers.output.length = 0;
    ui.connections.length = 0;

    const inputLayer = createElement('div', 'layer');
    const hiddenLayer = createElement('div', 'layer');
    const outputLayer = createElement('div', 'layer');

    const inTitle = createElement('div', 'layer-title', 'Inputs (features)');
    const hTitle = createElement('div', 'layer-title', 'Hidden (rate neurons)');
    const outTitle = createElement('div', 'layer-title', 'Outputs (classes)');

    inputLayer.appendChild(inTitle);
    hiddenLayer.appendChild(hTitle);
    outputLayer.appendChild(outTitle);

    for (let i = 0; i < CONFIG.NUM_INPUT; i++) {
      inputLayer.appendChild(createNeuron(LABELS.input[i], 'input'));
    }
    for (let j = 0; j < CONFIG.NUM_HIDDEN; j++) {
      hiddenLayer.appendChild(createNeuron('H' + (j + 1), 'hidden'));
    }
    for (let k = 0; k < CONFIG.NUM_OUTPUT; k++) {
      outputLayer.appendChild(createNeuron(LABELS.output[k], 'output'));
    }

    panel.appendChild(inputLayer);
    panel.appendChild(hiddenLayer);
    panel.appendChild(outputLayer);

    // connections as offset divs with single borders
    requestAnimationFrame(() => {
      layoutConnections(panel);
      updateConnectionStyles();
      updateNetworkVisualization();
    });
  }

  function layoutConnections(panel) {
    const panelRect = panel.getBoundingClientRect();
    function connect(layerFrom, layerTo, matrixName) {
      for (let dst = 0; dst < layerTo.length; dst++) {
        const dstElem = layerTo[dst].wrapper;
        const dr = dstElem.getBoundingClientRect();
        const y2 = dr.top + dr.height / 2 - panelRect.top;
        const x2 = dr.left - panelRect.left;
        for (let src = 0; src < layerFrom.length; src++) {
          const srcElem = layerFrom[src].wrapper;
          const sr = srcElem.getBoundingClientRect();
          const y1 = sr.top + sr.height / 2 - panelRect.top;
          const x1 = sr.right - panelRect.left;
          const dx = x2 - x1;
          const dy = y2 - y1;
          const len = Math.sqrt(dx * dx + dy * dy);
          const angle = Math.atan2(dy, dx) * 180 / Math.PI;
          const line = createElement('div', 'connection');
          line.style.left = x1 + 'px';
          line.style.top = y1 + 'px';
          line.style.width = len + 'px';
          line.style.transform = 'rotate(' + angle + 'deg)';
          panel.appendChild(line);
          ui.connections.push({ div: line, matrix: matrixName, src, dst });
        }
      }
    }
    connect(ui.neuronLayers.input, ui.neuronLayers.hidden, 'W1');
    connect(ui.neuronLayers.hidden, ui.neuronLayers.output, 'W2');
  }

  function activationToRateLevel(v) {
    const vClamped = Math.max(0, Math.min(1, v));
    const level = Math.round(vClamped * (CONFIG.RATE_LEVELS - 1));
    const frac = level / (CONFIG.RATE_LEVELS - 1);
    return { level, frac };
  }

  // Generate spike train from rate using Bernoulli sampling
  function setRasterFromRate(neuron, rate) {
    if (!neuron.rasterCells) return;
    for (let t = 0; t < CONFIG.RATE_LEVELS; t++) {
      const cell = neuron.rasterCells[t];
      const spike = Math.random() < rate; // Bernoulli(rate)
      cell.classList.toggle('on', spike);
    }
  }

  // Unified neuron display update
  function updateNeuronDisplay(neuron, value, layerType) {
    const { level, frac } = activationToRateLevel(value);
    neuron.fill.style.height = (frac * 100).toFixed(1) + '%';
    neuron.fill.style.background = getNeuronColor(layerType, frac);
    neuron.level.textContent = level + '/' + (CONFIG.RATE_LEVELS - 1);
    setRasterFromRate(neuron, frac);
  }

  function updateNetworkVisualization() {
    if (!dataset.samples || dataset.samples.length === 0) return;
    const sample = dataset.samples[Math.floor(Math.random() * dataset.samples.length)];
    const res = forwardSingle(sample.x);

    // inputs: normalize raw features into [0,1] by min/max
    for (let d = 0; d < CONFIG.NUM_INPUT; d++) {
      const neuron = ui.neuronLayers.input[d];
      const min = dataset.featureMin[d];
      const max = dataset.featureMax[d];
      const value = (sample.raw[d] - min) / (max - min || 1);
      updateNeuronDisplay(neuron, value, 'input');
    }

    // hidden
    for (let j = 0; j < CONFIG.NUM_HIDDEN; j++) {
      const neuron = ui.neuronLayers.hidden[j];
      updateNeuronDisplay(neuron, res.h[j], 'hidden');
    }

    // outputs: probabilities
    for (let k = 0; k < CONFIG.NUM_OUTPUT; k++) {
      const neuron = ui.neuronLayers.output[k];
      updateNeuronDisplay(neuron, res.probs[k], 'output');
    }
  }

  function getMaxAbsWeight() {
    let maxAbs = 0;
    for (let j = 0; j < CONFIG.NUM_HIDDEN; j++) {
      for (let i = 0; i < CONFIG.NUM_INPUT; i++) {
        maxAbs = Math.max(maxAbs, Math.abs(network.W1[j][i]));
      }
    }
    for (let k = 0; k < CONFIG.NUM_OUTPUT; k++) {
      for (let j = 0; j < CONFIG.NUM_HIDDEN; j++) {
        maxAbs = Math.max(maxAbs, Math.abs(network.W2[k][j]));
      }
    }
    return Math.max(maxAbs, 1e-6);
  }

  function updateConnectionStyles() {
    if (!ui.connections.length) return;
    const maxAbs = getMaxAbsWeight();

    for (const conn of ui.connections) {
      const w = conn.matrix === 'W1'
        ? network.W1[conn.dst][conn.src]
        : network.W2[conn.dst][conn.src];

      const strength = Math.min(1, Math.abs(w) / maxAbs);
      const width = 0.6 + 4.0 * strength;
      const hue = w >= 0 ? 200 : 20; // blue vs red
      const alpha = 0.15 + 0.75 * strength;

      conn.div.style.borderTopWidth = `${width.toFixed(2)}px`;
      conn.div.style.borderTopColor = `hsla(${hue},80%,55%,${alpha.toFixed(2)})`;
    }
  }

  function drawLossCurve() {
    const canvas = document.getElementById('lossCanvas');
    const ctx = canvas.getContext('2d');
    const w = canvas.width;
    const h = canvas.height;
    ctx.clearRect(0, 0, w, h);

    const left = 32, right = w - 10;
    const top = 10, bottom = h - 20;

    // axes
    ctx.strokeStyle = '#4b5563';
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(left, top);
    ctx.lineTo(left, bottom);
    ctx.lineTo(right, bottom);
    ctx.stroke();

    if (training.lossHistory.length < 2) return;

    let minL = Infinity, maxL = -Infinity;
    for (const p of training.lossHistory) {
      if (p.loss < minL) minL = p.loss;
      if (p.loss > maxL) maxL = p.loss;
    }
    if (!isFinite(minL) || !isFinite(maxL)) return;
    if (minL === maxL) maxL = minL + 1;

    ctx.strokeStyle = '#2ea043';
    ctx.lineWidth = 1.2;
    ctx.beginPath();
    for (let i = 0; i < training.lossHistory.length; i++) {
      const p = training.lossHistory[i];
      const tx = i / Math.max(1, training.lossHistory.length - 1);
      const x = left + (right - left) * tx;
      const ty = (p.loss - minL) / (maxL - minL);
      const y = bottom - (bottom - top) * ty;
      if (i === 0) ctx.moveTo(x, y);
      else ctx.lineTo(x, y);
    }
    ctx.stroke();
  }

  function computeConfusion(useModel) {
    const M = [
      [0,0,0],
      [0,0,0],
      [0,0,0]
    ];
    if (!dataset.samples || dataset.samples.length === 0) return M;
    for (const s of dataset.samples) {
      let pred;
      if (useModel) {
        const { probs } = forwardSingle(s.x);
        pred = argmax(probs);
      } else {
        pred = Math.floor(Math.random() * CONFIG.NUM_OUTPUT);
      }
      M[s.y][pred] += 1;
    }
    return M;
  }

  function updateConfusionTables() {
    if (!training.randomConfusion) {
      training.randomConfusion = computeConfusion(false);
    }
    const modelConf = computeConfusion(true);
    renderConfusionTable(training.randomConfusion, 'confRandom');
    renderConfusionTable(modelConf, 'confModel');
  }

  function labelForClass(c) {
    return LABELS.output[c] || String(c);
  }

  function renderConfusionTable(M, elementId) {
    const el = document.getElementById(elementId);
    const total = M.flat().reduce((a,b) => a + b, 0) || 1;
    const correct = M[0][0] + M[1][1] + M[2][2];
    const acc = correct / total;

    let html = '<tr><th>True \\ Pred</th>';
    for (let p = 0; p < CONFIG.NUM_OUTPUT; p++) {
      html += '<th>' + p + '</th>';
    }
    html += '</tr>';
    for (let t = 0; t < CONFIG.NUM_OUTPUT; t++) {
      html += '<tr><th>' + labelForClass(t) + '</th>';
      for (let p = 0; p < CONFIG.NUM_OUTPUT; p++) {
        const cls = t === p ? 'diag' : (M[t][p] ? 'off' : '');
        html += '<td class="' + cls + '">' + M[t][p] + '</td>';
      }
      html += '</tr>';
    }
    html += '<tr><th colspan="' + (CONFIG.NUM_OUTPUT + 1) + '">Accuracy: ' +
      acc.toFixed(3) + '</th></tr>';
    el.innerHTML = html;
  }

  function updateStats() {
    const statsEl = document.getElementById('stats');
    const modelConf = computeConfusion(true);
    const total = modelConf.flat().reduce((a,b) => a + b, 0) || 1;
    const correct = modelConf[0][0] + modelConf[1][1] + modelConf[2][2];
    const acc = correct / total;
    const randomAcc = 1 / CONFIG.NUM_OUTPUT;
    const oddsRatio = acc / randomAcc;
    const lastLoss = training.lossHistory.length
      ? training.lossHistory[training.lossHistory.length - 1].loss
      : NaN;

    statsEl.innerHTML =
      'Steps: ' + training.stepCount +
      '<br>Last loss: ' + (isFinite(lastLoss) ? lastLoss.toFixed(4) : 'n/a') +
      '<br>Accuracy: ' + acc.toFixed(3) +
      ' (random baseline ' + randomAcc.toFixed(3) + ')' +
      '<br>Accuracy / random: ' + oddsRatio.toFixed(2) +
      '<br>Learning rate: ' + CONFIG.LEARNING_RATE.toFixed(3) +
      ' · Batch: ' + CONFIG.BATCH_SIZE;
  }

  function updateSampleView() {
    const infoEl = document.getElementById('sampleInfo');
    const probsEl = document.getElementById('sampleProbs');
    if (!dataset.samples || dataset.samples.length === 0) {
      infoEl.textContent = 'No data.';
      probsEl.innerHTML = '';
      return;
    }
    const idx = ui.currentSampleIndex % dataset.samples.length;
    const s = dataset.samples[idx];
    const { probs } = forwardSingle(s.x);
    const pred = argmax(probs);

    const f = s.raw.map(v => v.toFixed(2));
    infoEl.innerHTML =
      'Index: ' + idx +
      '<br>True class: ' + labelForClass(s.y) +
      '<br>Features: [ ' + f.join(', ') + ' ]';

    const lines = [];
    for (let k = 0; k < CONFIG.NUM_OUTPUT; k++) {
      const p = probs[k];
      lines.push({
        label: labelForClass(k),
        p,
        isPred: k === pred,
        isTrue: k === s.y
      });
    }
    probsEl.innerHTML = '';
    for (const row of lines) {
      const rowEl = createElement('div', 'prob-row');
      const labelEl = createElement('div', 'prob-label', (row.isTrue ? '★ ' : '') + row.label);
      const track = createElement('div', 'prob-bar-track');
      const fill = createElement('div', 'prob-bar-fill');
      fill.style.width = (row.p * 100).toFixed(1) + '%';
      if (row.isPred) {
        fill.style.background = 'linear-gradient(90deg,#58a6ff,#3fb950)';
      }
      track.appendChild(fill);
      const valEl = createElement('div', 'prob-val', row.p.toFixed(3));
      rowEl.appendChild(labelEl);
      rowEl.appendChild(track);
      rowEl.appendChild(valEl);
      probsEl.appendChild(rowEl);
    }
  }

  function updateAllVisuals() {
    updateConnectionStyles();
    updateNetworkVisualization();
    drawLossCurve();
    updateConfusionTables();
    updateStats();
    updateSampleView();
  }

  // ----- training control -----
  function startTraining() {
    if (training.isTraining) return;
    training.isTraining = true;
    document.getElementById('btnTrainToggle').textContent = 'Stop training';
    const slow = document.getElementById('slowMode').checked;
    const delay = slow ? 400 : 60;
    const stepsPerTick = slow ? 1 : 10;
    training.timer = setInterval(() => {
      for (let i = 0; i < stepsPerTick; i++) {
        trainStep();
      }
      updateAllVisuals();
    }, delay);
  }

  function stopTraining() {
    if (!training.isTraining) return;
    training.isTraining = false;
    document.getElementById('btnTrainToggle').textContent = 'Start training';
    if (training.timer) {
      clearInterval(training.timer);
      training.timer = null;
    }
  }

  // ----- initialization -----
  function initApp() {
    dataset.samples = generateSyntheticIris();
    training.randomConfusion = computeConfusion(false);
    initNetwork();
    buildNetworkDiagram();
    drawLossCurve();
    updateConfusionTables();
    updateStats();
    setupSampleProbsSkeleton();
    updateSampleView();

    document.getElementById('btnInit').addEventListener('click', () => {
      stopTraining();
      initNetwork();
      training.lossHistory = [];
      training.stepCount = 0;
      training.randomConfusion = computeConfusion(false);
      drawLossCurve();
      updateConfusionTables();
      updateAllVisuals();
    });

    document.getElementById('btnTrainToggle').addEventListener('click', () => {
      if (training.isTraining) stopTraining();
      else startTraining();
    });

    document.getElementById('btnStep').addEventListener('click', () => {
      stopTraining();
      trainStep();
      updateAllVisuals();
    });

    document.getElementById('lrSelect').addEventListener('change', e => {
      CONFIG.LEARNING_RATE = parseFloat(e.target.value);
      updateStats();
    });

    document.getElementById('batchSelect').addEventListener('change', e => {
      CONFIG.BATCH_SIZE = parseInt(e.target.value, 10);
      updateStats();
    });

    document.getElementById('btnNextSample').addEventListener('click', () => {
      ui.currentSampleIndex = (ui.currentSampleIndex + 1) % dataset.samples.length;
      updateSampleView();
    });

    window.addEventListener('resize', () => {
      buildNetworkDiagram();
    });
  }

  function setupSampleProbsSkeleton() {
    const container = document.getElementById('sampleProbs');
    container.innerHTML = '';
    for (let k = 0; k < CONFIG.NUM_OUTPUT; k++) {
      const rowEl = createElement('div', 'prob-row');
      const labelEl = createElement('div', 'prob-label', labelForClass(k));
      const track = createElement('div', 'prob-bar-track');
      const fill = createElement('div', 'prob-bar-fill');
      track.appendChild(fill);
      const valEl = createElement('div', 'prob-val', '0.000');
      rowEl.appendChild(labelEl);
      rowEl.appendChild(track);
      rowEl.appendChild(valEl);
      container.appendChild(rowEl);
    }
  }

  document.addEventListener('DOMContentLoaded', initApp);
</script>
</body>
</html>
