<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Synthetic Iris Data Visualization</title>
  <link rel="stylesheet" href="styles.css">

  <!-- KaTeX for math rendering -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.css">
  <script defer src="https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.js"></script>
  <style>
    body {
      margin: 0;
      padding: 16px;
      display: flex;
      flex-direction: column;
      gap: 12px;
      overflow: auto;
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", "Roboto", "Helvetica Neue", Arial, sans-serif;
    }
    .controls {
      display: flex;
      gap: 8px;
      align-items: center;
      justify-content: center;
      padding: 6px 10px;
      background: transparent;
      border: 1px solid var(--grid);
      border-radius: 4px;
      flex-wrap: wrap;
    }
    .controls button {
      padding: 4px 10px;
      background: var(--panel);
      border: 1px solid var(--grid);
      border-radius: 3px;
      color: var(--text);
      cursor: pointer;
      font-size: 10px;
      font-weight: 600;
    }
    .controls button:hover {
      background: var(--accent);
      border-color: var(--accent);
    }
    .controls label {
      font-size: 10px;
      display: flex;
      align-items: center;
      gap: 4px;
      font-weight: 500;
    }
    .controls select {
      font-size: 10px;
      padding: 2px 4px;
    }
    /* Range slider styling */
    input[type="range"] {
      -webkit-appearance: none;
      background: transparent;
      cursor: pointer;
    }
    input[type="range"]::-webkit-slider-track {
      background: var(--grid);
      height: 4px;
      border-radius: 2px;
    }
    input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none;
      background: transparent;
      border: 1.5px solid var(--accent);
      width: 8px;
      height: 16px;
      border-radius: 2px;
      margin-top: -6px;
      cursor: pointer;
    }
    input[type="range"]::-moz-range-track {
      background: var(--grid);
      height: 4px;
      border-radius: 2px;
    }
    input[type="range"]::-moz-range-thumb {
      background: transparent;
      border: 1.5px solid var(--accent);
      width: 8px;
      height: 16px;
      border-radius: 2px;
      cursor: pointer;
    }

    .controls input[type="range"] {
      width: 80px;
    }
    .controls #spreadValue {
      min-width: 28px;
      font-weight: 600;
    }
    .controls input[type="checkbox"] {
      -webkit-appearance: none;
      appearance: none;
      width: 14px;
      height: 14px;
      border: 1px solid var(--grid);
      background: var(--bg);
      border-radius: 2px;
      cursor: pointer;
      position: relative;
    }
    .controls input[type="checkbox"]:checked {
      background: var(--accent);
      border-color: var(--accent);
    }
    .controls input[type="checkbox"]:checked::after {
      content: '‚úì';
      position: absolute;
      color: var(--bg);
      font-size: 11px;
      font-weight: bold;
      top: -1px;
      left: 2px;
    }
    .viz-container {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 16px;
      margin-bottom: 16px;
    }
    .plot-wrapper {
      display: flex;
      flex-direction: column;
      gap: 4px;
    }
    .plot-title {
      font-size: 11px;
      color: var(--muted);
      text-align: center;
    }
    canvas {
      width: 100%;
      height: 220px;
      border: 1px solid var(--grid);
      border-radius: 6px;
      background: var(--panel);
      cursor: pointer;
    }
    .info {
      font-size: 11px;
      color: var(--muted);
      padding: 8px;
      background: transparent;
      border: 1px solid var(--grid);
      border-radius: 4px;
      text-align: center;
    }
    .legend {
      display: flex;
      gap: 12px;
      justify-content: center;
      font-size: 10px;
      padding: 6px;
      background: transparent;
    }
    .legend-item {
      display: flex;
      align-items: center;
      gap: 4px;
    }
    .flower-icon {
      position: relative;
      width: 20px;
      height: 20px;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    .flower-icon .petal {
      position: absolute;
      background: currentColor;
      border-radius: 50%;
      z-index: 2;
    }
    .flower-icon .sepal {
      position: absolute;
      background: #5cdb5c;
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
      border: 1.5px solid #1a2a1f;
      box-shadow: 0 0 2px rgba(0, 0, 0, 0.5), inset 0 1px 1px rgba(255, 255, 255, 0.3);
      z-index: 3;
    }
    .flower-icon .center {
      position: absolute;
      background: #ffd700;
      border-radius: 50%;
      width: 5px;
      height: 5px;
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
      z-index: 3;
    }
    .matrix-section {
      display: grid;
      grid-template-columns: 380px 1fr;
      gap: 16px;
      margin-bottom: 16px;
    }
    @media (max-width: 1024px) {
      .matrix-section {
        grid-template-columns: 1fr;
      }
    }
    .matrix-panel {
      background: var(--panel);
      border: 1px solid var(--grid);
      border-radius: 6px;
      padding: 12px;
    }
    .matrix-title {
      font-size: 12px;
      color: var(--accent2);
      margin-bottom: 8px;
      text-align: center;
      font-weight: 600;
    }
    .corr-matrix {
      display: grid;
      grid-template-columns: auto repeat(4, 1fr);
      gap: 2px;
      font-size: 10px;
      background: #0d1117;
      border-radius: 6px;
      padding: 8px;
    }
    .corr-cell {
      padding: 8px;
      text-align: center;
      border-radius: 3px;
      transition: all 0.2s ease;
    }
    .corr-header {
      font-weight: 600;
      color: var(--muted);
      background: #1b1f27;
      border: 1px solid var(--grid);
    }
    .corr-value {
      font-family: monospace;
      color: var(--text);
      border: 1px solid var(--grid);
      cursor: ns-resize;
      user-select: none;
      position: relative;
    }
    .corr-value:hover {
      transform: scale(1.05);
      box-shadow: 0 2px 8px rgba(88, 166, 255, 0.3);
      border-color: var(--accent);
    }
    .corr-value.adjusting {
      background: rgba(88, 166, 255, 0.2);
      border-color: var(--accent2);
    }
    .corr-value::after {
      content: '‚Üï';
      position: absolute;
      right: 2px;
      top: 2px;
      font-size: 8px;
      opacity: 0;
      transition: opacity 0.2s;
      color: var(--accent2);
    }
    .corr-value:hover::after {
      opacity: 0.7;
    }
    .corr-value.adjusting::after {
      opacity: 1;
      animation: pulse 0.5s ease-in-out infinite;
    }
    @keyframes pulse {
      0%, 100% { transform: translateY(-1px); }
      50% { transform: translateY(1px); }
    }
    .gmm-container {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 8px;
    }
    .gmm-feature-panel {
      background: var(--bg);
      border: 1px solid var(--grid);
      border-radius: 4px;
      padding: 8px;
    }
    .gmm-feature-header {
      font-size: 10px;
      font-weight: 600;
      margin-bottom: 6px;
      color: var(--accent2);
      text-align: center;
    }
    .gmm-curve-canvas {
      width: 100%;
      height: 80px;
      display: block;
      border-radius: 3px;
      background: #0d1117;
    }
    .gmm-legend {
      display: flex;
      justify-content: space-around;
      margin-top: 4px;
      font-size: 9px;
      gap: 4px;
    }
    .gmm-legend-item {
      display: flex;
      align-items: center;
      gap: 3px;
    }
    .gmm-legend-dot {
      width: 6px;
      height: 6px;
      border-radius: 50%;
    }
    .equation-panel {
      background: var(--panel);
      border: 1px solid var(--grid);
      border-radius: 6px;
      padding: 16px;
      margin-top: 16px;
      position: relative;
    }
    .equation-panel .equation {
      min-height: 1800px;
    }
    .equation-panel.compact .margin-note {
      display: none;
    }
    .equation-panel.compact .equation {
      min-height: auto;
    }
    .equation-panel.compact .contribution-analysis {
      display: none;
    }
    .equation-panel.compact .equation-explanation {
      display: none;
    }
    .margin-note {
      position: absolute;
      right: -220px;
      width: 200px;
      font-size: 12px;
      font-weight: 600;
      color: var(--text);
      background: rgba(88, 166, 255, 0.1);
      border-left: 4px solid var(--accent);
      padding: 10px;
      border-radius: 4px;
      line-height: 1.5;
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", "Roboto", "Helvetica Neue", Arial, sans-serif;
    }
    @media (max-width: 1400px) {
      .margin-note {
        position: static;
        width: 100%;
        margin: 8px 0;
      }
    }
    .equation-title {
      font-size: 16px;
      color: var(--accent2);
      margin-bottom: 12px;
      text-align: center;
      font-weight: 800;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", "Roboto", "Helvetica Neue", Arial, sans-serif;
    }
    .equation {
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 16px;
      flex-wrap: wrap;
      padding: 24px;
      background: #0d1117;
      border-radius: 6px;
      font-family: 'Times New Roman', serif;
      font-size: 20px;
      min-height: 80px;
    }
    .equation > div {
      margin: 4px 0;
    }
    .eq-element {
      display: inline-flex;
      align-items: center;
      color: var(--text);
      position: relative;
    }
    .eq-matrix {
      display: inline-grid;
      grid-template-columns: repeat(4, 1fr);
      gap: 6px;
      padding: 8px 12px;
      border-left: 3px solid var(--accent);
      border-right: 3px solid var(--accent);
      font-size: 12px;
      font-family: monospace;
      background: rgba(88, 166, 255, 0.05);
      border-radius: 4px;
    }
    .eq-matrix-small {
      font-size: 8px;
      gap: 3px;
      padding: 4px 6px;
      border-left: 2px solid var(--accent);
      border-right: 2px solid var(--accent);
    }
    .eq-matrix-small .eq-matrix-cell {
      min-width: 24px;
      font-size: 8px;
      padding: 1px;
    }
    .eq-matrix-cell {
      min-width: 36px;
      text-align: center;
      transition: all 0.3s ease;
      padding: 2px;
      border-radius: 2px;
    }
    .eq-matrix-cell:hover {
      color: var(--accent2);
      transform: scale(1.3);
      background: rgba(247, 129, 102, 0.1);
    }
    .contribution-analysis {
      background: #11151d;
      border: 1px solid var(--grid);
      border-radius: 6px;
      padding: 12px;
      margin: 12px 0;
      font-size: 11px;
    }
    .contribution-row {
      display: flex;
      align-items: center;
      gap: 8px;
      margin: 5px 0;
      padding: 4px;
    }
    .contribution-label {
      min-width: 70px;
      font-weight: 700;
      color: var(--accent2);
      font-size: 11px;
    }
    .contribution-bar {
      flex: 1;
      height: 16px;
      background: #0d1117;
      border-radius: 8px;
      overflow: hidden;
      position: relative;
      border: 1px solid var(--grid);
    }
    .contribution-fill {
      height: 100%;
      background: linear-gradient(90deg, var(--accent), var(--accent2));
      transition: width 0.3s ease;
    }
    .contribution-value {
      min-width: 95px;
      text-align: right;
      font-family: monospace;
      color: var(--text);
      font-weight: 600;
      font-size: 10px;
    }
    .eq-fraction {
      display: inline-flex;
      flex-direction: column;
      align-items: center;
      font-size: 16px;
      margin: 0 8px;
    }
    .eq-numerator {
      border-bottom: 2px solid var(--text);
      padding-bottom: 6px;
      margin-bottom: 6px;
    }
    .eq-denominator {
      padding-top: 6px;
      font-size: 18px;
      font-weight: 600;
    }
    .eq-exp {
      font-size: 24px;
      color: var(--accent2);
      font-weight: 600;
    }
    .eq-superscript {
      font-size: 14px;
      vertical-align: super;
      color: var(--accent);
    }
    .eq-subscript {
      font-size: 10px;
      vertical-align: sub;
      color: var(--muted);
    }
    .eq-sqrt {
      position: relative;
      padding: 6px 10px 6px 16px;
    }
    .eq-sqrt::before {
      content: '‚àö';
      position: absolute;
      left: 0;
      font-size: 24px;
      color: var(--accent);
    }
    .eq-sqrt::after {
      content: '';
      position: absolute;
      top: 4px;
      left: 16px;
      right: 0;
      height: 1px;
      background: var(--accent);
    }
    .eq-parentheses {
      font-size: 30px;
      color: var(--accent);
    }
    .var-sigma {
      color: #58a6ff;
      font-weight: 700;
    }
    .var-mu {
      color: #f78166;
      font-weight: 700;
    }
    .var-x {
      color: #3fb950;
      font-weight: 700;
    }
    .var-r {
      color: #bc8cff;
      font-weight: 700;
    }
    .eq-element .var-sigma,
    .eq-element .var-mu,
    .eq-element .var-x {
      font-size: 24px;
    }

    /* Global scrollbar styling for WebKit browsers (Chrome, Safari, Edge) */
    ::-webkit-scrollbar {
      width: 12px;
      height: 12px;
    }
    ::-webkit-scrollbar-track {
      background: var(--bg);
    }
    ::-webkit-scrollbar-thumb {
      background: var(--grid);
      border-radius: 6px;
      border: 2px solid var(--bg);
    }
    ::-webkit-scrollbar-thumb:hover {
      background: var(--muted);
    }
    ::-webkit-scrollbar-corner {
      background: var(--bg);
    }

    /* Firefox scrollbar styling */
    * {
      scrollbar-width: thin;
      scrollbar-color: var(--grid) var(--bg);
    }
  </style>
</head>
<body>
  <div class="info">
    <strong>Synthetic Iris Dataset</strong>
    <span id="corrModeIndicator" style="margin-left: 12px; font-size: 10px; color: var(--accent2); display: none;">
      ‚ö° Using Custom Correlation Matrix
    </span>
  </div>

  <!-- Controls moved above plots -->
  <div style="position: sticky; top: 0; z-index: 100; background: var(--bg); border: 1px solid var(--grid); border-radius: 4px; padding: 12px; margin: 8px; margin-top: 0;">
    <div style="display: flex; flex-wrap: wrap; align-items: center; gap: 8px; row-gap: 12px;">
      <!-- Sliders group -->
      <div style="display: flex; flex-wrap: wrap; gap: 12px; flex: 1; min-width: 0;">
        <div style="flex: 1; min-width: 180px;">
          <label style="display: flex; align-items: center; gap: 6px; font-size: 11px;">
            <span style="color: var(--muted); min-width: 65px; white-space: nowrap;">Spread:</span>
            <input type="range" id="spreadSlider" min="0.1" max="5" step="0.1" value="1" style="flex: 1; margin: 0; min-width: 60px;">
            <span id="spreadValue" style="color: var(--text); min-width: 28px; text-align: right; font-variant-numeric: tabular-nums;">1.0</span>
          </label>
        </div>

        <div style="flex: 1; min-width: 180px;">
          <label style="display: flex; align-items: center; gap: 6px; font-size: 11px;">
            <span style="color: var(--muted); min-width: 65px; white-space: nowrap;">Separation:</span>
            <input type="range" id="separationSlider" min="0.3" max="2.0" step="0.1" value="1" style="flex: 1; margin: 0; min-width: 60px;">
            <span id="separationValue" style="color: var(--text); min-width: 28px; text-align: right; font-variant-numeric: tabular-nums;">1.0</span>
          </label>
        </div>

        <div style="flex: 1; min-width: 180px;">
          <label style="display: flex; align-items: center; gap: 6px; font-size: 11px;">
            <span style="color: var(--muted); min-width: 65px; white-space: nowrap;">Reserved:</span>
            <input type="range" id="skewSlider" min="-1.0" max="1.0" step="0.1" value="0" disabled style="flex: 1; margin: 0; min-width: 60px; opacity: 0.3;">
            <span id="skewValue" style="color: var(--text); min-width: 28px; text-align: right; font-variant-numeric: tabular-nums;">0.0</span>
          </label>
        </div>
      </div>

      <!-- Buttons group -->
      <div style="display: flex; gap: 8px; flex-shrink: 0;">
        <button id="dataInfoBtn" style="font-size: 10px; padding: 3px 8px; color: var(--muted); background: transparent; border: 1px solid var(--grid); border-radius: 3px; cursor: pointer; white-space: nowrap;">info</button>
      </div>
    </div>

    <div id="dataInfoPanel" style="display: none; background: linear-gradient(135deg, rgba(88, 166, 255, 0.06) 0%, rgba(78, 205, 196, 0.06) 100%); border-radius: 6px; padding: 16px; margin-top: 12px; font-size: 12px; line-height: 1.7; color: var(--text); border: 1px solid rgba(88, 166, 255, 0.2);">

      <!-- Header -->
      <div style="display: flex; align-items: center; gap: 8px; margin-bottom: 16px; padding-bottom: 10px; border-top: 2px solid rgba(88, 166, 255, 0.3);">
        <strong style="color: var(--accent); font-size: 14px; letter-spacing: 0.5px;">How Data Points are Generated</strong>
      </div>

      <div style="margin-bottom: 14px; padding: 12px; background: rgba(0, 0, 0, 0.2); border-radius: 5px;">
        <p style="margin: 0; color: var(--muted); font-size: 12px; line-height: 1.7;">
          Data points are generated using a <a href="https://en.wikipedia.org/wiki/Mixture_model#Gaussian_mixture_model" target="_blank" style="color: var(--accent); text-decoration: none; font-weight: 600;">Gaussian Mixture Model (GMM)</a>. Each of the three iris species is represented by a separate <a href="https://en.wikipedia.org/wiki/Multivariate_normal_distribution" target="_blank" style="color: var(--accent); text-decoration: none; font-weight: 600;">multivariate Gaussian distribution</a> with its own mean and covariance.
        </p>
      </div>
      <!-- Generation Process Steps -->
      <div style="margin-bottom: 10px; color: var(--accent); font-weight: 600; font-size: 12px;">Generation Process</div>

      <div style="display: grid; gap: 10px; margin-bottom: 16px;">
        <div style="display: flex; gap: 10px; padding: 10px 12px; background: rgba(255, 255, 255, 0.03); border-radius: 4px;">
          <div style="color: #ff6b6b; font-weight: bold; min-width: 24px; font-size: 13px;">1.</div>
          <div style="flex: 1; color: var(--muted); font-size: 12px; line-height: 1.6;">
            <strong style="color: var(--text);">Select species:</strong> Choose one of 3 classes (Setosa, Versicolor, Virginica) with equal probability (33.3% each)
          </div>
        </div>

        <div style="display: flex; gap: 10px; padding: 10px 12px; background: rgba(255, 255, 255, 0.03); border-radius: 4px;">
          <div style="color: #4ecdc4; font-weight: bold; min-width: 24px; font-size: 13px;">2.</div>
          <div style="flex: 1; color: var(--muted); font-size: 12px; line-height: 1.6;">
            <strong style="color: var(--text);">Sample features:</strong> Draw 4 correlated values from a <a href="https://en.wikipedia.org/wiki/Multivariate_normal_distribution" target="_blank" style="color: var(--accent); text-decoration: none; font-weight: 600;">multivariate Gaussian</a> using the species' mean vector <strong>Œº</strong><sub>k</sub> and covariance matrix <strong>Œ£</strong><sub>k</sub>
          </div>
        </div>

        <div style="display: flex; gap: 10px; padding: 10px 12px; background: rgba(255, 255, 255, 0.03); border-radius: 4px;">
          <div style="color: #ffe66d; font-weight: bold; min-width: 24px; font-size: 13px;">3.</div>
          <div style="flex: 1; color: var(--muted); font-size: 12px; line-height: 1.6;">
            <strong style="color: var(--text);">Apply controls:</strong> The <strong style="color: var(--text);">spread multiplier</strong> scales variance, <strong style="color: var(--text);">separation multiplier</strong> adjusts class centers
          </div>
        </div>

        <div style="display: flex; gap: 10px; padding: 10px 12px; background: rgba(255, 255, 255, 0.03); border-radius: 4px;">
          <div style="color: #8ab4f8; font-weight: bold; min-width: 24px; font-size: 13px;">4.</div>
          <div style="flex: 1; color: var(--muted); font-size: 12px; line-height: 1.6;">
            <strong style="color: var(--text);">Result:</strong> Realistic-looking clusters that can overlap or separate based on your settings
          </div>
        </div>
      </div>

      <!-- Mathematical Formulation -->
      <div style="margin-top: 14px; padding: 10px; background: rgba(78, 205, 196, 0.08); border-radius: 4px;">
        <div style="color: #4ecdc4; font-weight: bold; font-size: 11px; margin-bottom: 6px; letter-spacing: 0.5px;">GMM PROBABILITY DENSITY</div>
        <div style="font-family: 'Courier New', monospace; font-size: 13px; color: var(--text); padding: 8px; background: rgba(0,0,0,0.3); border-radius: 3px; text-align: center;">
          p(<strong>x</strong>) = Œ£<sub>k=1</sub><sup>K</sup> œÄ<sub>k</sub> ùí©(<strong>x</strong> | <strong>Œº</strong><sub>k</sub>, <strong>Œ£</strong><sub>k</sub>)
        </div>
        <div style="margin-top: 8px; font-size: 10px; color: var(--muted); line-height: 1.5;">
          Weighted sum of <strong style="color: var(--text);">K = 3</strong> Gaussian components (species)
        </div>

        <!-- Parameters Breakdown -->
        <div style="margin-top: 10px; padding: 8px; background: rgba(0,0,0,0.2); border-radius: 3px;">
          <div style="font-size: 10px; color: var(--muted); line-height: 1.6;">
            <div style="margin-bottom: 3px;">‚Ä¢ <strong style="color: var(--text);">œÄ<sub>k</sub> = 1/3</strong> ‚Äî Mixing coefficient (equal probability)</div>
            <div style="margin-bottom: 3px;">‚Ä¢ <strong style="color: var(--text);">Œº<sub>k</sub></strong> ‚Äî Mean vector [4D] for species k</div>
            <div style="margin-bottom: 3px;">‚Ä¢ <strong style="color: var(--text);">Œ£<sub>k</sub></strong> ‚Äî Covariance matrix [4√ó4] for species k</div>
          </div>
        </div>
      </div>

      <!-- Multivariate Gaussian Formula -->
      <div style="margin-top: 10px; padding: 10px; background: rgba(255, 107, 107, 0.08); border-radius: 4px;">
        <div style="color: #ff6b6b; font-weight: bold; font-size: 11px; margin-bottom: 6px; letter-spacing: 0.5px;">MULTIVARIATE GAUSSIAN</div>
        <div style="font-family: 'Courier New', monospace; font-size: 11px; color: var(--text); padding: 8px; background: rgba(0,0,0,0.3); border-radius: 3px; text-align: center; overflow-x: auto;">
          ùí©(<strong>x</strong> | <strong>Œº</strong><sub>k</sub>, <strong>Œ£</strong><sub>k</sub>) = (2œÄ)<sup>-d/2</sup> |<strong>Œ£</strong><sub>k</sub>|<sup>-1/2</sup> exp(-¬Ω(<strong>x</strong> - <strong>Œº</strong><sub>k</sub>)<sup>T</sup> <strong>Œ£</strong><sub>k</sub><sup>-1</sup> (<strong>x</strong> - <strong>Œº</strong><sub>k</sub>))
        </div>
        <div style="margin-top: 6px; font-size: 10px; color: var(--muted); line-height: 1.5;">
          where <strong style="color: var(--text);">d = 4</strong> dimensions: Sepal Length, Sepal Width, Petal Length, Petal Width
        </div>
      </div>

      <!-- Sampling Algorithm -->
      <div style="margin-top: 14px; padding: 10px; background: rgba(255, 230, 109, 0.08); border-radius: 4px;">
        <div style="color: #ffe66d; font-weight: bold; font-size: 11px; margin-bottom: 8px; letter-spacing: 0.5px;">SAMPLING ALGORITHM (2 STEPS)</div>

        <!-- Step 1 -->
        <div style="margin-bottom: 12px; padding: 10px; background: rgba(0,0,0,0.3); border-radius: 4px; border-left: 3px solid #4ecdc4;">
          <div style="color: #4ecdc4; font-weight: 600; font-size: 11px; margin-bottom: 6px;">Step 1: Component Selection</div>
          <div style="font-family: 'Courier New', monospace; font-size: 11px; color: var(--text); padding: 6px; background: rgba(0,0,0,0.3); border-radius: 3px; text-align: center;">
            k ~ Categorical(œÄ‚ÇÅ, œÄ‚ÇÇ, œÄ‚ÇÉ) = Categorical(1/3, 1/3, 1/3)
          </div>
          <div style="margin-top: 6px; font-size: 10px; color: var(--muted); line-height: 1.5;">
            Randomly choose which species to sample from (each has 33.3% probability)
          </div>
        </div>

        <!-- Step 2 -->
        <div style="margin-bottom: 8px; padding: 10px; background: rgba(0,0,0,0.3); border-radius: 4px; border-left: 3px solid #ff6b6b;">
          <div style="color: #ff6b6b; font-weight: 600; font-size: 11px; margin-bottom: 6px;">Step 2: Sample Features</div>
          <div style="font-family: 'Courier New', monospace; font-size: 11px; color: var(--text); padding: 6px; background: rgba(0,0,0,0.3); border-radius: 3px; text-align: center;">
            <strong>x</strong> ~ ùí©(<strong>Œº</strong><sub>k</sub>, <strong>Œ£</strong><sub>k</sub>)
          </div>
          <div style="margin-top: 6px; font-size: 10px; color: var(--muted); line-height: 1.5;">
            Draw a correlated 4D sample from the selected species' Gaussian distribution
          </div>
        </div>
      </div>

      <!-- Cholesky Decomposition -->
      <div style="margin-top: 10px; padding: 10px; background: rgba(138, 180, 248, 0.08); border-radius: 4px;">
        <div style="color: #8ab4f8; font-weight: bold; font-size: 11px; margin-bottom: 8px; letter-spacing: 0.5px;">CHOLESKY DECOMPOSITION</div>
        <div style="font-size: 10px; color: var(--muted); margin-bottom: 8px; line-height: 1.5;">
          To generate correlated samples, we use <a href="https://en.wikipedia.org/wiki/Cholesky_decomposition" target="_blank" style="color: var(--accent); text-decoration: none; font-weight: 600;">Cholesky decomposition</a>:
        </div>

        <div style="display: grid; gap: 8px;">
          <div style="padding: 8px; background: rgba(0,0,0,0.3); border-radius: 3px;">
            <div style="font-family: 'Courier New', monospace; font-size: 10px; color: var(--text);">
              <strong>1.</strong> Decompose: <strong>Œ£</strong><sub>k</sub> = <strong>L</strong><strong>L</strong><sup>T</sup>
            </div>
          </div>
          <div style="padding: 8px; background: rgba(0,0,0,0.3); border-radius: 3px;">
            <div style="font-family: 'Courier New', monospace; font-size: 10px; color: var(--text);">
              <strong>2.</strong> Sample: <strong>z</strong> ~ ùí©(<strong>0</strong>, <strong>I</strong>) (4 independent normals)
            </div>
          </div>
          <div style="padding: 8px; background: rgba(0,0,0,0.3); border-radius: 3px;">
            <div style="font-family: 'Courier New', monospace; font-size: 10px; color: var(--text);">
              <strong>3.</strong> Transform: <strong>x</strong> = <strong>Œº</strong><sub>k</sub> + <strong>L</strong><strong>z</strong>
            </div>
          </div>
        </div>

        <div style="margin-top: 8px; font-size: 9px; color: var(--muted); line-height: 1.5; font-style: italic; text-align: center;">
          Transforms uncorrelated samples into correlated features
        </div>
      </div>

      <!-- Footer Note -->
      <div style="margin-top: 12px; padding: 8px 10px; background: rgba(255, 255, 255, 0.02); border-radius: 4px; font-size: 10px; color: var(--muted); font-style: italic; text-align: center; border: 1px dashed rgba(255, 255, 255, 0.1);">
        üí° The GMM is "generative" ‚Äî this process describes how real iris flowers could have their features sampled from species-specific distributions
      </div>

    </div>
  </div>

  <div style="border: 1px solid var(--grid); border-radius: 4px; padding: 8px; margin: 8px; margin-top: 0;">
    <div style="display: flex; align-items: center; gap: 12px; margin-bottom: 8px;">
      <div class="legend" id="flowerLegend" style="margin-bottom: 0; flex: 1; justify-content: center;">
        <div class="legend-item">
          <div class="flower-icon" id="flower-0" style="color: #ff6b6b;">
            <div class="sepal"></div>
            <div class="petal"></div>
            <div class="petal"></div>
            <div class="petal"></div>
            <div class="petal"></div>
          </div>
          <span>Setosa</span>
        </div>
        <div class="legend-item">
          <div class="flower-icon" id="flower-1" style="color: #4ecdc4;">
            <div class="sepal"></div>
            <div class="petal"></div>
            <div class="petal"></div>
            <div class="petal"></div>
            <div class="petal"></div>
          </div>
          <span>Versicolor</span>
        </div>
        <div class="legend-item">
          <div class="flower-icon" id="flower-2" style="color: #ffe66d;">
            <div class="sepal"></div>
            <div class="petal"></div>
            <div class="petal"></div>
            <div class="petal"></div>
            <div class="petal"></div>
          </div>
          <span>Virginica</span>
        </div>
      </div>
      <button id="flowerInfoBtn" style="font-size: 10px; padding: 3px 8px; color: var(--muted); background: transparent; border: 1px solid var(--grid); border-radius: 3px; cursor: pointer;">info</button>
    </div>

    <div id="flowerInfo" style="display: none; background: rgba(88, 166, 255, 0.08); border-radius: 4px; padding: 12px; font-size: 12px; line-height: 1.6; color: var(--text);">
    <div style="margin-bottom: 12px;">
      The genetics behind the formation of <a href="https://en.wikipedia.org/wiki/Petal" target="_blank" style="color: var(--accent); text-decoration: none;">petals</a>, in accordance with the ABC model of flower development, are that sepals, petals, stamens, and carpels are modified versions of each other. It appears that the mechanisms to form <a href="https://en.wikipedia.org/wiki/Petal" target="_blank" style="color: var(--accent); text-decoration: none;">petals</a> evolved very few times (perhaps only once), rather than evolving repeatedly from stamens.
    </div>
    <div style="text-align: center; margin-bottom: 12px;">
      <img src="ABC_Model.svg" alt="ABC Model of Flower Development" style="max-width: 60%; height: auto; border: 1px solid var(--grid); border-radius: 4px; background: transparent; mix-blend-mode: lighten; display: block; margin: 0 auto;">
    </div>
    <div style="text-align: right; margin-top: 8px;">
      <a href="#" id="showFlowerTuner" style="color: var(--muted); text-decoration: none; font-size: 10px; border: 1px solid var(--grid); padding: 3px 8px; border-radius: 3px; display: inline-block;">üîß flower tuner</a>
    </div>
    </div>
  </div>

  <!-- Scatter Plots Section with Border and Controls -->
  <div style="border: 1px solid var(--grid); border-radius: 4px; padding: 12px; margin: 8px;">
    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 12px;">
      <h3 style="margin: 0; font-size: 13px; color: var(--text);">Feature Scatter Plots</h3>
      <div style="display: flex; gap: 8px;">
        <button id="toggleEllipses" style="font-size: 10px; padding: 3px 8px; color: var(--muted); background: transparent; border: 1px solid var(--grid); border-radius: 3px; cursor: pointer; min-width: 60px; white-space: nowrap;">Ellipse</button>
        <button id="scatterInfoBtn" style="font-size: 10px; padding: 3px 8px; color: var(--muted); background: transparent; border: 1px solid var(--grid); border-radius: 3px; cursor: pointer; white-space: nowrap;">info</button>
      </div>
    </div>

    <div id="scatterInfoPanel" style="display: none; background: linear-gradient(135deg, rgba(88, 166, 255, 0.06) 0%, rgba(78, 205, 196, 0.06) 100%); border-radius: 6px; padding: 16px; margin-bottom: 12px; font-size: 12px; line-height: 1.7; color: var(--text); border: 1px solid rgba(88, 166, 255, 0.2);">

      <!-- Header -->
      <div style="display: flex; align-items: center; gap: 8px; margin-bottom: 16px; padding-bottom: 10px; border-bottom: 2px solid rgba(88, 166, 255, 0.3);">
        <strong style="color: var(--accent); font-size: 14px; letter-spacing: 0.5px;">How Ellipses are Calculated</strong>
      </div>

      <!-- Two Column Layout -->
      <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap: 18px; margin-bottom: 16px;">

        <!-- Left Column: Process -->
        <div>
          <div style="margin-bottom: 14px; padding: 12px; background: rgba(0, 0, 0, 0.2); border-radius: 5px;">
            <p style="margin: 0; color: var(--muted); font-size: 12px; line-height: 1.7;">
              The ellipses are computed <strong style="color: var(--text);">from the actual generated points</strong> using the <strong style="color: var(--text);">empirical approach</strong>.
            </p>
          </div>

          <!-- Process Steps -->
          <div style="display: grid; gap: 10px;">
            <div style="display: flex; gap: 10px; padding: 10px 12px; background: rgba(255, 255, 255, 0.03); border-radius: 4px;">
              <div style="color: #ff6b6b; font-weight: bold; min-width: 24px; font-size: 13px;">1.</div>
              <div style="flex: 1; color: var(--muted); font-size: 12px; line-height: 1.6;">
                Calculate <a href="https://en.wikipedia.org/wiki/Covariance_matrix" target="_blank" style="color: var(--accent); text-decoration: none; font-weight: 600;">covariance matrix</a> and mean from points
              </div>
            </div>
            <div style="display: flex; gap: 10px; padding: 10px 12px; background: rgba(255, 255, 255, 0.03); border-radius: 4px;">
              <div style="color: #4ecdc4; font-weight: bold; min-width: 24px; font-size: 13px;">2.</div>
              <div style="flex: 1; color: var(--muted); font-size: 12px; line-height: 1.6;">
                Apply <a href="https://en.wikipedia.org/wiki/Eigendecomposition_of_a_matrix" target="_blank" style="color: var(--accent); text-decoration: none; font-weight: 600;">eigendecomposition</a> to find principal axes
              </div>
            </div>
            <div style="display: flex; gap: 10px; padding: 10px 12px; background: rgba(255, 255, 255, 0.03); border-radius: 4px;">
              <div style="color: #ffe66d; font-weight: bold; min-width: 24px; font-size: 13px;">3.</div>
              <div style="flex: 1; color: var(--muted); font-size: 12px; line-height: 1.6;">
                Draw ellipse at <strong style="color: var(--text);">2œÉ (95%)</strong> confidence
              </div>
            </div>
          </div>

          <!-- Formulas -->
          <div style="margin-top: 14px;">
            <div style="margin-bottom: 10px; padding: 10px; background: rgba(255, 107, 107, 0.08); border-radius: 4px;">
              <div style="color: #ff6b6b; font-weight: bold; font-size: 11px; margin-bottom: 6px; letter-spacing: 0.5px;">STEP 1: MEAN VECTOR</div>
              <div style="font-family: 'Courier New', monospace; font-size: 13px; color: var(--text); padding: 8px; background: rgba(0,0,0,0.3); border-radius: 3px; text-align: center;">
                <strong>Œº</strong> = (1/N) Œ£<sub>i=1</sub><sup>N</sup> <strong>x</strong><sub>i</sub>
              </div>
              <div style="margin-top: 6px; font-size: 10px; color: var(--muted); line-height: 1.5;">
                Average position of all N points
              </div>
            </div>

            <div style="margin-bottom: 10px; padding: 10px; background: rgba(78, 205, 196, 0.08); border-radius: 4px;">
              <div style="color: #4ecdc4; font-weight: bold; font-size: 11px; margin-bottom: 6px; letter-spacing: 0.5px;">STEP 2: COVARIANCE MATRIX</div>
              <div style="font-family: 'Courier New', monospace; font-size: 13px; color: var(--text); padding: 8px; background: rgba(0,0,0,0.3); border-radius: 3px; text-align: center; line-height: 1.8;">
                Œ£[j,k] = (1/N) Œ£<sub>i</sub> (x<sub>i,j</sub> - Œº<sub>j</sub>)(x<sub>i,k</sub> - Œº<sub>k</sub>)
              </div>

              <!-- Breakdown -->
              <div style="margin-top: 8px; padding: 8px; background: rgba(0,0,0,0.2); border-radius: 3px;">
                <div style="font-size: 10px; color: var(--muted); line-height: 1.6;">
                  <div style="margin-bottom: 4px;"><strong style="color: var(--text);">What it means:</strong></div>
                  <div style="margin-left: 8px; margin-bottom: 3px;">‚Ä¢ <strong style="color: var(--text);">j, k</strong> = feature indices (0 or 1 for 2D)</div>
                  <div style="margin-left: 8px; margin-bottom: 3px;">‚Ä¢ <strong style="color: var(--text);">x<sub>i,j</sub></strong> = value of feature j for point i</div>
                  <div style="margin-left: 8px; margin-bottom: 3px;">‚Ä¢ <strong style="color: var(--text);">Œº<sub>j</sub></strong> = mean of feature j</div>
                  <div style="margin-left: 8px;">‚Ä¢ Multiply deviations from mean</div>
                </div>
              </div>

              <!-- What you get -->
              <div style="margin-top: 8px; padding: 6px 8px; background: rgba(78, 205, 196, 0.15); border-radius: 3px;">
                <div style="font-size: 10px; color: var(--text); font-weight: 600; margin-bottom: 3px;">Result: 2√ó2 Matrix ‚Üí</div>
                <div style="font-size: 10px; color: var(--muted); line-height: 1.5;">
                  When <strong style="color: #ff6b6b;">j = k</strong>: variance (spread)<br>
                  When <strong style="color: #4ecdc4;">j ‚â† k</strong>: covariance (correlation)
                </div>
              </div>
            </div>

            <!-- Full 4x4 Matrix Context -->
            <div style="margin-top: 10px; padding: 10px; background: rgba(255, 230, 109, 0.08); border-radius: 4px;">
              <div style="color: #ffe66d; font-weight: bold; font-size: 11px; margin-bottom: 6px; letter-spacing: 0.5px;">IRIS FULL 4√ó4 COVARIANCE</div>
              <div style="font-size: 10px; color: var(--muted); margin-bottom: 8px; line-height: 1.5;">
                Each scatter plot shows a <strong style="color: var(--text);">2√ó2 slice</strong> of the full 4√ó4 matrix:
              </div>

              <!-- 4x4 Matrix Visualization -->
              <div style="display: flex; justify-content: center; margin: 8px 0;">
                <div style="font-family: 'Courier New', monospace; font-size: 9px; color: var(--text);">
                  <div style="display: grid; grid-template-columns: auto 1fr auto; gap: 3px; align-items: center;">
                    <div style="font-size: 16px; color: var(--muted);">[</div>
                    <div style="display: grid; grid-template-rows: repeat(4, 1fr); gap: 1px;">
                      <div style="display: grid; grid-template-columns: repeat(4, 1fr); gap: 3px;">
                        <div style="padding: 3px 5px; background: rgba(255,107,107,0.3); border-radius: 2px; text-align: center; font-size: 8px;">œÉ¬≤<sub>SL</sub></div>
                        <div style="padding: 3px 5px; background: rgba(78,205,196,0.15); border-radius: 2px; text-align: center; font-size: 8px;">œÅ</div>
                        <div style="padding: 3px 5px; background: rgba(78,205,196,0.15); border-radius: 2px; text-align: center; font-size: 8px;">œÅ</div>
                        <div style="padding: 3px 5px; background: rgba(78,205,196,0.15); border-radius: 2px; text-align: center; font-size: 8px;">œÅ</div>
                      </div>
                      <div style="display: grid; grid-template-columns: repeat(4, 1fr); gap: 3px;">
                        <div style="padding: 3px 5px; background: rgba(78,205,196,0.15); border-radius: 2px; text-align: center; font-size: 8px;">œÅ</div>
                        <div style="padding: 3px 5px; background: rgba(255,107,107,0.3); border-radius: 2px; text-align: center; font-size: 8px;">œÉ¬≤<sub>SW</sub></div>
                        <div style="padding: 3px 5px; background: rgba(78,205,196,0.15); border-radius: 2px; text-align: center; font-size: 8px;">œÅ</div>
                        <div style="padding: 3px 5px; background: rgba(78,205,196,0.15); border-radius: 2px; text-align: center; font-size: 8px;">œÅ</div>
                      </div>
                      <div style="display: grid; grid-template-columns: repeat(4, 1fr); gap: 3px;">
                        <div style="padding: 3px 5px; background: rgba(78,205,196,0.15); border-radius: 2px; text-align: center; font-size: 8px;">œÅ</div>
                        <div style="padding: 3px 5px; background: rgba(78,205,196,0.15); border-radius: 2px; text-align: center; font-size: 8px;">œÅ</div>
                        <div style="padding: 3px 5px; background: rgba(255,107,107,0.3); border-radius: 2px; text-align: center; font-size: 8px;">œÉ¬≤<sub>PL</sub></div>
                        <div style="padding: 3px 5px; background: rgba(78,205,196,0.15); border-radius: 2px; text-align: center; font-size: 8px;">œÅ</div>
                      </div>
                      <div style="display: grid; grid-template-columns: repeat(4, 1fr); gap: 3px;">
                        <div style="padding: 3px 5px; background: rgba(78,205,196,0.15); border-radius: 2px; text-align: center; font-size: 8px;">œÅ</div>
                        <div style="padding: 3px 5px; background: rgba(78,205,196,0.15); border-radius: 2px; text-align: center; font-size: 8px;">œÅ</div>
                        <div style="padding: 3px 5px; background: rgba(78,205,196,0.15); border-radius: 2px; text-align: center; font-size: 8px;">œÅ</div>
                        <div style="padding: 3px 5px; background: rgba(255,107,107,0.3); border-radius: 2px; text-align: center; font-size: 8px;">œÉ¬≤<sub>PW</sub></div>
                      </div>
                    </div>
                    <div style="font-size: 16px; color: var(--muted);">]</div>
                  </div>
                </div>
              </div>

              <div style="font-size: 9px; color: var(--muted); line-height: 1.4; margin-top: 6px;">
                <strong style="color: var(--text);">SL</strong> = Sepal Length,
                <strong style="color: var(--text);">SW</strong> = Sepal Width,<br>
                <strong style="color: var(--text);">PL</strong> = Petal Length,
                <strong style="color: var(--text);">PW</strong> = Petal Width
              </div>
            </div>
          </div>
        </div>

        <!-- Right Column: Examples with Matrices -->
        <div>
          <div style="margin-bottom: 8px; color: var(--accent); font-weight: 600; font-size: 12px;">2√ó2 Submatrix Examples</div>
          <div style="font-size: 10px; color: var(--muted); margin-bottom: 10px; line-height: 1.5;">
            Each scatter plot extracts a 2√ó2 slice from the full 4√ó4 matrix above:
          </div>

          <!-- Example 1: Uncorrelated -->
          <div style="margin-bottom: 10px; padding: 10px; background: rgba(0, 0, 0, 0.2); border-radius: 4px;">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
              <div style="color: var(--text); font-weight: 600; font-size: 11px;">Uncorrelated</div>
              <div style="color: #8b949e; font-size: 9px;">covXY = 0</div>
            </div>

            <!-- Matrix and Visual side by side -->
            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px; align-items: center;">
              <!-- Matrix -->
              <div style="display: flex; justify-content: center;">
                <div style="font-family: 'Courier New', monospace; font-size: 11px; color: var(--text);">
                  <div style="display: grid; grid-template-columns: auto 1fr auto; gap: 3px; align-items: center;">
                    <div style="font-size: 20px; color: var(--muted);">[</div>
                    <div style="display: grid; grid-template-rows: 1fr 1fr; gap: 2px;">
                      <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 6px; text-align: center;">
                        <div style="padding: 5px 8px; background: rgba(255,107,107,0.25); border-radius: 3px; font-size: 10px;">œÉ¬≤‚Çì</div>
                        <div style="padding: 5px 8px; background: rgba(139,148,158,0.2); border-radius: 3px; font-size: 10px;">0</div>
                      </div>
                      <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 6px; text-align: center;">
                        <div style="padding: 5px 8px; background: rgba(139,148,158,0.2); border-radius: 3px; font-size: 10px;">0</div>
                        <div style="padding: 5px 8px; background: rgba(255,107,107,0.25); border-radius: 3px; font-size: 10px;">œÉ¬≤·µß</div>
                      </div>
                    </div>
                    <div style="font-size: 20px; color: var(--muted);">]</div>
                  </div>
                </div>
              </div>

              <!-- Visual -->
              <canvas id="exampleCanvas1" width="120" height="120" style="width: 100%; height: auto; background: rgba(0,0,0,0.3); border-radius: 4px; border: 1px solid rgba(255,255,255,0.1);"></canvas>
            </div>
            <div style="font-size: 10px; color: var(--muted); text-align: center; margin-top: 6px;">Axes-aligned ellipse</div>
          </div>

          <!-- Example 2: Positive Correlation -->
          <div style="margin-bottom: 10px; padding: 10px; background: rgba(0, 0, 0, 0.2); border-radius: 4px;">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
              <div style="color: var(--text); font-weight: 600; font-size: 11px;">Positive Correlation</div>
              <div style="color: #4ecdc4; font-size: 9px;">covXY > 0</div>
            </div>

            <!-- Matrix and Visual side by side -->
            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px; align-items: center;">
              <!-- Matrix -->
              <div style="display: flex; justify-content: center;">
                <div style="font-family: 'Courier New', monospace; font-size: 11px; color: var(--text);">
                  <div style="display: grid; grid-template-columns: auto 1fr auto; gap: 3px; align-items: center;">
                    <div style="font-size: 20px; color: var(--muted);">[</div>
                    <div style="display: grid; grid-template-rows: 1fr 1fr; gap: 2px;">
                      <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 6px; text-align: center;">
                        <div style="padding: 5px 8px; background: rgba(255,107,107,0.25); border-radius: 3px; font-size: 10px;">œÉ¬≤‚Çì</div>
                        <div style="padding: 5px 8px; background: rgba(78,205,196,0.25); border-radius: 3px; font-size: 10px;">+œÅ</div>
                      </div>
                      <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 6px; text-align: center;">
                        <div style="padding: 5px 8px; background: rgba(78,205,196,0.25); border-radius: 3px; font-size: 10px;">+œÅ</div>
                        <div style="padding: 5px 8px; background: rgba(255,107,107,0.25); border-radius: 3px; font-size: 10px;">œÉ¬≤·µß</div>
                      </div>
                    </div>
                    <div style="font-size: 20px; color: var(--muted);">]</div>
                  </div>
                </div>
              </div>

              <!-- Visual -->
              <canvas id="exampleCanvas2" width="120" height="120" style="width: 100%; height: auto; background: rgba(0,0,0,0.3); border-radius: 4px; border: 1px solid rgba(255,255,255,0.1);"></canvas>
            </div>
            <div style="font-size: 10px; color: var(--muted); text-align: center; margin-top: 6px;">Rotated ellipse (/ slope)</div>
          </div>

          <!-- Example 3: Negative Correlation -->
          <div style="margin-bottom: 10px; padding: 10px; background: rgba(0, 0, 0, 0.2); border-radius: 4px;">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
              <div style="color: var(--text); font-weight: 600; font-size: 11px;">Negative Correlation</div>
              <div style="color: #ff6b6b; font-size: 9px;">covXY < 0</div>
            </div>

            <!-- Matrix and Visual side by side -->
            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px; align-items: center;">
              <!-- Matrix -->
              <div style="display: flex; justify-content: center;">
                <div style="font-family: 'Courier New', monospace; font-size: 11px; color: var(--text);">
                  <div style="display: grid; grid-template-columns: auto 1fr auto; gap: 3px; align-items: center;">
                    <div style="font-size: 20px; color: var(--muted);">[</div>
                    <div style="display: grid; grid-template-rows: 1fr 1fr; gap: 2px;">
                      <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 6px; text-align: center;">
                        <div style="padding: 5px 8px; background: rgba(255,107,107,0.25); border-radius: 3px; font-size: 10px;">œÉ¬≤‚Çì</div>
                        <div style="padding: 5px 8px; background: rgba(255,107,107,0.25); border-radius: 3px; font-size: 10px;">-œÅ</div>
                      </div>
                      <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 6px; text-align: center;">
                        <div style="padding: 5px 8px; background: rgba(255,107,107,0.25); border-radius: 3px; font-size: 10px;">-œÅ</div>
                        <div style="padding: 5px 8px; background: rgba(255,107,107,0.25); border-radius: 3px; font-size: 10px;">œÉ¬≤·µß</div>
                      </div>
                    </div>
                    <div style="font-size: 20px; color: var(--muted);">]</div>
                  </div>
                </div>
              </div>

              <!-- Visual -->
              <canvas id="exampleCanvas3" width="120" height="120" style="width: 100%; height: auto; background: rgba(0,0,0,0.3); border-radius: 4px; border: 1px solid rgba(255,255,255,0.1);"></canvas>
            </div>
            <div style="font-size: 10px; color: var(--muted); text-align: center; margin-top: 6px;">Rotated ellipse (\ slope)</div>
          </div>
        </div>
      </div>

      <!-- Footer Note -->
      <div style="margin-top: 12px; padding: 8px 10px; background: rgba(255, 255, 255, 0.02); border-radius: 4px; font-size: 10px; color: var(--muted); font-style: italic; text-align: center; border: 1px dashed rgba(255, 255, 255, 0.1);">
        üí° Because of random sampling, the ellipse will vary slightly each time you regenerate the data
      </div>

    </div>

    <div class="viz-container">
      <div class="plot-wrapper">
        <div class="plot-title">Sepal Length vs Sepal Width</div>
        <canvas id="canvas1"></canvas>
      </div>
      <div class="plot-wrapper">
        <div class="plot-title">Petal Length vs Petal Width</div>
        <canvas id="canvas2"></canvas>
      </div>
      <div class="plot-wrapper">
        <div class="plot-title">Sepal Length vs Petal Length</div>
        <canvas id="canvas3"></canvas>
      </div>
      <div class="plot-wrapper">
        <div class="plot-title">Sepal Width vs Petal Width</div>
        <canvas id="canvas4"></canvas>
      </div>
    </div>
  </div>

  <div class="matrix-section">
    <div class="matrix-panel">
      <div class="matrix-title" style="display: flex; justify-content: space-between; align-items: center;">
        <span>Cross-Correlation Matrix (Drag ‚Üï to Adjust Values)</span>
        <div style="display: flex; gap: 6px;">
          <button id="btnResetCorr" style="font-size: 9px; padding: 2px 6px;">Reset</button>
          <button id="corrInfoBtn" style="font-size: 9px; padding: 2px 6px; color: var(--muted); background: transparent; border: 1px solid var(--grid); border-radius: 3px; cursor: pointer;">info</button>
        </div>
      </div>

      <!-- Correlation Info Panel -->
      <div id="corrInfoPanel" style="display: none; background: rgba(88, 166, 255, 0.08); border-radius: 4px; padding: 10px; margin-top: 10px; font-size: 12px; line-height: 1.5; color: var(--text);">
        <div style="margin-bottom: 8px;">
          <strong style="color: #4ecdc4; font-size: 15px;">Interactive: 2√ó2 Submatrix ‚Üí 4√ó4 Full Matrix</strong>
        </div>

        <p style="margin: 6px 0; color: var(--muted); font-size: 12px; line-height: 1.5;">
          Adjust a <strong style="color: var(--text);">2√ó2 submatrix</strong> for two features and see how it affects the <strong style="color: var(--text);">full 4√ó4 covariance matrix</strong> and the generated data.
        </p>

        <!-- Controls and Visualization in responsive layout -->
        <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 8px; margin: 10px 0;">

          <!-- Feature Pair Selector -->
          <div style="padding: 6px; background: rgba(0,0,0,0.2); border-radius: 4px;">
            <div style="font-size: 10px; color: var(--accent); font-weight: 600; margin-bottom: 4px;">SELECT PAIR</div>
            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 3px;">
              <button class="feature-pair-btn" data-pair="0,1" style="font-size: 9px; padding: 3px; background: rgba(255,107,107,0.2); border: 1px solid #ff6b6b; border-radius: 2px; cursor: pointer; color: var(--text);">
                SL√óSW
              </button>
              <button class="feature-pair-btn" data-pair="2,3" style="font-size: 9px; padding: 3px; background: rgba(78,205,196,0.2); border: 1px solid #4ecdc4; border-radius: 2px; cursor: pointer; color: var(--text);">
                PL√óPW
              </button>
              <button class="feature-pair-btn" data-pair="0,2" style="font-size: 9px; padding: 3px; background: rgba(255,230,109,0.2); border: 1px solid #ffe66d; border-radius: 2px; cursor: pointer; color: var(--text);">
                SL√óPL
              </button>
              <button class="feature-pair-btn" data-pair="1,3" style="font-size: 9px; padding: 3px; background: rgba(138,180,248,0.2); border: 1px solid #8ab4f8; border-radius: 2px; cursor: pointer; color: var(--text);">
                SW√óPW
              </button>
              <button class="feature-pair-btn" data-pair="0,3" style="font-size: 9px; padding: 3px; background: rgba(186,104,200,0.2); border: 1px solid #ba68c8; border-radius: 2px; cursor: pointer; color: var(--text);">
                SL√óPW
              </button>
              <button class="feature-pair-btn" data-pair="1,2" style="font-size: 9px; padding: 3px; background: rgba(255,152,0,0.2); border: 1px solid #ff9800; border-radius: 2px; cursor: pointer; color: var(--text);">
                SW√óPL
              </button>
            </div>
          </div>

          <!-- 2x2 Submatrix Controls -->
          <div style="padding: 6px; background: rgba(0,0,0,0.2); border-radius: 4px;">
            <div style="font-size: 10px; color: var(--accent); font-weight: 600; margin-bottom: 4px;">ADJUST VALUES</div>

            <!-- Variance sliders -->
            <div style="margin-bottom: 3px;">
              <label style="display: flex; align-items: center; gap: 4px; font-size: 9px;">
                <span style="color: var(--text); min-width: 45px;">Var X:</span>
                <input type="range" id="submatrixVarX" min="0.1" max="1.0" step="0.05" value="0.5" style="flex: 1;">
                <span id="submatrixVarXValue" style="color: var(--text); min-width: 28px; text-align: right;">0.50</span>
              </label>
            </div>

            <div style="margin-bottom: 3px;">
              <label style="display: flex; align-items: center; gap: 4px; font-size: 9px;">
                <span style="color: var(--text); min-width: 45px;">Var Y:</span>
                <input type="range" id="submatrixVarY" min="0.1" max="1.0" step="0.05" value="0.5" style="flex: 1;">
                <span id="submatrixVarYValue" style="color: var(--text); min-width: 28px; text-align: right;">0.50</span>
              </label>
            </div>

            <div style="margin-bottom: 4px;">
              <label style="display: flex; align-items: center; gap: 4px; font-size: 9px;">
                <span style="color: var(--text); min-width: 45px;">Cov:</span>
                <input type="range" id="submatrixCov" min="-0.4" max="0.4" step="0.05" value="0" style="flex: 1;">
                <span id="submatrixCovValue" style="color: var(--text); min-width: 28px; text-align: right;">0.00</span>
              </label>
            </div>

            <div style="display: flex; gap: 3px; align-items: center; justify-content: center;">
              <button id="liveUpdateBtn" style="font-size: 8px; padding: 2px 6px; background: transparent; border: 1px solid var(--grid); border-radius: 2px; cursor: pointer; color: var(--muted); transition: all 0.2s;">
                Live
              </button>
              <button id="applySubmatrix" style="font-size: 8px; padding: 2px 6px; background: transparent; border: 1px solid #4ecdc4; border-radius: 2px; cursor: pointer; color: #4ecdc4;">
                Apply
              </button>
              <button id="resetSubmatrix" style="font-size: 8px; padding: 2px 6px; background: transparent; border: 1px solid var(--grid); border-radius: 2px; cursor: pointer; color: var(--muted);">
                Reset
              </button>
            </div>
          </div>

        </div>

        <!-- Matrix Visualization - Below the controls -->
        <div style="padding: 8px; background: rgba(0,0,0,0.2); border-radius: 4px; margin-top: 8px;">
          <div style="font-size: 10px; color: var(--accent); font-weight: 600; margin-bottom: 6px; text-align: center;">MATRICES</div>
          <div style="display: flex; gap: 10px; justify-content: center; align-items: center; flex-wrap: wrap;">
            <!-- Matrices -->
            <div style="display: flex; gap: 10px; align-items: center;">
              <div>
                <div style="font-size: 8px; color: var(--muted); margin-bottom: 2px; text-align: center;">2√ó2</div>
                <div id="submatrixDisplay" style="font-family: 'Courier New', monospace; font-size: 10px; color: var(--text);"></div>
              </div>
              <div style="color: var(--muted); font-size: 16px;">‚Üí</div>
              <div>
                <div style="font-size: 8px; color: var(--muted); margin-bottom: 2px; text-align: center;">4√ó4</div>
                <div id="fullmatrixDisplay" style="font-family: 'Courier New', monospace; font-size: 8px; color: var(--text);"></div>
              </div>
              <div style="color: var(--muted); font-size: 16px;">‚Üí</div>
            </div>

            <!-- Canvas and Tech Data grouped together -->
            <div style="display: flex; gap: 4px; align-items: center;">
              <canvas id="submatrixPreviewCanvas" width="280" height="280" style="width: 140px; height: 140px; background: rgba(0,0,0,0.3); border-radius: 3px; border: 1px solid rgba(255,255,255,0.1);"></canvas>

              <!-- Technical Data -->
              <div style="font-family: 'Courier New', monospace; font-size: 11px; color: var(--text); line-height: 1.7; background: rgba(0,0,0,0.5); padding: 8px; border-radius: 3px;">
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 8px;">
                  <div>
                    <div style="margin-bottom: 5px;">
                      <span style="color: #4ecdc4;">Œª‚ÇÅ:</span> <span id="techLambda1">--</span>
                    </div>
                    <div style="margin-bottom: 5px;">
                      <span style="color: #4ecdc4;">Œª‚ÇÇ:</span> <span id="techLambda2">--</span>
                    </div>
                    <div style="margin-bottom: 5px;">
                      <span style="color: #ffe66d;">Œ∏:</span> <span id="techAngle">--</span>¬∞
                    </div>
                    <div style="margin-bottom: 5px;">
                      <span style="color: #ffe66d;">rx:</span> <span id="techRx">--</span>
                    </div>
                    <div>
                      <span style="color: #ffe66d;">ry:</span> <span id="techRy">--</span>
                    </div>
                  </div>
                  <div>
                    <div style="margin-bottom: 5px;">
                      <span style="color: #ff6b6b;">det:</span> <span id="techDet">--</span>
                    </div>
                    <div style="margin-bottom: 5px;">
                      <span style="color: #ff6b6b;">tr:</span> <span id="techTrace">--</span>
                    </div>
                    <div style="margin-bottom: 5px;">
                      <span style="color: #8ab4f8;">œÅ:</span> <span id="techCorr">--</span>
                    </div>
                    <div>
                      <span style="color: #8ab4f8;">ok:</span> <span id="techValid">--</span>
                    </div>
                  </div>
                </div>
              </div>
            </div>
          </div>
        </div>

        <div style="margin-top: 6px; padding: 5px 6px; background: rgba(255,230,109,0.1); border-radius: 3px; font-size: 10px; color: var(--muted); text-align: center;">
          üí° Changes to the submatrix update the corresponding cells in the full 4√ó4 matrix
        </div>
      </div>

      <div id="corrMatrix" class="corr-matrix"></div>

      <div style="margin: 12px 0 0 0; padding: 10px; background: rgba(88, 166, 255, 0.05); border-radius: 6px; border-left: 3px solid var(--accent);">
        <div style="font-size: 11px; font-weight: 700; margin-bottom: 6px; color: var(--accent);">Interactive Examples - Click to Set Correlation Matrix:</div>
        <div style="display: flex; gap: 6px; flex-wrap: wrap;">
          <button id="btnWeakCorr" style="padding: 5px 10px; font-size: 10px; font-weight: 600;">Weak</button>
          <button id="btnStrongCorr" style="padding: 5px 10px; font-size: 10px; font-weight: 600;">Strong</button>
          <button id="btnUncorrelated" style="padding: 5px 10px; font-size: 10px; font-weight: 600;">Uncorrelated</button>
          <button id="btnTight" style="padding: 5px 10px; font-size: 10px; font-weight: 600;">Tight</button>
          <button id="btnSingular" style="padding: 5px 10px; font-size: 10px; font-weight: 600;">Singular</button>
        </div>
      </div>
    </div>
    <div class="matrix-panel">
      <div class="matrix-title">Gaussian Mixture Model Parameters</div>
      <div id="gmmParams" class="gmm-container"></div>
    </div>
  </div>

  <div class="equation-panel compact" id="equationPanel">
    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 12px;">
      <div class="equation-title" style="margin: 0;">Multivariate Gaussian as Matrix Exponential</div>
      <button id="btnToggleEquation" style="padding: 3px 8px; font-size: 10px; color: var(--muted); background: transparent; border: 1px solid var(--grid); border-radius: 3px; cursor: pointer; white-space: nowrap;">info</button>
    </div>
    <div id="gmmEquation" class="equation"></div>
  </div>

<script>
  // Global tuning parameters - set immediately
  window.flowerTuning = {
    petalBaseRadius: 1.5,    // Where petals attach/start (over sepal)
    petalLengthScale: 2.0,   // Scale all petal lengths
    petalWidthScale: 2.4,    // Scale all petal widths
    setosaGain: 2.0,         // Extra scale for Setosa only
    sepalSizeMin: 5,
    sepalSizeRange: 1.5,
    sepalRoundness: 20,      // 0-50% border-radius (50 = circle)
    sepalGreen: '#11df11'
  };
  console.log('üå∏ Flower tuning available:', window.flowerTuning);

  // Gaussian RNG (Box-Muller transform)
  let _gaussSpare = null;
  function gaussianRandom() {
    if (_gaussSpare !== null) {
      const v = _gaussSpare;
      _gaussSpare = null;
      return v;
    }
    let u = 0, v = 0;
    while (u === 0) u = Math.random();
    while (v === 0) v = Math.random();
    const mag = Math.sqrt(-2.0 * Math.log(u));
    const z0 = mag * Math.cos(2 * Math.PI * v);
    const z1 = mag * Math.sin(2 * Math.PI * v);
    _gaussSpare = z1;
    return z0;
  }

  // GMM Configuration
  const gmmConfig = {
    centers: [
      [5.0, 3.4, 1.5, 0.2], // setosa
      [6.0, 2.8, 4.5, 1.3], // versicolor
      [6.7, 3.1, 5.5, 2.1]  // virginica
    ],
    baseSpreads: [
      [0.2, 0.2, 0.2, 0.05],
      [0.4, 0.3, 0.4, 0.2],
      [0.5, 0.3, 0.6, 0.25]
    ],
    spreads: [
      [0.2, 0.2, 0.2, 0.05],
      [0.4, 0.3, 0.4, 0.2],
      [0.5, 0.3, 0.6, 0.25]
    ],
    nPerClass: 50,
    spreadMultiplier: 1.0,
    separationMultiplier: 1.0,
    ellipseAxisScale: 1.0,
    versicolorSkew: 0.0  // Skew factor for Versicolor class only
  };

  // Update spreads based on multiplier
  function updateSpreads() {
    for (let c = 0; c < 3; c++) {
      for (let d = 0; d < 4; d++) {
        gmmConfig.spreads[c][d] = gmmConfig.baseSpreads[c][d] * gmmConfig.spreadMultiplier;
      }
    }
  }

  // Cholesky decomposition for generating correlated data
  function choleskyDecomposition(matrix) {
    const n = matrix.length;
    const L = Array(n).fill(0).map(() => Array(n).fill(0));

    for (let i = 0; i < n; i++) {
      for (let j = 0; j <= i; j++) {
        let sum = 0;
        for (let k = 0; k < j; k++) {
          sum += L[i][k] * L[j][k];
        }
        if (i === j) {
          const val = matrix[i][i] - sum;
          L[i][j] = val > 0 ? Math.sqrt(val) : 0.01; // Safeguard
        } else {
          L[i][j] = (matrix[i][j] - sum) / (L[j][j] || 0.01);
        }
      }
    }
    return L;
  }

  // Apply skew to samples (only for Versicolor)
  function applySkewToSamples(samples, skewFactor) {
    if (Math.abs(skewFactor) < 0.01) return samples;

    // Apply non-linear transformation to create asymmetric distribution
    return samples.map(sample => {
      const skewed = sample.slice();
      // Apply cubic transformation to all dimensions for dramatic skew effect
      for (let i = 0; i < 4; i++) {
        if (skewFactor > 0) {
          // Positive skew: push values away from center on positive side
          skewed[i] = sample[i] + skewFactor * Math.pow(Math.max(0, sample[i]), 2);
        } else {
          // Negative skew: push values away from center on negative side
          skewed[i] = sample[i] + skewFactor * Math.pow(Math.min(0, sample[i]), 2);
        }
      }
      return skewed;
    });
  }

  // Generate correlated samples using Cholesky decomposition
  function generateCorrelatedSamples(n, corrMatrix) {
    const L = choleskyDecomposition(corrMatrix);
    const samples = [];

    for (let i = 0; i < n; i++) {
      const z = [gaussianRandom(), gaussianRandom(), gaussianRandom(), gaussianRandom()];
      const x = [0, 0, 0, 0];

      // Matrix multiplication: x = L * z
      for (let row = 0; row < 4; row++) {
        for (let col = 0; col < 4; col++) {
          x[row] += L[row][col] * z[col];
        }
      }
      samples.push(x);
    }
    return samples;
  }

  // Generate synthetic Iris data using GMM
  function generateData(customCorrMatrix = null) {
    const data = [];

    // Calculate global mean across all class centers for separation scaling
    const globalMean = [0, 0, 0, 0];
    for (let d = 0; d < 4; d++) {
      globalMean[d] = (gmmConfig.centers[0][d] + gmmConfig.centers[1][d] + gmmConfig.centers[2][d]) / 3;
    }

    for (let c = 0; c < 3; c++) {
      let classSamples;

      if (customCorrMatrix) {
        // Generate correlated samples
        classSamples = generateCorrelatedSamples(gmmConfig.nPerClass, customCorrMatrix);
      } else {
        // Generate independent samples
        classSamples = [];
        for (let n = 0; n < gmmConfig.nPerClass; n++) {
          classSamples.push([
            gaussianRandom(),
            gaussianRandom(),
            gaussianRandom(),
            gaussianRandom()
          ]);
        }
      }

      // Scale and shift to match GMM parameters
      for (const sample of classSamples) {
        const point = [];
        for (let d = 0; d < 4; d++) {
          // Apply separation scaling: move centers toward/away from global mean
          const scaledCenter = globalMean[d] + (gmmConfig.centers[c][d] - globalMean[d]) * gmmConfig.separationMultiplier;
          const val = scaledCenter + gmmConfig.spreads[c][d] * sample[d];
          point.push(val);
        }
        data.push({ features: point, class: c });
      }
    }
    return data;
  }

  // Compute correlation matrix
  function computeCorrelationMatrix(data) {
    const n = data.length;
    const dims = 4;

    // Compute means
    const means = new Array(dims).fill(0);
    for (const d of data) {
      for (let i = 0; i < dims; i++) {
        means[i] += d.features[i];
      }
    }
    for (let i = 0; i < dims; i++) {
      means[i] /= n;
    }

    // Compute covariance matrix
    const cov = Array(dims).fill(0).map(() => Array(dims).fill(0));
    for (const d of data) {
      for (let i = 0; i < dims; i++) {
        for (let j = 0; j < dims; j++) {
          cov[i][j] += (d.features[i] - means[i]) * (d.features[j] - means[j]);
        }
      }
    }

    // Normalize to correlation
    const corr = Array(dims).fill(0).map(() => Array(dims).fill(0));
    for (let i = 0; i < dims; i++) {
      for (let j = 0; j < dims; j++) {
        const stdI = Math.sqrt(cov[i][i] / n);
        const stdJ = Math.sqrt(cov[j][j] / n);
        corr[i][j] = cov[i][j] / (n * stdI * stdJ);
      }
    }

    return corr;
  }

  // Adjustable correlation matrix state
  const adjustState = {
    element: null,
    row: -1,
    col: -1,
    startY: 0,
    startValue: 0,
    updatePending: false
  };

  // Make correlation value adjustable
  function makeAdjustable(element, row, col, currentValue) {
    element.addEventListener('mousedown', (e) => {
      adjustState.element = element;
      adjustState.row = row;
      adjustState.col = col;
      adjustState.startY = e.clientY;
      adjustState.startValue = currentValue;
      element.classList.add('adjusting');
      e.preventDefault();
    });
  }

  // Store current correlation matrix for editing
  let editableCorr = null;

  // Render simple correlation matrix grid
  function renderCorrelationMatrix(data) {
    // Use editableCorr if it's set, otherwise compute from data
    let corr;
    if (editableCorr) {
      corr = editableCorr;
    } else {
      corr = computeCorrelationMatrix(data);
      editableCorr = corr.map(row => [...row]); // Deep copy
    }

    const labels = ['SepL', 'SepW', 'PetL', 'PetW'];
    const container = document.getElementById('corrMatrix');
    container.innerHTML = '';

    // Header row
    const emptyCell = document.createElement('div');
    emptyCell.className = 'corr-cell corr-header';
    emptyCell.textContent = 'œÅ';
    container.appendChild(emptyCell);

    for (const label of labels) {
      const cell = document.createElement('div');
      cell.className = 'corr-cell corr-header';
      cell.textContent = label;
      container.appendChild(cell);
    }

    // Data rows
    for (let i = 0; i < 4; i++) {
      const rowLabel = document.createElement('div');
      rowLabel.className = 'corr-cell corr-header';
      rowLabel.textContent = labels[i];
      container.appendChild(rowLabel);

      for (let j = 0; j < 4; j++) {
        const cell = document.createElement('div');
        cell.className = 'corr-cell corr-value';
        const val = editableCorr[i][j];
        cell.textContent = val.toFixed(2);
        cell.dataset.row = i;
        cell.dataset.col = j;

        // Color coding based on correlation strength
        const absVal = Math.abs(val);
        const hue = val > 0 ? 210 : 0; // blue for positive, red for negative
        const alpha = absVal * 0.7;
        cell.style.background = `hsla(${hue}, 80%, 55%, ${alpha})`;

        // Make adjustable (except diagonal which is always 1)
        if (i !== j) {
          makeAdjustable(cell, i, j, val);
        } else {
          cell.style.cursor = 'default';
          cell.style.opacity = '0.7';
        }

        container.appendChild(cell);
      }
    }
  }

  // Update all visualizations (throttled with requestAnimationFrame)
  function updateAllVisualizations() {
    if (!adjustState.updatePending) return;
    adjustState.updatePending = false;

    // REAL-TIME UPDATE: Regenerate data with new correlation matrix
    currentData = generateData(editableCorr);

    // Show indicator that we're using custom correlation
    document.getElementById('corrModeIndicator').style.display = 'inline';

    // Update all visualizations
    projections.forEach((proj, i) => {
      drawScatter(canvases[i], currentData, proj[0], proj[1]);
    });
    renderGMMParams(currentData);
    renderGaussianEquation(currentData);

    // Notify parent window if we're in an iframe
    if (window.parent !== window) {
      window.parent.postMessage({
        type: 'dataRegenerated',
        data: currentData
      }, '*');
    }
  }

  // Handle mouse movement for adjusting values
  document.addEventListener('mousemove', (e) => {
    if (!adjustState.element) return;

    const deltaY = adjustState.startY - e.clientY; // Inverted: drag up increases
    const sensitivity = 0.005;
    let newValue = adjustState.startValue + (deltaY * sensitivity);

    // Clamp to [-1, 1]
    newValue = Math.max(-1, Math.min(1, newValue));

    // Update the editable correlation matrix
    editableCorr[adjustState.row][adjustState.col] = newValue;
    editableCorr[adjustState.col][adjustState.row] = newValue; // Keep symmetric

    // Update display
    adjustState.element.textContent = newValue.toFixed(2);

    // Update color
    const absVal = Math.abs(newValue);
    const hue = newValue > 0 ? 210 : 0;
    const alpha = absVal * 0.7;
    adjustState.element.style.background = `hsla(${hue}, 80%, 55%, ${alpha})`;

    // Update symmetric cell
    const symCell = document.querySelector(`[data-row="${adjustState.col}"][data-col="${adjustState.row}"]`);
    if (symCell) {
      symCell.textContent = newValue.toFixed(2);
      symCell.style.background = `hsla(${hue}, 80%, 55%, ${alpha})`;
    }

    // Schedule visualization update (throttled)
    if (!adjustState.updatePending) {
      adjustState.updatePending = true;
      requestAnimationFrame(updateAllVisualizations);
    }
  });

  // Handle mouse up for adjusting
  document.addEventListener('mouseup', () => {
    if (adjustState.element) {
      adjustState.element.classList.remove('adjusting');
      adjustState.element = null;
    }
  });

  // Gaussian PDF function
  function gaussianPDF(x, mu, sigma) {
    const coefficient = 1 / (sigma * Math.sqrt(2 * Math.PI));
    const exponent = -Math.pow(x - mu, 2) / (2 * Math.pow(sigma, 2));
    return coefficient * Math.exp(exponent);
  }

  // Compute actual statistics from data for a feature and class
  function computeFeatureStats(data, classIdx, featureIdx) {
    const classData = data.filter(d => d.class === classIdx);
    const values = classData.map(d => d.features[featureIdx]);

    const n = values.length;
    const mean = values.reduce((a, b) => a + b, 0) / n;
    const variance = values.reduce((a, v) => a + Math.pow(v - mean, 2), 0) / n;
    const std = Math.sqrt(variance);

    return { mean, std };
  }

  // Draw Gaussian curve on canvas using actual data statistics
  function drawGaussianCurve(canvas, data, featureIdx) {
    const ctx = canvas.getContext('2d');
    const rect = canvas.getBoundingClientRect();
    const dpr = window.devicePixelRatio || 1;

    canvas.width = rect.width * dpr;
    canvas.height = rect.height * dpr;
    ctx.scale(dpr, dpr);

    const w = rect.width;
    const h = rect.height;
    const pad = 10;

    // Clear
    ctx.fillStyle = '#0d1117';
    ctx.fillRect(0, 0, w, h);

    const colors = ['#ff6b6b', '#4ecdc4', '#ffe66d'];
    const classNames = ['Setosa', 'Versicolor', 'Virginica'];

    // Compute actual stats from data
    const stats = [];
    for (let c = 0; c < 3; c++) {
      stats.push(computeFeatureStats(data, c, featureIdx));
    }

    // Find global min/max for this feature across all classes
    let minX = Infinity, maxX = -Infinity;
    for (let c = 0; c < 3; c++) {
      const { mean, std } = stats[c];
      minX = Math.min(minX, mean - 3 * std);
      maxX = Math.max(maxX, mean + 3 * std);
    }

    // Draw all three curves
    let maxY = 0;
    const curves = [];
    for (let c = 0; c < 3; c++) {
      const { mean, std } = stats[c];
      const curve = [];

      for (let i = 0; i <= 100; i++) {
        const x = minX + (i / 100) * (maxX - minX);
        const y = gaussianPDF(x, mean, std);
        curve.push({ x, y });
        maxY = Math.max(maxY, y);
      }
      curves.push({ curve, mean, std });
    }

    // Draw curves
    for (let c = 0; c < 3; c++) {
      const { curve, mean, std } = curves[c];

      // Draw curve
      ctx.strokeStyle = colors[c];
      ctx.lineWidth = 1.5;
      ctx.beginPath();

      for (let i = 0; i < curve.length; i++) {
        const px = pad + ((curve[i].x - minX) / (maxX - minX)) * (w - 2 * pad);
        const py = h - pad - (curve[i].y / maxY) * (h - 2 * pad);

        if (i === 0) ctx.moveTo(px, py);
        else ctx.lineTo(px, py);
      }
      ctx.stroke();

      // Draw mean marker
      const muX = pad + ((mean - minX) / (maxX - minX)) * (w - 2 * pad);
      ctx.strokeStyle = colors[c];
      ctx.lineWidth = 1;
      ctx.setLineDash([3, 2]);
      ctx.beginPath();
      ctx.moveTo(muX, h - pad);
      ctx.lineTo(muX, pad);
      ctx.stroke();
      ctx.setLineDash([]);

      // Label mean and std
      ctx.fillStyle = colors[c];
      ctx.font = '8px monospace';
      ctx.textAlign = 'center';
      ctx.fillText(`Œº=${mean.toFixed(2)}`, muX, h - 2);
      ctx.fillText(`œÉ=${std.toFixed(2)}`, muX, 10);
    }

    // Draw axes
    ctx.strokeStyle = '#30363d';
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(pad, h - pad);
    ctx.lineTo(w - pad, h - pad);
    ctx.stroke();
  }

  // Compute matrix power for Taylor series
  function matrixPower(matrix, power) {
    if (power === 0) {
      // Return identity matrix
      const n = matrix.length;
      const I = Array(n).fill(0).map(() => Array(n).fill(0));
      for (let i = 0; i < n; i++) I[i][i] = 1;
      return I;
    }
    if (power === 1) return matrix;

    // Matrix multiplication for power 2
    const n = matrix.length;
    const result = Array(n).fill(0).map(() => Array(n).fill(0));
    for (let i = 0; i < n; i++) {
      for (let j = 0; j < n; j++) {
        for (let k = 0; k < n; k++) {
          result[i][j] += matrix[i][k] * matrix[k][j];
        }
      }
    }
    return result;
  }

  // Compute Frobenius norm of a matrix (total magnitude)
  function frobeniusNorm(matrix) {
    let sum = 0;
    for (let i = 0; i < matrix.length; i++) {
      for (let j = 0; j < matrix[i].length; j++) {
        sum += matrix[i][j] * matrix[i][j];
      }
    }
    return Math.sqrt(sum);
  }

  // Compute determinant of 4x4 matrix
  function determinant4x4(m) {
    // Using cofactor expansion (simplified for 4x4)
    // This is a simplified calculation
    return (
      m[0][0] * m[1][1] * m[2][2] * m[3][3] +
      m[0][1] * m[1][2] * m[2][3] * m[3][0] +
      m[0][2] * m[1][3] * m[2][0] * m[3][1] +
      m[0][3] * m[1][0] * m[2][1] * m[3][2] -
      m[0][3] * m[1][2] * m[2][1] * m[3][0] -
      m[0][2] * m[1][1] * m[2][0] * m[3][3] -
      m[0][1] * m[1][0] * m[2][3] * m[3][2] -
      m[0][0] * m[1][3] * m[2][2] * m[3][1]
    );
  }

  // Render matrix exponential equation for Gaussian with Taylor expansion
  function renderGaussianEquation(data) {
    const container = document.getElementById('gmmEquation');
    const corr = editableCorr || computeCorrelationMatrix(data);

    // Compute correlation matrix powers for Taylor series
    const R0 = matrixPower(corr, 0); // Identity
    const R1 = corr;
    const R2 = matrixPower(corr, 2);
    const R3 = matrixPower(corr, 3);

    // Calculate contributions (Frobenius norms)
    const norm0 = frobeniusNorm(R0);
    const norm1 = frobeniusNorm(R1);
    const norm2 = frobeniusNorm(R2) / 2; // Divided by 2!
    const norm3 = frobeniusNorm(R3) / 6; // Divided by 3!

    const totalNorm = norm0 + norm1 + norm2 + norm3;
    const contrib0 = (norm0 / totalNorm) * 100;
    const contrib1 = (norm1 / totalNorm) * 100;
    const contrib2 = (norm2 / totalNorm) * 100;
    const contrib3 = (norm3 / totalNorm) * 100;

    // Calculate determinant
    const det = determinant4x4(corr);

    const renderMatrix = (mat, small = false) => `
      <div class="eq-matrix ${small ? 'eq-matrix-small' : ''}">
        ${mat.map((row, i) =>
          row.map((val, j) =>
            `<div class="eq-matrix-cell" style="color: ${val > 0 ? '#58a6ff' : '#f78166'}">${val.toFixed(2)}</div>`
          ).join('')
        ).join('')}
      </div>
    `;

    container.innerHTML = `
      <div style="text-align: center; margin: 20px 0;">
        <div id="mainEquationTop"></div>
      </div>

      <div class="equation-explanation" style="margin-bottom: 20px;">
        <table style="width: 100%; border-collapse: collapse; margin-bottom: 20px; font-size: 18px;">
          <thead>
            <tr style="border-bottom: 2px solid var(--grid);">
              <th style="padding: 10px; text-align: left; color: var(--accent); font-weight: 600;">Variable</th>
              <th style="padding: 10px; text-align: left; color: var(--accent); font-weight: 600;">Symbol</th>
              <th style="padding: 10px; text-align: left; color: var(--accent); font-weight: 600;">Meaning</th>
            </tr>
          </thead>
          <tbody>
            <tr style="border-bottom: 1px solid var(--grid);">
              <td style="padding: 10px; color: #58a6ff; font-weight: 600;">Data vector</td>
              <td style="padding: 10px; color: #58a6ff; font-size: 18px; font-weight: 700;">x</td>
              <td style="padding: 10px; color: var(--text);">4D observation (SL, SW, PL, PW)</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--grid);">
              <td style="padding: 10px; color: #ffe66d; font-weight: 600;">Mean vector</td>
              <td style="padding: 10px; color: #ffe66d; font-size: 18px; font-weight: 700;">Œº</td>
              <td style="padding: 10px; color: var(--text);">Center of the distribution</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--grid);">
              <td style="padding: 10px; color: #ff6b6b; font-weight: 600;">Covariance matrix</td>
              <td style="padding: 10px; color: #ff6b6b; font-size: 18px; font-weight: 700;">Œ£</td>
              <td style="padding: 10px; color: var(--text);">4√ó4 matrix encoding variances & correlations</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--grid);">
              <td style="padding: 10px; color: #4ecdc4; font-weight: 600;">Precision matrix</td>
              <td style="padding: 10px; color: #4ecdc4; font-size: 18px; font-weight: 700;">Œ£‚Åª¬π</td>
              <td style="padding: 10px; color: var(--text);">Inverse of covariance (high precision = tight distribution)</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--grid);">
              <td style="padding: 10px; color: #ba68c8; font-weight: 600;">Normalization constant</td>
              <td style="padding: 10px; color: #ba68c8; font-size: 18px; font-weight: 700;">(2œÄ)^(d/2)</td>
              <td style="padding: 10px; color: var(--text);">2œÄ raised to the power d/2, where d is the number of dimensions</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--grid);">
              <td style="padding: 10px; color: #3fb950; font-weight: 600;">Exponential function</td>
              <td style="padding: 10px; color: #3fb950; font-size: 18px; font-weight: 700;">exp</td>
              <td style="padding: 10px; color: var(--text);">Creates the bell-shaped curve (e^x function)</td>
            </tr>
            <tr>
              <td style="padding: 10px; color: #ff9800; font-weight: 600;">Exponent factor</td>
              <td style="padding: 10px; color: #ff9800; font-size: 18px; font-weight: 700;">-1/2</td>
              <td style="padding: 10px; color: var(--text);">From completing the square in quadratic form</td>
            </tr>
          </tbody>
        </table>

        <p style="margin: 0 0 16px 0; font-size: 18px; line-height: 2; color: var(--text);">
          The multivariate Gaussian probability density function describes the likelihood of observing a d-dimensional vector <b style="color: #58a6ff;">x</b> given a mean vector <b style="color: #ffe66d;">Œº</b> and covariance matrix <b style="color: #ff6b6b;">Œ£</b>. In our Iris dataset, this is a 4-dimensional distribution (sepal length, sepal width, petal length, petal width) that captures how these features vary together for each species.
        </p>

        <!-- Mean Vector Visualization -->
        <div style="margin: 40px 0;">
          <div style="display: grid; grid-template-columns: 400px 1fr; gap: 32px; align-items: start;">
            <canvas id="meanVectorCanvas" width="800" height="640" style="width: 400px; height: 320px; background: #0d1117; border: none;"></canvas>
            <div style="font-size: 18px; line-height: 1.9; color: var(--text); padding-top: 0;">
              <p style="margin: 0 0 20px 0;">
                The <b style="color: #ff8800;">mean vector Œº</b> is the center point of the distribution in 4-dimensional space. The diagram shows a 2D projection (petal length vs. petal width) of the Setosa class. The full 4D mean vector for Setosa is:
              </p>
              <div style="margin: 20px 0; font-family: monospace; font-size: 17px; line-height: 1.7;">
                <div><b style="color: #ff8800;">Œº</b> = [<span id="meanVector_SL" style="color: #58a6ff;">5.01</span>, <span id="meanVector_SW" style="color: #58a6ff;">3.42</span>, <span id="meanVector_PL" style="color: #ff8800;">1.46</span>, <span id="meanVector_PW" style="color: #ff8800;">0.25</span>]</div>
              </div>
              <p style="margin: 20px 0 0 0; font-size: 18px; color: var(--muted);">
                The highlighted values (<span style="color: #ff8800;">1.46, 0.25</span>) are the petal dimensions shown in the 2D plot. We cannot visualize 4D directly, so we examine 2D slices.
              </p>
            </div>
          </div>
        </div>

        <!-- 2x2 Correlation Section -->
        <div style="margin: 40px 0;">
          <p style="margin: 0 0 20px 0; font-size: 18px; line-height: 2; color: var(--text);">
            To understand correlation geometrically, start with the 2D petal subspace we visualized above. The mean vector <b style="color: #ff8800;">Œº</b> = (<span style="color: #ff8800;">1.46, 0.25</span>) is the center. Around this center, the 2√ó2 covariance matrix describes how the data spreads:
          </p>
          <div style="display: flex; align-items: center; gap: 24px; margin: 20px 0;">
            <div style="display: flex; align-items: center; gap: 12px;">
              <div style="font-size: 24px; font-weight: bold; color: #4ecdc4;">Œ£<sub>petals</sub> =</div>
              <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 6px; padding: 16px; background: rgba(0,0,0,0.3); border-radius: 6px;">
                <div style="padding: 12px; background: rgba(255,107,107,0.3); border-radius: 3px; text-align: center; font-size: 16px; color: var(--text); font-weight: 600;">œÉ¬≤<sub>PL</sub></div>
                <div style="padding: 12px; background: rgba(78,205,196,0.4); border-radius: 3px; text-align: center; font-size: 16px; color: var(--text); font-weight: 700; border: 2px solid #4ecdc4;">cov<sub>PL,PW</sub></div>
                <div style="padding: 12px; background: rgba(78,205,196,0.4); border-radius: 3px; text-align: center; font-size: 16px; color: var(--text); font-weight: 700; border: 2px solid #4ecdc4;">cov<sub>PL,PW</sub></div>
                <div style="padding: 12px; background: rgba(255,107,107,0.3); border-radius: 3px; text-align: center; font-size: 16px; color: var(--text); font-weight: 600;">œÉ¬≤<sub>PW</sub></div>
              </div>
            </div>
            <div style="flex: 1; font-size: 18px; line-height: 1.9; color: var(--text);">
              The diagonal holds variances (spread along each axis). The off-diagonal elements are identical and measure covariance‚Äîwhen petal length increases, petal width tends to increase too, creating positive correlation.
            </div>
          </div>
        </div>

        <!-- Building to 4x4 -->
        <div style="margin: 40px 0;">
          <p style="margin: 0 0 20px 0; font-size: 18px; line-height: 2; color: var(--text);">
            The full 4-dimensional iris has 4 features: sepal length, sepal width, petal length, petal width. All four features are interdependent‚Äîsepal dimensions correlate with each other, petal dimensions correlate with each other, and sepals correlate with petals. The 4√ó4 covariance matrix <b style="color: #ff6b6b;">Œ£</b> captures all these relationships simultaneously. It contains 4 variances (diagonal) and 6 unique pairwise covariances (off-diagonal), totaling 10 independent numbers that fully describe the Gaussian shape in 4D space.
          </p>
        </div>

        <div style="display: flex; align-items: center; gap: 20px; margin: 20px 0;">
          <div style="flex: 1;">
            <p style="margin: 0; font-size: 18px; line-height: 2;">
              The covariance matrix <b style="color: #ff6b6b;">Œ£</b> is central to understanding correlations. Its diagonal elements are the variances (how much each feature spreads), while the off-diagonal elements are covariances (how features co-vary). For the Iris dataset, petal length and petal width are strongly correlated, which shows up as large off-diagonal values in <b style="color: #ff6b6b;">Œ£</b>.
            </p>
          </div>

          <div style="display: flex; flex-direction: column; align-items: center; gap: 16px;">
            <div style="display: flex; align-items: center; gap: 12px;">
              <div style="font-size: 32px; font-weight: bold; color: #ff6b6b;">Œ£ =</div>
              <div style="display: grid; grid-template-columns: repeat(4, 1fr); gap: 4px; padding: 12px; background: rgba(0,0,0,0.3); border-radius: 6px;">
                <div style="padding: 8px; background: rgba(255,107,107,0.3); border-radius: 3px; text-align: center; font-size: 14px; color: var(--text); font-weight: 600;">œÉ¬≤<sub>SL</sub></div>
                <div style="padding: 8px; background: rgba(88,166,255,0.2); border-radius: 3px; text-align: center; font-size: 14px; color: var(--muted);">cov</div>
                <div style="padding: 8px; background: rgba(88,166,255,0.2); border-radius: 3px; text-align: center; font-size: 14px; color: var(--muted);">cov</div>
                <div style="padding: 8px; background: rgba(88,166,255,0.2); border-radius: 3px; text-align: center; font-size: 14px; color: var(--muted);">cov</div>

                <div style="padding: 8px; background: rgba(88,166,255,0.2); border-radius: 3px; text-align: center; font-size: 14px; color: var(--muted);">cov</div>
                <div style="padding: 8px; background: rgba(255,107,107,0.3); border-radius: 3px; text-align: center; font-size: 14px; color: var(--text); font-weight: 600;">œÉ¬≤<sub>SW</sub></div>
                <div style="padding: 8px; background: rgba(88,166,255,0.2); border-radius: 3px; text-align: center; font-size: 14px; color: var(--muted);">cov</div>
                <div style="padding: 8px; background: rgba(88,166,255,0.2); border-radius: 3px; text-align: center; font-size: 14px; color: var(--muted);">cov</div>

                <div style="padding: 8px; background: rgba(88,166,255,0.2); border-radius: 3px; text-align: center; font-size: 14px; color: var(--muted);">cov</div>
                <div style="padding: 8px; background: rgba(88,166,255,0.2); border-radius: 3px; text-align: center; font-size: 14px; color: var(--muted);">cov</div>
                <div style="padding: 8px; background: rgba(255,107,107,0.3); border-radius: 3px; text-align: center; font-size: 14px; color: var(--text); font-weight: 600;">œÉ¬≤<sub>PL</sub></div>
                <div style="padding: 8px; background: rgba(78,205,196,0.4); border-radius: 3px; text-align: center; font-size: 14px; color: var(--text); font-weight: 700; border: 2px solid #4ecdc4;">‚òÖ</div>

                <div style="padding: 8px; background: rgba(88,166,255,0.2); border-radius: 3px; text-align: center; font-size: 14px; color: var(--muted);">cov</div>
                <div style="padding: 8px; background: rgba(88,166,255,0.2); border-radius: 3px; text-align: center; font-size: 14px; color: var(--muted);">cov</div>
                <div style="padding: 8px; background: rgba(78,205,196,0.4); border-radius: 3px; text-align: center; font-size: 14px; color: var(--text); font-weight: 700; border: 2px solid #4ecdc4;">‚òÖ</div>
                <div style="padding: 8px; background: rgba(255,107,107,0.3); border-radius: 3px; text-align: center; font-size: 14px; color: var(--text); font-weight: 600;">œÉ¬≤<sub>PW</sub></div>
              </div>
            </div>
            <div style="font-size: 16px; color: rgba(139, 148, 158, 0.7); line-height: 1.8; text-align: center;">
              <div>‚òÖ = Strong correlation (PL√óPW)</div>
              <div>Diagonal = Variances</div>
            </div>
          </div>
        </div>

        <!-- Precision Matrix Section -->
        <div style="margin: 40px 0;">
          <p style="margin: 0 0 20px 0; font-size: 18px; line-height: 2; color: var(--text);">
            The <b style="color: #4ecdc4;">precision matrix Œ£‚Åª¬π</b> is the matrix inverse of the covariance matrix. It appears in the Gaussian equation's exponent and measures certainty rather than spread. The relationship is reciprocal: high variance (wide spread) means low precision (high uncertainty), while low variance (tight spread) means high precision (high certainty).
          </p>

          <div style="display: flex; align-items: start; gap: 32px; margin: 20px 0;">
            <div style="flex: 1;">
              <p style="margin: 0 0 16px 0; font-size: 18px; line-height: 2; color: var(--text);">
                For the 2√ó2 petal example, if the covariance matrix describes the spread:
              </p>
              <div style="display: flex; align-items: center; gap: 12px; margin: 20px 0;">
                <div style="font-size: 20px; font-weight: bold; color: #ff6b6b;">Œ£ =</div>
                <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 4px; padding: 12px; background: rgba(0,0,0,0.3); border-radius: 6px;">
                  <div style="padding: 10px; background: rgba(255,107,107,0.3); border-radius: 3px; text-align: center; font-size: 14px; color: var(--text); font-weight: 600;">0.03</div>
                  <div style="padding: 10px; background: rgba(78,205,196,0.4); border-radius: 3px; text-align: center; font-size: 14px; color: var(--text); font-weight: 600;">0.01</div>
                  <div style="padding: 10px; background: rgba(78,205,196,0.4); border-radius: 3px; text-align: center; font-size: 14px; color: var(--text); font-weight: 600;">0.01</div>
                  <div style="padding: 10px; background: rgba(255,107,107,0.3); border-radius: 3px; text-align: center; font-size: 14px; color: var(--text); font-weight: 600;">0.01</div>
                </div>
              </div>
              <p style="margin: 16px 0 0 0; font-size: 18px; line-height: 2; color: var(--text);">
                Then the precision matrix (its inverse) shows how tightly constrained each dimension is:
              </p>
              <div style="display: flex; align-items: center; gap: 12px; margin: 20px 0;">
                <div style="font-size: 20px; font-weight: bold; color: #4ecdc4;">Œ£‚Åª¬π =</div>
                <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 4px; padding: 12px; background: rgba(0,0,0,0.3); border-radius: 6px;">
                  <div style="padding: 10px; background: rgba(78,205,196,0.3); border-radius: 3px; text-align: center; font-size: 14px; color: var(--text); font-weight: 600;">50.0</div>
                  <div style="padding: 10px; background: rgba(78,205,196,0.2); border-radius: 3px; text-align: center; font-size: 14px; color: var(--text); font-weight: 600;">-33.3</div>
                  <div style="padding: 10px; background: rgba(78,205,196,0.2); border-radius: 3px; text-align: center; font-size: 14px; color: var(--text); font-weight: 600;">-33.3</div>
                  <div style="padding: 10px; background: rgba(78,205,196,0.3); border-radius: 3px; text-align: center; font-size: 14px; color: var(--text); font-weight: 600;">125.0</div>
                </div>
              </div>
            </div>

            <div style="flex: 1;">
              <p style="margin: 0 0 16px 0; font-size: 18px; line-height: 2; color: var(--text);">
                Notice the precision values are much larger‚Äîthis is the reciprocal relationship. The precision matrix weights the Mahalanobis distance:
              </p>
              <div style="margin: 20px 0;">
                <div style="font-size: 18px; line-height: 2; color: var(--text);">
                  <div style="margin-bottom: 12px;">
                    Distance = (<b style="color: #58a6ff;">x</b> - <b style="color: #ff8800;">Œº</b>)<sup>T</sup> <b style="color: #4ecdc4;">Œ£‚Åª¬π</b> (<b style="color: #58a6ff;">x</b> - <b style="color: #ff8800;">Œº</b>)
                  </div>
                  <div style="font-size: 16px; color: rgba(139, 148, 158, 0.8); line-height: 1.8;">
                    This measures how many "standard deviations" a point is from the mean, accounting for correlations. Points far from the mean get exponentially lower probability.
                  </div>
                </div>
              </div>
              <p style="margin: 16px 0 0 0; font-size: 18px; line-height: 2; color: var(--text);">
                In 4D, <b style="color: #4ecdc4;">Œ£‚Åª¬π</b> is a 4√ó4 matrix that encodes how all dimensions jointly constrain probability. The off-diagonal elements show how knowing one feature's value affects our certainty about others.
              </p>
            </div>
          </div>
        </div>

        <!-- Mahalanobis Distance Section -->
        <div style="margin: 40px 0;">
          <p style="margin: 0 0 20px 0; font-size: 18px; line-height: 2; color: var(--text);">
            The Gaussian probability density is built from a single core quantity: the Mahalanobis distance. For a point <b style="color: #58a6ff;">x</b> relative to the distribution centered at <b style="color: #ff8800;">Œº</b> with precision matrix <b style="color: #4ecdc4;">Œ£‚Åª¬π</b>, the squared Mahalanobis distance is:
          </p>

          <div style="text-align: center; font-size: 20px; font-weight: 600; margin: 24px 0; padding: 20px; background: rgba(0,0,0,0.2); border-radius: 6px;">
            d¬≤ = (<b style="color: #58a6ff;">x</b> - <b style="color: #ff8800;">Œº</b>)<sup>T</sup> <b style="color: #4ecdc4;">Œ£‚Åª¬π</b> (<b style="color: #58a6ff;">x</b> - <b style="color: #ff8800;">Œº</b>)
          </div>

          <p style="margin: 20px 0; font-size: 18px; line-height: 2; color: var(--text);">
            This generalizes Euclidean distance. In 2D with uncorrelated, unit-variance features, <b style="color: #4ecdc4;">Œ£‚Åª¬π</b> = I (identity matrix), and d¬≤ reduces to the familiar (x‚ÇÅ - Œº‚ÇÅ)¬≤ + (x‚ÇÇ - Œº‚ÇÇ)¬≤. The precision matrix <b style="color: #4ecdc4;">Œ£‚Åª¬π</b> weights and rotates the coordinate system to account for different variances and correlations between dimensions.
          </p>

          <div style="display: flex; gap: 32px; margin: 30px 0;">
            <div style="flex: 1;">
              <p style="margin: 0 0 16px 0; font-size: 18px; line-height: 2; color: var(--text);">
                For the 2D petal example with mean <b style="color: #ff8800;">Œº</b> = (1.46, 0.25):
              </p>
              <div style="font-size: 18px; line-height: 2; color: var(--text); margin-left: 20px;">
                <div>deviation = <b style="color: #58a6ff;">x</b> - <b style="color: #ff8800;">Œº</b></div>
                <div style="margin-top: 8px; margin-left: 20px; color: rgba(139, 148, 158, 0.9);">= [x‚ÇÅ - 1.46, x‚ÇÇ - 0.25]</div>
                <div style="margin-top: 16px;">d¬≤ = deviation<sup>T</sup> <b style="color: #4ecdc4;">Œ£‚Åª¬π</b> deviation</div>
              </div>
            </div>

            <div style="flex: 1;">
              <p style="margin: 0 0 16px 0; font-size: 18px; line-height: 2; color: var(--text);">
                The quadratic form computes a weighted sum. If <b style="color: #4ecdc4;">Œ£‚Åª¬π</b> has large diagonal values, deviations in those dimensions are heavily penalized. Off-diagonal elements couple dimensions‚Äîcorrelation between petal length and width means knowing one constrains the other.
              </p>
            </div>
          </div>

          <!-- Interactive: Euclidean vs Mahalanobis -->
          <div style="margin: 30px 0;">
            <p style="margin: 0 0 16px 0; font-size: 18px; line-height: 2; color: var(--text);">
              Interactive: Euclidean vs Mahalanobis distance
            </p>
            <div style="display: flex; gap: 24px; align-items: start;">
              <div style="flex: 0 0 350px;">
                <canvas id="euclideanVsMahalanobis" width="350" height="350" style="border: 1px solid var(--grid); border-radius: 4px; cursor: crosshair;"></canvas>
                <p style="margin: 10px 0 0 0; font-size: 13px; color: rgba(139, 148, 158, 0.9); text-align: center;">
                  Click or drag the point to explore
                </p>
              </div>
              <div style="flex: 1;">
                <p style="margin: 0 0 16px 0; font-size: 16px; line-height: 1.8; color: var(--text);">
                  The ellipse contours represent points at equal Mahalanobis distance from the mean. As you move the point around, notice how the two distance metrics behave differently:
                </p>
                <div style="margin: 20px 0; padding: 16px; background: rgba(78, 205, 196, 0.05); border-left: 3px solid #4ecdc4; border-radius: 4px;">
                  <div style="margin-bottom: 12px;">
                    <span style="font-size: 14px; color: #58a6ff;">Euclidean distance: </span>
                    <span id="euclideanDist" style="font-size: 24px; font-weight: 600; font-family: monospace; color: #58a6ff;">0.00</span>
                  </div>
                  <div>
                    <span style="font-size: 14px; color: #4ecdc4;">Mahalanobis distance: </span>
                    <span id="mahalanobisDist" style="font-size: 24px; font-weight: 600; font-family: monospace; color: #4ecdc4;">0.00</span>
                  </div>
                </div>
                <p style="margin: 0; font-size: 16px; line-height: 1.8; color: rgba(139, 148, 158, 0.9);">
                  When you drag the point along an ellipse contour, the Mahalanobis distance stays approximately constant while the Euclidean distance changes. This demonstrates how Mahalanobis distance accounts for the shape and orientation of the distribution, not just raw coordinate distance.
                </p>
              </div>
            </div>
          </div>

          <!-- Comparative Examples: Precision -->
          <div style="margin: 30px 0;">
            <p style="margin: 0 0 16px 0; font-size: 18px; line-height: 2; color: var(--text);">
              How precision affects distance: Comparative examples
            </p>

            <p style="margin: 0 0 20px 0; font-size: 16px; line-height: 1.8; color: var(--text);">
              Precision is the inverse of variance. When precision is high, data is tightly clustered. The same physical displacement means different things statistically:
            </p>

            <div style="display: flex; gap: 16px; margin-bottom: 20px;">
              <div style="flex: 1; text-align: center;">
                <canvas id="precisionLow" width="180" height="180" style="border: 1px solid var(--grid); border-radius: 4px;"></canvas>
                <div style="margin: 8px 0 0 0; font-size: 14px; color: var(--text); font-weight: 600;">Low Precision (œÉ¬≤ = 1.0)</div>
                <div style="font-size: 13px; color: rgba(139, 148, 158, 0.9); margin-top: 4px;">Coordinate: 50px</div>
                <div style="font-size: 13px; color: #4ecdc4; font-weight: 600;">Mahalanobis: 1.58</div>
              </div>
              <div style="flex: 1; text-align: center;">
                <canvas id="precisionMed" width="180" height="180" style="border: 1px solid var(--grid); border-radius: 4px;"></canvas>
                <div style="margin: 8px 0 0 0; font-size: 14px; color: var(--text); font-weight: 600;">Medium Precision (œÉ¬≤ = 0.25)</div>
                <div style="font-size: 13px; color: rgba(139, 148, 158, 0.9); margin-top: 4px;">Coordinate: 50px</div>
                <div style="font-size: 13px; color: #4ecdc4; font-weight: 600;">Mahalanobis: 3.16</div>
              </div>
              <div style="flex: 1; text-align: center;">
                <canvas id="precisionHigh" width="180" height="180" style="border: 1px solid var(--grid); border-radius: 4px;"></canvas>
                <div style="margin: 8px 0 0 0; font-size: 14px; color: var(--text); font-weight: 600;">High Precision (œÉ¬≤ = 0.04)</div>
                <div style="font-size: 13px; color: rgba(139, 148, 158, 0.9); margin-top: 4px;">Coordinate: 50px</div>
                <div style="font-size: 13px; color: #4ecdc4; font-weight: 600;">Mahalanobis: 7.91</div>
              </div>
            </div>

            <p style="margin: 20px 0 0 0; font-size: 16px; line-height: 1.8; color: rgba(139, 148, 158, 0.9);">
              All three scenarios show the same blue point at the same coordinate distance (50 pixels) from the orange mean. But as precision increases (variance decreases), the ellipse shrinks. The point goes from being "typical" (inside the contour) to "unusual" (far outside). When data is tightly clustered, even small displacements are statistically significant.
            </p>
          </div>

          <p style="margin: 30px 0 20px 0; font-size: 18px; line-height: 2; color: var(--text);">
            The Gaussian is constructed by applying the exponential function to <b>-¬Ω d¬≤</b>. Points at Mahalanobis distance d from the mean get probability proportional to exp(-¬Ω d¬≤). At the mean (<b style="color: #58a6ff;">x</b> = <b style="color: #ff8800;">Œº</b>), d¬≤ = 0 and probability is maximal. Moving away, d¬≤ grows quadratically and probability decays exponentially.
          </p>
        </div>
      </div>

      <div class="equation-explanation" style="margin: 20px 0; font-size: 18px; line-height: 2; color: var(--text);">
        <p style="margin: 0 0 24px 0; font-size: 20px; font-weight: 600; color: var(--accent2);">
          Building the Gaussian
        </p>

        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 32px; align-items: start;">
          <div>
            <p style="margin: 0 0 20px 0; font-size: 16px; color: rgba(139, 148, 158, 0.9);">
              The Gaussian is constructed by applying the exponential function to <b style="color: #ff9800;">-¬Ω</b> d¬≤. Points at Mahalanobis distance d from the mean get probability proportional to <b style="color: #3fb950;">exp</b>(<b style="color: #ff9800;">-¬Ω</b> d¬≤). At the mean (<b style="color: #58a6ff;">x</b> = <b style="color: #ff8800;">Œº</b>), d¬≤ = 0 and probability is maximal. Moving away, d¬≤ grows quadratically and probability decays exponentially.
            </p>
            <p style="margin: 0; font-size: 16px; color: rgba(139, 148, 158, 0.9);">
              The result is the multivariate Gaussian probability density function.
            </p>
          </div>

          <div>
            <p style="margin: 0 0 8px 0; font-weight: 600; color: var(--text);">
              Step 1: Define distance d¬≤ = (<b style="color: #58a6ff;">x</b> - <b style="color: #ff8800;">Œº</b>)<sup>T</sup> <b style="color: #4ecdc4;">Œ£‚Åª¬π</b> (<b style="color: #58a6ff;">x</b> - <b style="color: #ff8800;">Œº</b>)
            </p>
            <p style="margin: 0 0 16px 0; font-size: 16px; color: rgba(139, 148, 158, 0.9);">
              The Mahalanobis distance accounts for variances and correlations. The precision matrix <b style="color: #4ecdc4;">Œ£‚Åª¬π</b> shapes the ellipse.
            </p>

            <p style="margin: 0 0 8px 0; font-weight: 600; color: var(--text);">
              Step 2: Apply exponential decay: <b style="color: #3fb950;">exp</b>(<b style="color: #ff9800;">-¬Ω</b> d¬≤)
            </p>
            <p style="margin: 0 0 16px 0; font-size: 16px; color: rgba(139, 148, 158, 0.9);">
              Creates the bell-shaped curve.
            </p>

            <p style="margin: 0 0 8px 0; font-weight: 600; color: var(--text);">
              Step 3: Normalize: multiply by (<b style="color: #ba68c8;">2œÄ</b>)<sup>-d/2</sup> |<b style="color: #ff6b6b;">Œ£</b>|<sup>-1/2</sup>
            </p>
            <p style="margin: 0; font-size: 16px; color: rgba(139, 148, 158, 0.9);">
              Ensures total probability = 1. The term <b style="color: #ba68c8;">2œÄ raised to the power d/2</b> accounts for dimension; |<b style="color: #ff6b6b;">Œ£</b>| measures ellipsoid volume‚Äîsmaller determinant = more concentrated.
            </p>
          </div>
        </div>
      </div>

      <div class="equation-explanation" style="margin: 30px 0; font-size: 18px; line-height: 2; color: var(--text);">
        <p style="margin: 0 0 24px 0; font-size: 20px; font-weight: 600; color: var(--accent2);">
          Where Does 2œÄ Come From?
        </p>

        <p style="margin: 0 0 20px 0; font-size: 16px; color: rgba(139, 148, 158, 0.9);">
          The normalization constant (<b style="color: #ba68c8;">2œÄ</b>)<sup>-d/2</sup> |<b style="color: #ff6b6b;">Œ£</b>|<sup>-1/2</sup> ensures the probability integrates to 1. But why <b style="color: #ba68c8;">2œÄ</b>? It comes from the circumference of a circle‚Äîand to see it, we need to work in <b>2D</b>.
        </p>

        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 32px; align-items: start; margin: 24px 0;">
          <div style="padding: 16px; background: rgba(88, 166, 255, 0.08); border-radius: 6px;">
            <p style="margin: 0 0 12px 0; font-weight: 600; color: var(--accent);">
              The Problem (1D)
            </p>
            <p style="margin: 0 0 12px 0; font-size: 16px; color: rgba(139, 148, 158, 0.9);">
              We want to evaluate:
            </p>
            <p style="margin: 0 0 12px 0; font-family: monospace; font-size: 15px; color: var(--text); text-align: center;">
              I = ‚à´<sub>-‚àû</sub><sup>‚àû</sup> e<sup>-x¬≤/2</sup> dx
            </p>
            <p style="margin: 0; font-size: 16px; color: rgba(139, 148, 158, 0.9);">
              This integral has no closed-form antiderivative. You <b>cannot</b> use polar coordinates in 1D‚Äîthere's no angle to integrate over.
            </p>
          </div>

          <div style="padding: 16px; background: rgba(247, 129, 102, 0.08); border-radius: 6px;">
            <p style="margin: 0 0 12px 0; font-weight: 600; color: var(--accent2);">
              The Trick (2D)
            </p>
            <p style="margin: 0 0 12px 0; font-size: 16px; color: rgba(139, 148, 158, 0.9);">
              Square the integral to create a 2D <b>joint distribution</b>:
            </p>
            <p style="margin: 0 0 12px 0; font-family: monospace; font-size: 14px; color: var(--text); text-align: center;">
              I¬≤ = ‚à´‚à´<sub>‚Ñù¬≤</sub> e<sup>-(x¬≤+y¬≤)/2</sup> dx dy
            </p>
            <p style="margin: 0 0 12px 0; font-size: 16px; color: rgba(139, 148, 158, 0.9);">
              Now we have two <b>independent</b> random variables (x, y). The 2D integral factors into separate x and y integrals because they're uncorrelated.
            </p>
            <p style="margin: 0; font-size: 16px; color: rgba(139, 148, 158, 0.9);">
              The integrand depends only on <b>r¬≤ = x¬≤ + y¬≤</b> (radially symmetric), making polar coordinates natural.
            </p>
          </div>
        </div>

        <p style="margin: 24px 0 12px 0; font-size: 20px; font-weight: 600; color: var(--accent2);">
          Why 2D reveals 2œÄ
        </p>
        <p style="margin: 0 0 24px 0; font-size: 18px; line-height: 1.8; color: var(--text);">
          Squaring transforms a 1D problem (no polar coordinates) into a 2D problem where polar coordinates work. In polar coordinates (r, Œ∏), the 2D integral separates cleanly: I¬≤ = ‚à´<sub>0</sub><sup>2œÄ</sup> dŒ∏ ¬∑ ‚à´<sub>0</sub><sup>‚àû</sup> e<sup>-r¬≤/2</sup> r dr = 2œÄ ¬∑ 1 = 2œÄ. The 2œÄ is literally the angular range when you sweep around a full circle; the radial integral gives 1, therefore I = ‚àö2œÄ. In d dimensions, this generalizes to 2œÄ raised to the power d/2. The |Œ£|<sup>1/2</sup> term accounts for volume scaling‚Äîlarger covariance = wider spread = smaller peak density.
        </p>
      </div>

      <div class="equation-explanation" style="margin: 30px 0;">
        <p style="margin: 0 0 16px 0; font-size: 20px; font-weight: 600; color: var(--accent2);">
          The Exponential Function: Infinitesimal Composition
        </p>
        <p style="margin: 0 0 24px 0; font-size: 18px; line-height: 1.8; color: var(--text);">
          Repeated application at the infinitesimal level. The exponential emerges from composing tiny steps infinite times.
        </p>

        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 32px; margin: 20px 0;">
          <div>
            <p style="margin: 0 0 12px 0; font-size: 18px; font-weight: 600; color: var(--text);">
              Scalar
            </p>
            <div style="font-size: 24px; line-height: 1.8; color: var(--text); margin-bottom: 16px;">
              e<sup>x</sup> = lim<sub>n‚Üí‚àû</sub> (1 + x/n)<sup>n</sup>
            </div>
            <p style="margin: 0; font-size: 18px; line-height: 1.8; color: var(--text);">
              (1 + x/n) is a tiny growth step. Composing it with itself n times gives e<sup>x</sup>. As n‚Üí‚àû, infinitesimal steps compose to continuous growth.
            </p>
          </div>

          <div>
            <p style="margin: 0 0 12px 0; font-size: 18px; font-weight: 600; color: var(--text);">
              Matrix
            </p>
            <div style="font-size: 24px; line-height: 1.8; color: var(--text); margin-bottom: 16px;">
              <div>exp(A) = lim<sub>n‚Üí‚àû</sub> (I + A/n)<sup>n</sup></div>
              <div style="padding-left: 88px;">= Œ£<sub>k=0</sub><sup>‚àû</sup> A<sup>k</sup>/k!</div>
            </div>
            <p style="margin: 0 0 12px 0; font-size: 18px; line-height: 1.8; color: var(--text);">
              (I + A/n) is a tiny linear update: v ‚Ü¶ v + (1/n)Av. Keep most of v, nudge slightly in direction Av.
            </p>
            <p style="margin: 0; font-size: 18px; line-height: 1.8; color: var(--text);">
              Applying n times gives (I + A/n)<sup>n</sup>v ‚Üí exp(A)v. The vector traces a smooth trajectory, rotating and scaling in tiny increments until reaching the continuous flow exp(A)v.
            </p>
          </div>
        </div>

        <div style="margin: 40px 0;">
          <p style="margin: 0 0 16px 0; font-size: 20px; font-weight: 600; color: var(--accent2);">
            Why This Matters for Gaussians
          </p>

          <p style="margin: 0 0 16px 0; font-size: 18px; line-height: 1.8; color: var(--text);">
            In our probability density, we compute exp(-¬Ωd¬≤) where d¬≤ is the Mahalanobis distance. The exponential function creates smooth, bell-shaped decay as you move away from the mean‚Äîbut how does it decay?
          </p>

          <p style="margin: 0 0 16px 0; font-size: 18px; line-height: 1.8; color: var(--text);">
            The Taylor series expansion reveals the answer:
          </p>

          <p style="margin: 0 0 24px 0; font-size: 20px; line-height: 1.8; color: var(--text); text-align: center;">
            exp(M) = I + M + M¬≤/2! + M¬≥/3! + ...
          </p>

          <p style="margin: 0 0 24px 0; font-size: 18px; line-height: 1.8; color: var(--text);">
            Each term shows how correlations propagate through the distribution. Here's where it gets interesting:
          </p>

          <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 24px; margin: 24px 0;">
            <div>
              <p style="margin: 0 0 8px 0; font-size: 18px; font-weight: 600; color: var(--text);">
                Weak Correlations
              </p>
              <p style="margin: 0; font-size: 18px; line-height: 1.8; color: var(--text);">
                The first two terms (I + M) capture 85%+ of the total. Higher-order terms contribute less than 15%. The distribution is nearly "separable"‚Äîfeatures behave almost independently.
              </p>
            </div>

            <div>
              <p style="margin: 0 0 8px 0; font-size: 18px; font-weight: 600; color: var(--text);">
                Strong Correlations
              </p>
              <p style="margin: 0; font-size: 18px; line-height: 1.8; color: var(--text);">
                Higher-order terms (M¬≤/2!, M¬≥/3!, ...) become significant. You need 4+ terms to capture 90%+ of the distribution. Correlations create complex dependencies.
              </p>
            </div>
          </div>

          <p style="margin: 24px 0 0 0; font-size: 18px; line-height: 1.8; color: var(--text);">
            Click on the Correlation slider to see how Taylor Series Expansion term contributions change! When correlations are weak, the first two terms dominate. When correlations are strong, you need many more terms to capture the distribution accurately.
          </p>
        </div>
      </div>

      <div style="width: 100%; margin: 16px 0; padding: 14px; background: rgba(247, 129, 102, 0.15); border-radius: 4px;">
        <div style="font-size: 15px; font-weight: 700; color: var(--accent2); margin-bottom: 10px; text-align: center;">
          Taylor Series Expansion
        </div>
        <div style="display: flex; align-items: center; justify-content: center; gap: 8px; flex-wrap: wrap; font-size: 15px; font-weight: 600;">
          <span><b>exp(<span class="var-r">R</span>)</b> ‚âà</span>
          <span style="display: inline-flex; flex-direction: column; align-items: center; gap: 4px;">
            <span style="display: inline-flex; flex-direction: column; align-items: center;">
              <span>${renderMatrix(R0, true)}</span>
              <span style="height: 16px;"></span>
            </span>
            <span style="font-size: 12px; color: var(--accent); font-weight: 700;">${contrib0.toFixed(1)}%</span>
          </span>
          <span><b>+</b></span>
          <span style="display: inline-flex; flex-direction: column; align-items: center; gap: 4px;">
            <span style="display: inline-flex; flex-direction: column; align-items: center;">
              <span>${renderMatrix(R1, true)}</span>
              <span style="height: 16px;"></span>
            </span>
            <span style="font-size: 12px; color: var(--accent); font-weight: 700;">${contrib1.toFixed(1)}%</span>
          </span>
          <span><b>+</b></span>
          <span style="display: inline-flex; flex-direction: column; align-items: center; font-size: 11px; gap: 4px;">
            <span style="display: inline-flex; flex-direction: column; align-items: center;">
              <span>${renderMatrix(R2, true)}</span>
              <span style="border-top: 1px solid var(--text); padding-top: 2px; margin-top: 2px; font-weight: 700;">2</span>
            </span>
            <span style="font-size: 12px; color: var(--accent); font-weight: 700;">${contrib2.toFixed(1)}%</span>
          </span>
          <span><b>+</b></span>
          <span style="display: inline-flex; flex-direction: column; align-items: center; font-size: 11px; gap: 4px;">
            <span style="display: inline-flex; flex-direction: column; align-items: center;">
              <span>${renderMatrix(R3, true)}</span>
              <span style="border-top: 1px solid var(--text); padding-top: 2px; margin-top: 2px; font-weight: 700;">6</span>
            </span>
            <span style="font-size: 12px; color: var(--accent); font-weight: 700;">${contrib3.toFixed(1)}%</span>
          </span>
          <span style="color: var(--muted); font-weight: 500;">+ ...</span>
        </div>
      </div>

      <div class="contribution-analysis">
        <div style="font-size: 14px; font-weight: 600; margin-bottom: 8px; color: var(--accent);">
          How Each Term Contributes
        </div>

        <div class="equation-explanation" style="margin: 20px 0; font-size: 18px; line-height: 2; color: var(--text);">
          <p style="margin: 0;">
            We can measure how much each term in the Taylor series contributes using the Frobenius norm‚Äîa way to measure the "size" or "magnitude" of a matrix, similar to how eigenvalues measure variance explained in PCA. The bars below show both individual contributions and cumulative totals.
          </p>
        </div>

        <div class="contribution-row">
          <div class="contribution-label">Term 0 (I)</div>
          <div class="contribution-bar">
            <div class="contribution-fill" style="width: ${contrib0.toFixed(1)}%"></div>
          </div>
          <div class="contribution-value">${norm0.toFixed(2)} ‚Üí ${contrib0.toFixed(1)}% (${contrib0.toFixed(1)}%)</div>
        </div>

        <div class="contribution-row">
          <div class="contribution-label">Term 1 (R)</div>
          <div class="contribution-bar">
            <div class="contribution-fill" style="width: ${contrib1.toFixed(1)}%"></div>
          </div>
          <div class="contribution-value">${norm1.toFixed(2)} ‚Üí ${contrib1.toFixed(1)}% (${(contrib0 + contrib1).toFixed(1)}%)</div>
        </div>

        <div class="contribution-row">
          <div class="contribution-label">Term 2 (R¬≤/2)</div>
          <div class="contribution-bar">
            <div class="contribution-fill" style="width: ${contrib2.toFixed(1)}%"></div>
          </div>
          <div class="contribution-value">${norm2.toFixed(2)} ‚Üí ${contrib2.toFixed(1)}% (${(contrib0 + contrib1 + contrib2).toFixed(1)}%)</div>
        </div>

        <div class="contribution-row">
          <div class="contribution-label">Term 3 (R¬≥/6)</div>
          <div class="contribution-bar">
            <div class="contribution-fill" style="width: ${contrib3.toFixed(1)}%"></div>
          </div>
          <div class="contribution-value">${norm3.toFixed(2)} ‚Üí ${contrib3.toFixed(1)}% (100.0%)</div>
        </div>

        <div class="equation-explanation" style="margin: 20px 0; font-size: 18px; line-height: 2; color: var(--text);">
          <p style="margin: 0;">
            ${norm1 < 0.5 * norm0
              ? `When correlations are weak, the linear approximation exp(R) ‚âà I + R works remarkably well. In this case, just the first two terms capture ${(contrib0 + contrib1).toFixed(1)}% of the total contribution, meaning we can safely ignore higher-order terms. This is analogous to how in PCA, the first few principal components often explain most of the variance.`
              : `With stronger correlations, we need more terms. The first two terms only account for ${(contrib0 + contrib1).toFixed(1)}% of the total, and we need the quadratic term (R¬≤/2) to reach ${(contrib0 + contrib1 + contrib2).toFixed(1)}%. This shows that correlations introduce non-linear effects that require higher-order terms to capture accurately.`
            }
            ${det < 0.1 ? ' The determinant |<b style="color: #ff6b6b;">Œ£</b>| = ' + det.toFixed(3) + ' is very small, indicating the features are nearly collinear‚Äîthe uncertainty ellipsoid is extremely flat in one or more directions.' : ''}
          </p>
        </div>
      </div>
    `;

    // Render the main equation with KaTeX
    const renderEquation = () => {
      const equationEl = document.getElementById('mainEquation');
      const equationTopEl = document.getElementById('mainEquationTop');
      const equation = String.raw`p{\color{white}{(}}\color{#58a6ff}{\mathbf{x}} \mid \color{#ffe66d}{\boldsymbol{\mu}}, \color{#ff6b6b}{\boldsymbol{\Sigma}}{\color{white}{)}} = \frac{1}{\color{#ba68c8}{(2\pi)^{d/2}} \color{#ff6b6b}{|\boldsymbol{\Sigma}|^{1/2}}} \color{#3fb950}{\exp}{\color{#3fb950}{\Big[}}\color{#ff9800}{-\frac{1}{2}}{\color{#ffe66d}{(}}\color{#58a6ff}{\mathbf{x}} - \color{#ffe66d}{\boldsymbol{\mu}}{\color{#ffe66d}{)}}^T \color{#4ecdc4}{\boldsymbol{\Sigma}^{-1}} {\color{#ffe66d}{(}}\color{#58a6ff}{\mathbf{x}} - \color{#ffe66d}{\boldsymbol{\mu}}{\color{#ffe66d}{)}}{\color{#3fb950}{\Big]}}`;

      if (typeof katex !== 'undefined') {
        try {
          if (equationEl) {
            katex.render(equation, equationEl, { throwOnError: false, displayMode: true });
          }
          if (equationTopEl) {
            katex.render(equation, equationTopEl, { throwOnError: false, displayMode: true });
          }
        } catch (e) {
          console.error('KaTeX render error:', e);
        }
      } else if (equationEl || equationTopEl) {
        // KaTeX not loaded yet, try again
        setTimeout(renderEquation, 100);
      }
    };

    setTimeout(renderEquation, 50);

    // Draw mean vector after DOM updates
    setTimeout(() => {
      const meanVectorCanvas = document.getElementById('meanVectorCanvas');
      if (meanVectorCanvas) {
        drawMeanVector(meanVectorCanvas, data);
      }
    }, 100);
  }

  // Render GMM parameters as Gaussian curves from actual data
  function renderGMMParams(data) {
    const container = document.getElementById('gmmParams');
    const classNames = ['Setosa', 'Versicolor', 'Virginica'];
    const colors = ['#ff6b6b', '#4ecdc4', '#ffe66d'];
    const featureNames = ['Sepal Length', 'Sepal Width', 'Petal Length', 'Petal Width'];

    container.innerHTML = '';

    for (let d = 0; d < 4; d++) {
      const featurePanel = document.createElement('div');
      featurePanel.className = 'gmm-feature-panel';

      const header = document.createElement('div');
      header.className = 'gmm-feature-header';
      header.textContent = featureNames[d];
      featurePanel.appendChild(header);

      const canvas = document.createElement('canvas');
      canvas.className = 'gmm-curve-canvas';
      featurePanel.appendChild(canvas);

      const legend = document.createElement('div');
      legend.className = 'gmm-legend';

      for (let c = 0; c < 3; c++) {
        const item = document.createElement('div');
        item.className = 'gmm-legend-item';

        const dot = document.createElement('div');
        dot.className = 'gmm-legend-dot';
        dot.style.background = colors[c];
        item.appendChild(dot);

        const label = document.createElement('span');
        label.textContent = classNames[c].substring(0, 3);
        item.appendChild(label);

        legend.appendChild(item);
      }

      featurePanel.appendChild(legend);
      container.appendChild(featurePanel);

      // Draw after DOM insertion with actual data
      requestAnimationFrame(() => drawGaussianCurve(canvas, data, d));
    }
  }

  // Compute 2D covariance matrix for a specific class and dimensions
  function compute2DCovMatrix(data, classIdx, dimX, dimY) {
    const classData = data.filter(d => d.class === classIdx);
    const n = classData.length;
    if (n === 0) return { covXX: 1, covYY: 1, covXY: 0 };

    // Compute means
    let meanX = 0, meanY = 0;
    for (const d of classData) {
      meanX += d.features[dimX];
      meanY += d.features[dimY];
    }
    meanX /= n;
    meanY /= n;

    // Compute covariance
    let covXX = 0, covYY = 0, covXY = 0;
    for (const d of classData) {
      const dx = d.features[dimX] - meanX;
      const dy = d.features[dimY] - meanY;
      covXX += dx * dx;
      covYY += dy * dy;
      covXY += dx * dy;
    }
    covXX /= n;
    covYY /= n;
    covXY /= n;

    return { covXX, covYY, covXY, meanX, meanY };
  }

  // Draw rotated Gaussian ellipse using eigenvalue decomposition
  // Correctly handles non-uniform scaling between X and Y axes
  function drawEllipse(ctx, centerX, centerY, covXX, covYY, covXY, w, h, pad, minX, maxX, minY, maxY, color, alpha = 0.2, nstd = 2) {
    // Transform center to canvas coordinates
    const cx = pad + ((centerX - minX) / (maxX - minX)) * (w - 2 * pad);
    const cy = h - pad - ((centerY - minY) / (maxY - minY)) * (h - 2 * pad);

    // Calculate scale factors for X and Y axes
    const scaleX = (w - 2 * pad) / (maxX - minX);
    const scaleY = (h - 2 * pad) / (maxY - minY);

    // Transform covariance matrix to canvas space
    // This accounts for different scaling and Y-axis inversion
    const covXX_canvas = covXX * scaleX * scaleX;
    const covYY_canvas = covYY * scaleY * scaleY;
    const covXY_canvas = covXY * scaleX * scaleY * (-1); // Negate for Y-axis flip

    // Eigenvalue decomposition in canvas space
    const a = covXX_canvas, b = covXY_canvas, c = covXY_canvas, d = covYY_canvas;
    const trace = a + d;
    const det = a * d - b * c;
    const discriminant = Math.sqrt(Math.max(0, trace * trace / 4 - det));

    const lambda1 = trace / 2 + discriminant;
    const lambda2 = trace / 2 - discriminant;

    // Eigenvector for larger eigenvalue (lambda1) - now in canvas space
    // Eigenvector is [covXY, Œª‚ÇÅ - covXX] = [b, lambda1 - a]
    let angle;
    if (Math.abs(b) < 1e-10) {
      // No covariance, ellipse aligned with axes
      angle = a >= d ? 0 : Math.PI / 2;
    } else {
      // General case: eigenvector direction
      angle = Math.atan2(lambda1 - a, b);  // atan2(y-component, x-component)
    }

    // Radii - already in canvas space from transformed eigenvalues
    const rx = nstd * Math.sqrt(lambda1);
    const ry = nstd * Math.sqrt(lambda2);

    ctx.save();
    ctx.translate(cx, cy);
    ctx.rotate(angle);

    ctx.beginPath();
    ctx.ellipse(0, 0, rx, ry, 0, 0, Math.PI * 2);

    ctx.fillStyle = color + Math.floor(alpha * 255).toString(16).padStart(2, '0');
    ctx.fill();

    ctx.strokeStyle = color + Math.floor((alpha * 2) * 255).toString(16).padStart(2, '0');
    ctx.lineWidth = 1.5;
    ctx.stroke();

    ctx.restore();
  }

  // Draw scatter plot
  function drawScatter(canvas, data, dimX, dimY) {
    const ctx = canvas.getContext('2d');
    const rect = canvas.getBoundingClientRect();
    const dpr = window.devicePixelRatio || 1;

    canvas.width = rect.width * dpr;
    canvas.height = rect.height * dpr;

    ctx.scale(dpr, dpr);

    const w = rect.width;
    const h = rect.height;

    // Clear
    ctx.fillStyle = '#1b1f27';
    ctx.fillRect(0, 0, w, h);

    const colors = ['#ff6b6b', '#4ecdc4', '#ffe66d'];
    const pad = 35;

    // Get data ranges
    let minX = Infinity, maxX = -Infinity;
    let minY = Infinity, maxY = -Infinity;
    for (const d of data) {
      if (d.features[dimX] < minX) minX = d.features[dimX];
      if (d.features[dimX] > maxX) maxX = d.features[dimX];
      if (d.features[dimY] < minY) minY = d.features[dimY];
      if (d.features[dimY] > maxY) maxY = d.features[dimY];
    }

    // Add padding to ranges
    const rangeX = maxX - minX;
    const rangeY = maxY - minY;
    minX -= rangeX * 0.1;
    maxX += rangeX * 0.1;
    minY -= rangeY * 0.1;
    maxY += rangeY * 0.1;

    // Draw grid
    ctx.strokeStyle = '#30363d';
    ctx.lineWidth = 0.5;
    for (let i = 0; i <= 4; i++) {
      const x = pad + (i / 4) * (w - 2 * pad);
      const y = h - pad - (i / 4) * (h - 2 * pad);
      ctx.beginPath();
      ctx.moveTo(x, pad);
      ctx.lineTo(x, h - pad);
      ctx.stroke();
      ctx.beginPath();
      ctx.moveTo(pad, y);
      ctx.lineTo(w - pad, y);
      ctx.stroke();
    }

    // Draw axes
    ctx.strokeStyle = '#4b5563';
    ctx.lineWidth = 1.5;
    ctx.beginPath();
    ctx.moveTo(pad, h - pad);
    ctx.lineTo(w - pad, h - pad);
    ctx.moveTo(pad, pad);
    ctx.lineTo(pad, h - pad);
    ctx.stroke();

    // Draw Gaussian ellipses if enabled
    if (showEllipses) {
      for (let c = 0; c < 3; c++) {
        const cov = compute2DCovMatrix(data, c, dimX, dimY);
        drawEllipse(ctx, cov.meanX, cov.meanY, cov.covXX, cov.covYY, cov.covXY,
                    w, h, pad, minX, maxX, minY, maxY, colors[c], 0.15, 2);
      }
    }

    // Draw points
    for (const d of data) {
      const x = pad + ((d.features[dimX] - minX) / (maxX - minX)) * (w - 2 * pad);
      const y = h - pad - ((d.features[dimY] - minY) / (maxY - minY)) * (h - 2 * pad);

      ctx.fillStyle = colors[d.class];
      ctx.beginPath();
      ctx.arc(x, y, 4, 0, Math.PI * 2);
      ctx.fill();

      // Add subtle stroke
      ctx.strokeStyle = 'rgba(0,0,0,0.3)';
      ctx.lineWidth = 0.5;
      ctx.stroke();
    }

    // Axis labels
    ctx.fillStyle = '#8b949e';
    ctx.font = '10px system-ui';
    ctx.textAlign = 'left';
    ctx.fillText(minX.toFixed(1), pad - 5, h - pad + 15);
    ctx.textAlign = 'right';
    ctx.fillText(maxX.toFixed(1), w - pad + 5, h - pad + 15);

    ctx.textAlign = 'right';
    ctx.fillText(minY.toFixed(1), pad - 5, h - pad + 5);
    ctx.fillText(maxY.toFixed(1), pad - 5, pad + 5);
  }

  // Draw mean vector visualization
  function drawMeanVector(canvas, data) {
    if (!canvas) return;

    const ctx = canvas.getContext('2d');
    const dpr = window.devicePixelRatio || 1;

    // Use fixed dimensions from CSS
    const w = 400;
    const h = 320;

    canvas.width = w * dpr;
    canvas.height = h * dpr;
    ctx.scale(dpr, dpr);

    const pad = 40;

    // Clear
    ctx.fillStyle = '#0d1117';
    ctx.fillRect(0, 0, w, h);

    // Filter only Setosa class (class 0) for clarity
    const setosaData = data.filter(d => d.class === 0);

    // Use Petal Length (index 2) and Petal Width (index 3)
    const dimX = 2; // Petal Length
    const dimY = 3; // Petal Width

    // Calculate mean for all 4 dimensions
    let sum = [0, 0, 0, 0];
    for (const d of setosaData) {
      for (let i = 0; i < 4; i++) {
        sum[i] += d.features[i];
      }
    }
    const mean4D = sum.map(s => s / setosaData.length);
    const meanX = mean4D[dimX];
    const meanY = mean4D[dimY];

    // Update all mean values in the UI
    const els = ['meanVector_SL', 'meanVector_SW', 'meanVector_PL', 'meanVector_PW'];
    els.forEach((id, i) => {
      const el = document.getElementById(id);
      if (el) el.textContent = mean4D[i].toFixed(2);
    });

    // Get data ranges (include origin)
    let minX = 0, maxX = -Infinity;
    let minY = 0, maxY = -Infinity;
    for (const d of setosaData) {
      if (d.features[dimX] > maxX) maxX = d.features[dimX];
      if (d.features[dimY] > maxY) maxY = d.features[dimY];
    }

    // Add padding
    const rangeX = maxX - minX;
    const rangeY = maxY - minY;
    maxX += rangeX * 0.2;
    maxY += rangeY * 0.2;

    // Helper to convert data coords to canvas coords
    function toCanvasX(x) {
      return pad + ((x - minX) / (maxX - minX)) * (w - 2 * pad);
    }
    function toCanvasY(y) {
      return h - pad - ((y - minY) / (maxY - minY)) * (h - 2 * pad);
    }

    // Draw grid
    ctx.strokeStyle = '#21262d';
    ctx.lineWidth = 1;
    for (let i = 0; i <= 5; i++) {
      const x = pad + (i / 5) * (w - 2 * pad);
      const y = h - pad - (i / 5) * (h - 2 * pad);
      ctx.beginPath();
      ctx.moveTo(x, pad);
      ctx.lineTo(x, h - pad);
      ctx.stroke();
      ctx.beginPath();
      ctx.moveTo(pad, y);
      ctx.lineTo(w - pad, y);
      ctx.stroke();
    }

    // Draw axes
    ctx.strokeStyle = '#58a6ff';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(toCanvasX(0), toCanvasY(0));
    ctx.lineTo(toCanvasX(maxX), toCanvasY(0));
    ctx.stroke();
    ctx.beginPath();
    ctx.moveTo(toCanvasX(0), toCanvasY(0));
    ctx.lineTo(toCanvasX(0), toCanvasY(maxY));
    ctx.stroke();

    // Axis labels
    ctx.fillStyle = '#8b949e';
    ctx.font = '11px system-ui';
    ctx.textAlign = 'center';
    ctx.fillText('Petal Length (cm)', w / 2, h - 10);
    ctx.save();
    ctx.translate(12, h / 2);
    ctx.rotate(-Math.PI / 2);
    ctx.fillText('Petal Width (cm)', 0, 0);
    ctx.restore();

    // Draw points in light yellow
    for (const d of setosaData) {
      const x = toCanvasX(d.features[dimX]);
      const y = toCanvasY(d.features[dimY]);

      ctx.fillStyle = '#ffd97d'; // Light yellow
      ctx.beginPath();
      ctx.arc(x, y, 5, 0, Math.PI * 2);
      ctx.fill();

      ctx.strokeStyle = 'rgba(255, 217, 125, 0.4)';
      ctx.lineWidth = 1;
      ctx.stroke();
    }

    // Draw mean vector arrow
    const meanCanvasX = toCanvasX(meanX);
    const meanCanvasY = toCanvasY(meanY);
    const originX = toCanvasX(0);
    const originY = toCanvasY(0);

    // Arrow shaft - bright magenta for contrast
    ctx.strokeStyle = '#ff8800';
    ctx.lineWidth = 4;
    ctx.beginPath();
    ctx.moveTo(originX, originY);
    ctx.lineTo(meanCanvasX, meanCanvasY);
    ctx.stroke();

    // Arrow head
    const angle = Math.atan2(originY - meanCanvasY, meanCanvasX - originX);
    const headLen = 14;
    ctx.fillStyle = '#ff8800';
    ctx.beginPath();
    ctx.moveTo(meanCanvasX, meanCanvasY);
    ctx.lineTo(
      meanCanvasX - headLen * Math.cos(angle - Math.PI / 6),
      meanCanvasY + headLen * Math.sin(angle - Math.PI / 6)
    );
    ctx.lineTo(
      meanCanvasX - headLen * Math.cos(angle + Math.PI / 6),
      meanCanvasY + headLen * Math.sin(angle + Math.PI / 6)
    );
    ctx.closePath();
    ctx.fill();

    // Draw dotted lines to axes (showing x and y components)
    ctx.setLineDash([4, 4]);
    ctx.strokeStyle = '#ff8800';
    ctx.lineWidth = 2;

    // Vertical line down to x-axis (showing y-component)
    ctx.beginPath();
    ctx.moveTo(meanCanvasX, meanCanvasY);
    ctx.lineTo(meanCanvasX, originY);
    ctx.stroke();

    // Horizontal line left to y-axis (showing x-component)
    ctx.beginPath();
    ctx.moveTo(meanCanvasX, meanCanvasY);
    ctx.lineTo(originX, meanCanvasY);
    ctx.stroke();

    // Reset line dash
    ctx.setLineDash([]);

    // Label the mean point with frosted background
    const meanLabel = `Œº = (${meanX.toFixed(2)}, ${meanY.toFixed(2)})`;
    ctx.font = 'bold 13px system-ui';
    ctx.textAlign = 'left';
    const meanLabelWidth = ctx.measureText(meanLabel).width;

    // Frosted background
    ctx.fillStyle = 'rgba(13, 17, 23, 0.85)';
    ctx.strokeStyle = 'rgba(255, 136, 0, 0.3)';
    ctx.lineWidth = 1;
    const meanLabelX = meanCanvasX + 8;
    const meanLabelY = meanCanvasY - 22;
    ctx.beginPath();
    ctx.roundRect(meanLabelX - 4, meanLabelY, meanLabelWidth + 8, 20, 4);
    ctx.fill();
    ctx.stroke();

    // Text
    ctx.fillStyle = '#ff8800';
    ctx.fillText(meanLabel, meanLabelX, meanLabelY + 14);

    // Origin label with frosted background
    const originLabel = '(0, 0)';
    ctx.font = '11px system-ui';
    ctx.textAlign = 'right';
    const originLabelWidth = ctx.measureText(originLabel).width;

    // Frosted background
    ctx.fillStyle = 'rgba(13, 17, 23, 0.85)';
    ctx.strokeStyle = 'rgba(88, 166, 255, 0.3)';
    ctx.lineWidth = 1;
    const originLabelX = originX - 8 - originLabelWidth;
    const originLabelY = originY + 5;
    ctx.beginPath();
    ctx.roundRect(originLabelX - 4, originLabelY, originLabelWidth + 8, 18, 4);
    ctx.fill();
    ctx.stroke();

    // Text
    ctx.fillStyle = '#58a6ff';
    ctx.textAlign = 'right';
    ctx.fillText(originLabel, originX - 8, originY + 15);

    // Draw ticks on axes
    ctx.fillStyle = '#8b949e';
    ctx.font = '9px system-ui';
    ctx.textAlign = 'center';
    for (let i = 0; i <= 5; i++) {
      const val = (maxX / 5) * i;
      const x = toCanvasX(val);
      ctx.fillText(val.toFixed(1), x, h - pad + 15);
    }
    ctx.textAlign = 'right';
    for (let i = 0; i <= 5; i++) {
      const val = (maxY / 5) * i;
      const y = toCanvasY(val);
      if (i > 0) { // Skip origin to avoid overlap
        ctx.fillText(val.toFixed(1), pad - 8, y + 3);
      }
    }

    // Legend with frosted background
    const legendText = `‚ñ† Data points (n=${setosaData.length})`;
    ctx.font = '11px system-ui';
    ctx.textAlign = 'left';
    const legendWidth = ctx.measureText(legendText).width;

    // Frosted background
    ctx.fillStyle = 'rgba(13, 17, 23, 0.85)';
    ctx.strokeStyle = 'rgba(255, 217, 125, 0.3)';
    ctx.lineWidth = 1;
    const legendX = pad + 3;
    const legendY = pad - 22;
    ctx.beginPath();
    ctx.roundRect(legendX, legendY, legendWidth + 8, 18, 4);
    ctx.fill();
    ctx.stroke();

    // Text
    ctx.fillStyle = '#ffd97d';
    ctx.fillText(legendText, pad + 5, pad - 10);
  }

  // Initialize
  window.currentData = generateData();
  let currentData = window.currentData;
  const labels = ['Sepal L', 'Sepal W', 'Petal L', 'Petal W'];

  const canvases = [
    document.getElementById('canvas1'),
    document.getElementById('canvas2'),
    document.getElementById('canvas3'),
    document.getElementById('canvas4')
  ];

  const projections = [
    [0, 1], // Sepal L vs W
    [2, 3], // Petal L vs W
    [0, 2], // Sepal L vs Petal L
    [1, 3]  // Sepal W vs Petal W
  ];

  let showEllipses = false;

  // Draw all visualizations
  // Update flower icons based on actual data
  function updateFlowerIcons(data) {
    const tuning = window.flowerTuning || {
      petalBaseRadius: 1.5,
      petalLengthScale: 2.0,
      petalWidthScale: 2.4,
      setosaGain: 2.0,
      sepalSizeMin: 5,
      sepalSizeRange: 1.5,
      sepalRoundness: 20,
      sepalGreen: '#11df11'
    };

    for (let c = 0; c < 3; c++) {
      const classData = data.filter(d => d.class === c);

      // Calculate mean values for all four features
      const meanSepalLength = classData.reduce((sum, d) => sum + d.features[0], 0) / classData.length;
      const meanSepalWidth = classData.reduce((sum, d) => sum + d.features[1], 0) / classData.length;
      const meanPetalLength = classData.reduce((sum, d) => sum + d.features[2], 0) / classData.length;
      const meanPetalWidth = classData.reduce((sum, d) => sum + d.features[3], 0) / classData.length;

      // Sepal: length 4-8cm ‚Üí size, roundness controlled by slider
      const sepalSize = tuning.sepalSizeMin + (meanSepalLength - 4) * tuning.sepalSizeRange;
      const sepalRoundness = tuning.sepalRoundness; // User-controlled roundness

      // Petal dimensions based on actual measurements
      // Petal length: 1-7cm, Petal width: 0.1-2.5cm
      const rawPetalLength = 1 + (meanPetalLength - 1) * 1.5;  // Data-driven length
      const rawPetalWidth = 1 + (meanPetalWidth - 0.1) * 1.5;  // Data-driven width

      // Apply global scales and Setosa-specific gain
      const setosaMultiplier = (c === 0) ? tuning.setosaGain : 1.0;
      const petalLength = rawPetalLength * tuning.petalLengthScale * setosaMultiplier;
      const petalWidth = rawPetalWidth * tuning.petalWidthScale * setosaMultiplier;

      const flower = document.getElementById(`flower-${c}`);
      const sepal = flower.querySelector('.sepal');
      const petals = flower.querySelectorAll('.petal');

      // Style the single central sepal (behind petals)
      sepal.style.width = `${sepalSize}px`;
      sepal.style.height = `${sepalSize}px`;
      sepal.style.borderRadius = `${sepalRoundness}%`;
      sepal.style.background = tuning.sepalGreen;

      // Position and style petals - they "grow" from petalBaseRadius
      petals.forEach((petal, i) => {
        // Petals start at petalBaseRadius from center and extend outward by petalLength
        // The base (attachment point) is invisible, covered by sepal
        const attachmentRadius = tuning.petalBaseRadius;

        if (i === 0) { // top - grows upward (vertical)
          petal.style.width = `${petalWidth}px`;
          petal.style.height = `${petalLength}px`;
          petal.style.bottom = '50%';
          petal.style.left = '50%';
          petal.style.transform = `translateX(-50%) translateY(-${attachmentRadius}px)`;
          petal.style.transformOrigin = `center bottom`;
        } else if (i === 1) { // bottom - grows downward (vertical)
          petal.style.width = `${petalWidth}px`;
          petal.style.height = `${petalLength}px`;
          petal.style.top = '50%';
          petal.style.left = '50%';
          petal.style.transform = `translateX(-50%) translateY(${attachmentRadius}px)`;
          petal.style.transformOrigin = `center top`;
        } else if (i === 2) { // left - grows leftward (horizontal - swap dimensions)
          petal.style.width = `${petalLength}px`;
          petal.style.height = `${petalWidth}px`;
          petal.style.top = '50%';
          petal.style.right = '50%';
          petal.style.transform = `translateY(-50%) translateX(-${attachmentRadius}px)`;
          petal.style.transformOrigin = `right center`;
        } else { // right - grows rightward (horizontal - swap dimensions)
          petal.style.width = `${petalLength}px`;
          petal.style.height = `${petalWidth}px`;
          petal.style.top = '50%';
          petal.style.left = '50%';
          petal.style.transform = `translateY(-50%) translateX(${attachmentRadius}px)`;
          petal.style.transformOrigin = `left center`;
        }
      });
    }
  }

  function drawAll(data) {
    projections.forEach((proj, i) => {
      drawScatter(canvases[i], data, proj[0], proj[1]);
    });
    renderCorrelationMatrix(data);
    renderGMMParams(data);
    renderGaussianEquation(data);
    updateFlowerIcons(data);
    drawEllipseCalculation(data);
  }

  // Draw ellipse calculation visualization for Versicolor
  function drawEllipseCalculation(data) {
    const canvas = document.getElementById('ellipseCalcCanvas');
    if (!canvas) return;

    const ctx = canvas.getContext('2d');

    // Set canvas resolution to match display size for crisp rendering
    const rect = canvas.getBoundingClientRect();
    const dpr = window.devicePixelRatio || 1;
    canvas.width = rect.width * dpr;
    canvas.height = rect.height * dpr;
    ctx.scale(dpr, dpr);

    const w = rect.width;
    const h = rect.height;

    ctx.clearRect(0, 0, w, h);

    // Use the SAME function that draws the scatter plot ellipse!
    const dimX = 0; // Sepal Length
    const dimY = 1; // Sepal Width
    const classIdx = 1; // Versicolor

    // Get the exact same covariance data used in the first scatter plot
    const cov = compute2DCovMatrix(data, classIdx, dimX, dimY);
    const meanX = cov.meanX;
    const meanY = cov.meanY;
    const covXX = cov.covXX;
    const covYY = cov.covYY;
    const covXY = cov.covXY;

    const versicolorData = data.filter(d => d.class === classIdx);
    const n = versicolorData.length;

    // Get data range from ALL data (same as scatter plot) so we can see spread changes!
    let minX = Infinity, maxX = -Infinity;
    let minY = Infinity, maxY = -Infinity;
    for (const d of data) {
      if (d.features[dimX] < minX) minX = d.features[dimX];
      if (d.features[dimX] > maxX) maxX = d.features[dimX];
      if (d.features[dimY] < minY) minY = d.features[dimY];
      if (d.features[dimY] > maxY) maxY = d.features[dimY];
    }

    // Add padding to ranges (same as scatter plot)
    const rangeX = maxX - minX || 1;
    const rangeY = maxY - minY || 1;
    minX -= rangeX * 0.05;
    maxX += rangeX * 0.05;
    minY -= rangeY * 0.05;
    maxY += rangeY * 0.05;

    // Eigenvalue decomposition
    const trace = covXX + covYY;
    const det = covXX * covYY - covXY * covXY;
    const lambda1 = trace / 2 + Math.sqrt((trace * trace) / 4 - det);
    const lambda2 = trace / 2 - Math.sqrt((trace * trace) / 4 - det);
    const angle = Math.atan2(lambda1 - covXX, covXY);

    // Left side: Show the calculation steps
    const leftMargin = 20;
    const leftWidth = w * 0.38;
    let y = 30;
    const lineHeight = 18;

    ctx.fillStyle = '#4ecdc4';
    ctx.font = 'bold 11px system-ui';
    ctx.fillText('Step 1: Calculate Mean Œº', leftMargin, y);
    y += lineHeight;

    ctx.fillStyle = '#8b949e';
    ctx.font = '10px monospace';
    ctx.fillText(`Œº = [${meanX.toFixed(2)}, ${meanY.toFixed(2)}]`, leftMargin + 5, y);
    y += lineHeight + 6;

    ctx.fillStyle = '#4ecdc4';
    ctx.font = 'bold 11px system-ui';
    ctx.fillText('Step 2: Covariance Matrix Œ£', leftMargin, y);
    y += lineHeight;

    ctx.fillStyle = '#8b949e';
    ctx.font = '9px monospace';
    ctx.fillText(`‚îå ${covXX.toFixed(3)}  ${covXY.toFixed(3)} ‚îê`, leftMargin + 5, y);
    y += 14;
    ctx.fillText(`‚îî ${covXY.toFixed(3)}  ${covYY.toFixed(3)} ‚îò`, leftMargin + 5, y);
    y += 14;

    // Get axis scale for showing modified covariance
    const s = gmmConfig.ellipseAxisScale;
    const origDet = covXX * covYY - covXY * covXY;
    if (s < 0.99) {
      ctx.fillStyle = '#f78166';
      ctx.font = '8px monospace';
      ctx.fillText(`det(Œ£) ‚Üí det(Œ£') = ${origDet.toFixed(3)} √ó ${(s*s).toFixed(2)}`, leftMargin + 5, y);
      y += 12;
      const newDet = origDet * s * s;
      if (newDet < 0.001) {
        ctx.fillText(`         = ${newDet.toFixed(4)} ‚âà 0 (singular!)`, leftMargin + 5, y);
      }
    }
    y += lineHeight + 6;

    ctx.fillStyle = '#4ecdc4';
    ctx.font = 'bold 11px system-ui';
    ctx.fillText('Step 3: Eigendecomposition', leftMargin, y);
    y += lineHeight;

    ctx.fillStyle = '#8b949e';
    ctx.font = '9px monospace';
    ctx.fillText(`Œª‚ÇÅ = ${lambda1.toFixed(3)} (major axis)`, leftMargin + 5, y);
    y += 14;
    const lambda2Scaled = lambda2 * s * s;
    if (s < 0.99) {
      ctx.fillText(`Œª‚ÇÇ = ${lambda2.toFixed(3)} √ó ${(s*s).toFixed(2)} = ${lambda2Scaled.toFixed(3)}`, leftMargin + 5, y);
    } else {
      ctx.fillText(`Œª‚ÇÇ = ${lambda2.toFixed(3)} (minor axis)`, leftMargin + 5, y);
    }
    y += 14;
    ctx.fillText(`Œ∏ = ${(angle * 180 / Math.PI).toFixed(1)}¬∞ (rotation)`, leftMargin + 5, y);
    y += lineHeight + 6;

    ctx.fillStyle = '#4ecdc4';
    ctx.font = 'bold 11px system-ui';
    ctx.fillText('Step 4: Draw Ellipse', leftMargin, y);
    y += lineHeight;

    ctx.fillStyle = '#8b949e';
    ctx.font = '9px monospace';
    const axis1 = (2 * Math.sqrt(lambda1)).toFixed(2);
    const axis2 = (2 * Math.sqrt(lambda2) * gmmConfig.ellipseAxisScale).toFixed(2);
    ctx.fillText(`Semi-axes: 2‚àöŒª‚ÇÅ, 2‚àöŒª‚ÇÇ√óscale`, leftMargin + 5, y);
    y += 14;
    ctx.fillText(`= ${axis1}, ${axis2}`, leftMargin + 5, y);

    // Add live data indicator
    y += lineHeight + 8;
    ctx.fillStyle = '#f78166';
    ctx.font = 'bold 9px system-ui';
    ctx.fillText('Current Settings:', leftMargin, y);
    y += 14;
    ctx.fillStyle = '#8b949e';
    ctx.font = '9px monospace';
    ctx.fillText(`Spread: ${gmmConfig.spreadMultiplier.toFixed(1)}x`, leftMargin + 5, y);
    y += 12;
    ctx.fillText(`Separation: ${gmmConfig.separationMultiplier.toFixed(1)}x`, leftMargin + 5, y);
    y += 12;
    ctx.fillText(`Samples: ${n}`, leftMargin + 5, y);

    // Right side: Draw the actual ellipse visualization
    const vizLeft = leftWidth + 40;
    const vizTop = 20;
    const vizWidth = w - vizLeft - 20;
    const vizHeight = h - 40;
    const vizPad = 35;

    // Helper to convert data coordinates to canvas coordinates
    const toCanvasX = (val) => vizLeft + vizPad + ((val - minX) / (maxX - minX)) * (vizWidth - 2 * vizPad);
    const toCanvasY = (val) => vizTop + vizHeight - vizPad - ((val - minY) / (maxY - minY)) * (vizHeight - 2 * vizPad);

    // Draw axes
    ctx.strokeStyle = '#30363d';
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(vizLeft + vizPad, vizTop + vizPad);
    ctx.lineTo(vizLeft + vizPad, vizTop + vizHeight - vizPad);
    ctx.lineTo(vizLeft + vizWidth - vizPad, vizTop + vizHeight - vizPad);
    ctx.stroke();

    // Draw only Versicolor data points
    for (const d of versicolorData) {
      const px = toCanvasX(d.features[dimX]);
      const py = toCanvasY(d.features[dimY]);
      ctx.fillStyle = 'rgba(78, 205, 196, 0.5)';
      ctx.beginPath();
      ctx.arc(px, py, 3, 0, Math.PI * 2);
      ctx.fill();
    }

    // Draw mean point
    const meanPx = toCanvasX(meanX);
    const meanPy = toCanvasY(meanY);
    ctx.fillStyle = '#4ecdc4';
    ctx.beginPath();
    ctx.arc(meanPx, meanPy, 4, 0, Math.PI * 2);
    ctx.fill();

    // Draw eigenvectors in data space
    const scale = (maxX - minX) / (vizWidth - 2 * vizPad);
    const ev1X = Math.cos(angle) * Math.sqrt(lambda1);
    const ev1Y = Math.sin(angle) * Math.sqrt(lambda1);
    const ev2X = -Math.sin(angle) * Math.sqrt(lambda2) * gmmConfig.ellipseAxisScale;
    const ev2Y = Math.cos(angle) * Math.sqrt(lambda2) * gmmConfig.ellipseAxisScale;

    const ev1EndX = toCanvasX(meanX + ev1X);
    const ev1EndY = toCanvasY(meanY + ev1Y);
    const ev2EndX = toCanvasX(meanX + ev2X);
    const ev2EndY = toCanvasY(meanY + ev2Y);

    ctx.strokeStyle = '#f78166';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(meanPx, meanPy);
    ctx.lineTo(ev1EndX, ev1EndY);
    ctx.stroke();

    ctx.strokeStyle = '#58a6ff';
    ctx.beginPath();
    ctx.moveTo(meanPx, meanPy);
    ctx.lineTo(ev2EndX, ev2EndY);
    ctx.stroke();

    // Draw ellipse (2-sigma) with axis scaling
    ctx.strokeStyle = '#4ecdc4';
    ctx.lineWidth = 2;
    ctx.beginPath();
    for (let t = 0; t <= Math.PI * 2; t += 0.1) {
      const r1 = 2 * Math.sqrt(lambda1);
      const r2 = 2 * Math.sqrt(lambda2) * gmmConfig.ellipseAxisScale;
      const dataX = meanX + r1 * Math.cos(t) * Math.cos(angle) - r2 * Math.sin(t) * Math.sin(angle);
      const dataY = meanY + r1 * Math.cos(t) * Math.sin(angle) + r2 * Math.sin(t) * Math.cos(angle);
      const x = toCanvasX(dataX);
      const y = toCanvasY(dataY);
      if (t === 0) ctx.moveTo(x, y);
      else ctx.lineTo(x, y);
    }
    ctx.closePath();
    ctx.stroke();

    // Labels with bounds checking
    ctx.fillStyle = '#8b949e';
    ctx.font = '9px system-ui';
    ctx.textAlign = 'left';

    // Mean label
    const meanLabelX = Math.min(Math.max(meanPx + 6, vizLeft + vizPad + 2), vizLeft + vizWidth - vizPad - 10);
    const meanLabelY = Math.min(Math.max(meanPy - 6, vizTop + vizPad + 10), vizTop + vizHeight - vizPad - 2);
    ctx.fillText('Œº', meanLabelX, meanLabelY);

    // Eigenvector labels
    ctx.fillStyle = '#f78166';
    const v1LabelX = Math.min(Math.max(ev1EndX + 3, vizLeft + vizPad + 2), vizLeft + vizWidth - vizPad - 15);
    const v1LabelY = Math.min(Math.max(ev1EndY, vizTop + vizPad + 10), vizTop + vizHeight - vizPad - 2);
    ctx.fillText('v‚ÇÅ', v1LabelX, v1LabelY);

    ctx.fillStyle = '#58a6ff';
    const v2LabelX = Math.min(Math.max(ev2EndX + 3, vizLeft + vizPad + 2), vizLeft + vizWidth - vizPad - 15);
    const v2LabelY = Math.min(Math.max(ev2EndY, vizTop + vizPad + 10), vizTop + vizHeight - vizPad - 2);
    ctx.fillText('v‚ÇÇ', v2LabelX, v2LabelY);

    // Axis labels
    ctx.fillStyle = '#8b949e';
    ctx.font = '9px system-ui';

    // X-axis labels (bottom)
    ctx.textAlign = 'center';
    ctx.fillText(minX.toFixed(1), vizLeft + vizPad, vizTop + vizHeight - vizPad + 15);
    ctx.fillText(maxX.toFixed(1), vizLeft + vizWidth - vizPad, vizTop + vizHeight - vizPad + 15);

    // Y-axis labels (left side)
    ctx.textAlign = 'right';
    ctx.fillText(minY.toFixed(1), vizLeft + vizPad - 8, vizTop + vizHeight - vizPad + 4);
    ctx.fillText(maxY.toFixed(1), vizLeft + vizPad - 8, vizTop + vizPad + 4);
  }

  // Full regenerate
  function regenerateAll() {
    editableCorr = null;
    document.getElementById('corrModeIndicator').style.display = 'none';
    currentData = generateData();
    drawAll(currentData);

    // Notify parent window if we're in an iframe
    if (window.parent !== window) {
      window.parent.postMessage({
        type: 'dataRegenerated',
        data: currentData
      }, '*');
    }
  }

  // Check if we're in an iframe and adjust layout
  const isInIframe = window.self !== window.top;
  if (isInIframe) {
    // Force margin notes to be inline when in iframe
    const style = document.createElement('style');
    style.textContent = `
      .margin-note {
        position: static !important;
        width: 100% !important;
        margin: 8px 0 !important;
      }
      .equation-panel {
        position: relative !important;
        overflow: visible !important;
      }
      body {
        padding: 8px !important;
      }
    `;
    document.head.appendChild(style);

    // Add indicator that this is embedded view
    const info = document.querySelector('.info');
    if (info) {
      info.innerHTML += ' <span style="font-size: 9px; color: var(--muted);">(Embedded View)</span>';
    }
  }

  // Initial draw
  drawAll(currentData);

  // IIFE: Flower tuning controls (for development/tweaking)
  (function() {
    const controlsDiv = document.createElement('div');
    controlsDiv.id = 'flowerTuning';
    controlsDiv.style.cssText = `
      position: fixed;
      top: 10px;
      right: 10px;
      background: var(--panel);
      border: 1px solid var(--grid);
      border-radius: 6px;
      padding: 12px;
      z-index: 9999;
      font-size: 11px;
      min-width: 220px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.3);
      display: none;
    `;

    const title = document.createElement('div');
    title.textContent = 'üå∏ Flower Tuning';
    title.style.cssText = 'font-weight: 600; margin-bottom: 8px; color: var(--text); text-align: center; font-size: 12px; user-select: none; cursor: move;';
    controlsDiv.appendChild(title);

    const closeBtn = document.createElement('button');
    closeBtn.textContent = '√ó';
    closeBtn.classList.add('close-btn-tuning');
    closeBtn.style.cssText = `
      position: absolute;
      top: 8px;
      right: 8px;
      background: transparent;
      border: none;
      color: var(--muted);
      font-size: 18px;
      cursor: pointer;
      padding: 0;
      width: 20px;
      height: 20px;
      line-height: 1;
    `;
    closeBtn.onmouseover = () => closeBtn.style.color = 'var(--text)';
    closeBtn.onmouseout = () => closeBtn.style.color = 'var(--muted)';
    closeBtn.onclick = () => controlsDiv.remove();
    controlsDiv.appendChild(closeBtn);

    function createSlider(label, key, min, max, step, onChange) {
      const container = document.createElement('div');
      container.style.marginBottom = '8px';

      const labelEl = document.createElement('div');
      labelEl.textContent = label;
      labelEl.style.cssText = 'margin-bottom: 3px; color: var(--muted); font-size: 10px;';
      container.appendChild(labelEl);

      const sliderContainer = document.createElement('div');
      sliderContainer.style.display = 'flex';
      sliderContainer.style.alignItems = 'center';
      sliderContainer.style.gap = '6px';

      const slider = document.createElement('input');
      slider.type = 'range';
      slider.min = min;
      slider.max = max;
      slider.step = step;
      slider.value = window.flowerTuning[key];
      slider.style.cssText = 'flex: 1; cursor: pointer;';

      const valueDisplay = document.createElement('span');
      valueDisplay.textContent = window.flowerTuning[key];
      valueDisplay.style.cssText = 'min-width: 35px; text-align: right; font-family: monospace; color: var(--text); font-size: 11px;';

      slider.oninput = function() {
        const val = parseFloat(this.value);
        window.flowerTuning[key] = val;
        valueDisplay.textContent = val;
        if (onChange) onChange(val);
        updateFlowerIcons(currentData);
      };

      sliderContainer.appendChild(slider);
      sliderContainer.appendChild(valueDisplay);
      container.appendChild(sliderContainer);

      return container;
    }

    function createColorPicker(label, key, onChange) {
      const container = document.createElement('div');
      container.style.marginBottom = '8px';

      const labelEl = document.createElement('div');
      labelEl.textContent = label;
      labelEl.style.cssText = 'margin-bottom: 3px; color: var(--muted); font-size: 10px;';
      container.appendChild(labelEl);

      const pickerContainer = document.createElement('div');
      pickerContainer.style.display = 'flex';
      pickerContainer.style.alignItems = 'center';
      pickerContainer.style.gap = '6px';

      const picker = document.createElement('input');
      picker.type = 'color';
      picker.value = window.flowerTuning[key];
      picker.style.cssText = 'width: 32px; height: 20px; border: 1px solid var(--grid); cursor: pointer; border-radius: 3px;';

      const valueDisplay = document.createElement('span');
      valueDisplay.textContent = window.flowerTuning[key];
      valueDisplay.style.cssText = 'font-family: monospace; color: var(--text); font-size: 10px;';

      picker.oninput = function() {
        window.flowerTuning[key] = this.value;
        valueDisplay.textContent = this.value;
        if (onChange) onChange(this.value);
        updateFlowerIcons(currentData);
      };

      pickerContainer.appendChild(picker);
      pickerContainer.appendChild(valueDisplay);
      container.appendChild(pickerContainer);

      return container;
    }

    // Add controls
    controlsDiv.appendChild(createSlider('Petal Base Radius', 'petalBaseRadius', 0, 8, 0.5));
    controlsDiv.appendChild(createSlider('Petal Length Scale', 'petalLengthScale', 0.5, 3, 0.1));
    controlsDiv.appendChild(createSlider('Petal Width Scale', 'petalWidthScale', 0.5, 3, 0.1));
    controlsDiv.appendChild(createSlider('Setosa Gain', 'setosaGain', 0.5, 3, 0.1));

    const sepalTitle = document.createElement('div');
    sepalTitle.textContent = 'Sepal Controls';
    sepalTitle.style.cssText = 'font-weight: 600; margin-top: 10px; margin-bottom: 6px; color: var(--muted); text-align: left; border-top: 1px solid var(--grid); padding-top: 8px; font-size: 10px;';
    controlsDiv.appendChild(sepalTitle);

    controlsDiv.appendChild(createSlider('Sepal Min Size', 'sepalSizeMin', 2, 12, 0.5));
    controlsDiv.appendChild(createSlider('Sepal Size Range', 'sepalSizeRange', 0, 5, 0.1));
    controlsDiv.appendChild(createSlider('Sepal Roundness', 'sepalRoundness', 0, 50, 1));
    controlsDiv.appendChild(createColorPicker('Sepal Color', 'sepalGreen'));

    // Data controls section
    const dataTitle = document.createElement('div');
    dataTitle.textContent = 'Data Controls';
    dataTitle.style.cssText = 'font-weight: 600; margin-top: 10px; margin-bottom: 6px; color: var(--muted); text-align: left; border-top: 1px solid var(--grid); padding-top: 8px; font-size: 10px;';
    controlsDiv.appendChild(dataTitle);

    // Samples/Class selector
    const samplesContainer = document.createElement('div');
    samplesContainer.style.cssText = 'margin-bottom: 8px;';

    const samplesLabel = document.createElement('div');
    samplesLabel.textContent = 'Samples/Class';
    samplesLabel.style.cssText = 'margin-bottom: 3px; color: var(--muted); font-size: 10px;';
    samplesContainer.appendChild(samplesLabel);

    const samplesSelect = document.createElement('select');
    samplesSelect.id = 'samplesPerClass';
    samplesSelect.style.cssText = `
      width: 100%;
      background: #161b22;
      color: var(--text);
      border: 1px solid var(--grid);
      border-radius: 4px;
      padding: 4px 6px;
      font-size: 11px;
      cursor: pointer;
    `;

    const options = [25, 50, 100];
    options.forEach(val => {
      const opt = document.createElement('option');
      opt.value = val;
      opt.textContent = val;
      if (val === 50) opt.selected = true;
      samplesSelect.appendChild(opt);
    });

    samplesContainer.appendChild(samplesSelect);
    controlsDiv.appendChild(samplesContainer);

    // Button container
    const btnContainer = document.createElement('div');
    btnContainer.style.cssText = 'display: flex; gap: 4px; margin-top: 10px; border-top: 1px solid var(--grid); padding-top: 8px;';

    // Save button (copy values to clipboard)
    const saveBtn = document.createElement('button');
    saveBtn.textContent = 'Copy';
    saveBtn.style.cssText = `
      flex: 1;
      padding: 4px 8px;
      font-size: 11px;
      border-radius: 4px;
      border: 1px solid var(--grid);
      background: #161b22;
      color: var(--text);
      cursor: pointer;
    `;
    saveBtn.onmouseover = () => saveBtn.style.background = '#1f2933';
    saveBtn.onmouseout = () => saveBtn.style.background = '#161b22';
    saveBtn.onclick = () => {
      const settings = JSON.stringify(window.flowerTuning, null, 2);
      navigator.clipboard.writeText(settings).then(() => {
        const originalText = saveBtn.textContent;
        saveBtn.textContent = '‚úì Copied';
        setTimeout(() => {
          saveBtn.textContent = originalText;
        }, 1500);
      }).catch(err => {
        console.log('Settings:', settings);
        alert('Settings logged to console:\n\n' + settings);
      });
    };
    btnContainer.appendChild(saveBtn);

    // Reset button
    const resetBtn = document.createElement('button');
    resetBtn.textContent = 'Reset';
    resetBtn.style.cssText = `
      flex: 1;
      padding: 4px 8px;
      font-size: 11px;
      border-radius: 4px;
      border: 1px solid var(--grid);
      background: #161b22;
      color: var(--text);
      cursor: pointer;
    `;
    resetBtn.onmouseover = () => resetBtn.style.background = '#1f2933';
    resetBtn.onmouseout = () => resetBtn.style.background = '#161b22';
    resetBtn.onclick = () => {
      window.flowerTuning = {
        petalBaseRadius: 1.5,
        petalLengthScale: 2.0,
        petalWidthScale: 2.4,
        setosaGain: 2.0,
        sepalSizeMin: 5,
        sepalSizeRange: 1.5,
        sepalRoundness: 20,
        sepalGreen: '#11df11'
      };
      location.reload();
    };
    btnContainer.appendChild(resetBtn);

    controlsDiv.appendChild(btnContainer);

    document.body.appendChild(controlsDiv);

    // Make draggable via title
    let isDragging = false;
    let startX, startY, initialX, initialY;

    title.onmousedown = (e) => {
      isDragging = true;
      startX = e.clientX;
      startY = e.clientY;
      const rect = controlsDiv.getBoundingClientRect();
      initialX = rect.left;
      initialY = rect.top;
      e.preventDefault();
    };

    document.addEventListener('mousemove', (e) => {
      if (!isDragging) return;
      const dx = e.clientX - startX;
      const dy = e.clientY - startY;
      controlsDiv.style.left = (initialX + dx) + 'px';
      controlsDiv.style.top = (initialY + dy) + 'px';
      controlsDiv.style.right = 'auto';
    });

    document.addEventListener('mouseup', () => {
      isDragging = false;
    });
  })();

  // Data info panel toggle (below plots)
  document.getElementById('dataInfoBtn').addEventListener('click', function() {
    const infoDiv = document.getElementById('dataInfoPanel');
    const isVisible = infoDiv.style.display !== 'none';
    infoDiv.style.display = isVisible ? 'none' : 'block';
    this.textContent = isVisible ? 'info' : 'hide';
    this.style.color = isVisible ? 'var(--muted)' : 'var(--accent)';
  });

  // Scatter plots info panel toggle
  document.getElementById('scatterInfoBtn').addEventListener('click', function() {
    const infoDiv = document.getElementById('scatterInfoPanel');
    const isVisible = infoDiv.style.display !== 'none';
    infoDiv.style.display = isVisible ? 'none' : 'block';
    this.textContent = isVisible ? 'info' : 'hide';
    this.style.color = isVisible ? 'var(--muted)' : 'var(--accent)';
    if (!isVisible) {
      setTimeout(drawExampleVisualizations, 50);
    }
  });

  // Correlation matrix info panel toggle
  document.getElementById('corrInfoBtn').addEventListener('click', function() {
    const infoDiv = document.getElementById('corrInfoPanel');
    const isVisible = infoDiv.style.display !== 'none';
    infoDiv.style.display = isVisible ? 'none' : 'block';
    this.textContent = isVisible ? 'info' : 'hide';
    this.style.color = isVisible ? 'var(--muted)' : 'var(--accent)';
    if (!isVisible) {
      setTimeout(drawSubmatrixVisualizations, 50);
    }
  });

  // Submatrix interactive controls
  let selectedFeaturePair = [0, 1]; // Default: Sepal Length √ó Width
  let submatrixState = {
    varX: 0.5,
    varY: 0.5,
    cov: 0.0
  };

  function drawSubmatrixVisualizations() {
    // Draw 2x2 submatrix using HTML/CSS (like the examples)
    const submatrixDiv = document.getElementById('submatrixDisplay');
    if (submatrixDiv) {
      const matrix2x2 = [
        [submatrixState.varX, submatrixState.cov],
        [submatrixState.cov, submatrixState.varY]
      ];

      let html = '<div style="display: grid; grid-template-columns: auto 1fr auto; gap: 3px; align-items: center;">';
      html += '<div style="font-size: 16px; color: var(--muted);">[</div>';
      html += '<div style="display: grid; grid-template-rows: 1fr 1fr; gap: 2px;">';

      for (let i = 0; i < 2; i++) {
        html += '<div style="display: grid; grid-template-columns: 1fr 1fr; gap: 4px; text-align: center;">';
        for (let j = 0; j < 2; j++) {
          const val = matrix2x2[i][j];
          let bgColor;
          if (i === j) {
            bgColor = 'rgba(255,107,107,0.25)';
          } else if (val > 0) {
            bgColor = 'rgba(78,205,196,0.25)';
          } else if (val < 0) {
            bgColor = 'rgba(255,107,107,0.25)';
          } else {
            bgColor = 'rgba(139,148,158,0.2)';
          }
          html += `<div style="padding: 4px 6px; background: ${bgColor}; border-radius: 2px; font-size: 9px;">${val.toFixed(2)}</div>`;
        }
        html += '</div>';
      }

      html += '</div>';
      html += '<div style="font-size: 16px; color: var(--muted);">]</div>';
      html += '</div>';

      submatrixDiv.innerHTML = html;
    }

    // Draw 4x4 full matrix using HTML/CSS
    const fullmatrixDiv = document.getElementById('fullmatrixDisplay');
    if (fullmatrixDiv) {
      // Create full 4x4 matrix (identity as base)
      const matrix4x4 = [
        [0.5, 0, 0, 0],
        [0, 0.5, 0, 0],
        [0, 0, 0.5, 0],
        [0, 0, 0, 0.5]
      ];

      // Insert submatrix values
      const [f1, f2] = selectedFeaturePair;
      matrix4x4[f1][f1] = submatrixState.varX;
      matrix4x4[f2][f2] = submatrixState.varY;
      matrix4x4[f1][f2] = submatrixState.cov;
      matrix4x4[f2][f1] = submatrixState.cov;

      let html = '<div style="display: grid; grid-template-columns: auto 1fr auto; gap: 1px; align-items: center;">';
      html += '<div style="font-size: 12px; color: var(--muted);">[</div>';
      html += '<div style="display: grid; grid-template-rows: repeat(4, 1fr); gap: 1px;">';

      for (let i = 0; i < 4; i++) {
        html += '<div style="display: grid; grid-template-columns: repeat(4, 1fr); gap: 2px;">';
        for (let j = 0; j < 4; j++) {
          const val = matrix4x4[i][j];
          const isSelected = (i === f1 || i === f2) && (j === f1 || j === f2);

          let bgColor;
          if (i === j) {
            bgColor = isSelected ? 'rgba(255,107,107,0.3)' : 'rgba(255,107,107,0.15)';
          } else if (val > 0) {
            bgColor = isSelected ? 'rgba(78,205,196,0.35)' : 'rgba(78,205,196,0.15)';
          } else if (val < 0) {
            bgColor = isSelected ? 'rgba(255,107,107,0.35)' : 'rgba(255,107,107,0.15)';
          } else {
            bgColor = 'rgba(139,148,158,0.1)';
          }

          const border = isSelected ? '1px solid rgba(78,205,196,0.8)' : 'none';
          const fontWeight = isSelected ? 'bold' : 'normal';
          const fontSize = isSelected ? '7px' : '6px';

          html += `<div style="padding: 2px 3px; background: ${bgColor}; border-radius: 2px; text-align: center; font-size: ${fontSize}; border: ${border}; font-weight: ${fontWeight};">${Math.abs(val) >= 0.01 ? val.toFixed(2) : ''}</div>`;
        }
        html += '</div>';
      }

      html += '</div>';
      html += '<div style="font-size: 12px; color: var(--muted);">]</div>';
      html += '</div>';

      fullmatrixDiv.innerHTML = html;
    }

    // Draw live preview with ellipse
    const previewCanvas = document.getElementById('submatrixPreviewCanvas');
    if (previewCanvas) {
      const ctx = previewCanvas.getContext('2d');
      const w = previewCanvas.width;
      const h = previewCanvas.height;

      // Clear with transparent background
      ctx.clearRect(0, 0, w, h);

      // Generate example points using Cholesky decomposition
      const covXX = submatrixState.varX;
      const covYY = submatrixState.varY;
      const covXY = submatrixState.cov;

      let L, points = [];
      try {
        L = choleskyDecomposition([[covXX, covXY], [covXY, covYY]]);
        for (let i = 0; i < 25; i++) {
          const z1 = gaussianRandom();
          const z2 = gaussianRandom();
          const x = L[0][0] * z1 + L[0][1] * z2;
          const y = L[1][0] * z1 + L[1][1] * z2;
          points.push([x, y]);
        }
      } catch (e) {
        // Invalid covariance matrix, skip point generation
      }

      // Find range
      let minX = -2.5, maxX = 2.5, minY = -2.5, maxY = 2.5;
      const pad = 10;

      // Eigenvalue decomposition for ellipse
      const a = covXX, b = covXY, d = covYY;
      const trace = a + d;
      const det = a * d - b * b;
      const discriminant = Math.sqrt(Math.max(0, trace * trace / 4 - det));
      const lambda1 = trace / 2 + discriminant;
      const lambda2 = trace / 2 - discriminant;

      let angle;
      if (Math.abs(b) < 1e-10) {
        angle = a >= d ? 0 : Math.PI / 2;
      } else {
        angle = Math.atan2(lambda1 - a, b);
      }

      const cx = w / 2;
      const cy = h / 2;
      const scaleX = (w - 2 * pad) / (maxX - minX);
      const scaleY = (h - 2 * pad) / (maxY - minY);
      const rx = 2 * Math.sqrt(lambda1) * scaleX;
      const ry = 2 * Math.sqrt(lambda2) * scaleY;

      // Draw ellipse
      ctx.save();
      ctx.translate(cx, cy);
      ctx.rotate(-angle);

      ctx.beginPath();
      ctx.ellipse(0, 0, rx, ry, 0, 0, Math.PI * 2);
      ctx.strokeStyle = '#4ecdc4aa';
      ctx.lineWidth = 2;
      ctx.stroke();
      ctx.fillStyle = '#4ecdc420';
      ctx.fill();

      ctx.restore();

      // Draw points
      for (const [x, y] of points) {
        const px = cx + x * scaleX;
        const py = cy - y * scaleY;

        ctx.fillStyle = '#4ecdc4';
        ctx.beginPath();
        ctx.arc(px, py, 2.5, 0, Math.PI * 2);
        ctx.fill();
      }

      // Draw axes
      ctx.strokeStyle = 'rgba(255,255,255,0.1)';
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.moveTo(cx, pad);
      ctx.lineTo(cx, h - pad);
      ctx.moveTo(pad, cy);
      ctx.lineTo(w - pad, cy);
      ctx.stroke();

      // Draw eigenvectors
      const eigenvector1X = Math.cos(-angle);
      const eigenvector1Y = Math.sin(-angle);
      const eigenvector2X = Math.cos(-angle + Math.PI / 2);
      const eigenvector2Y = Math.sin(-angle + Math.PI / 2);

      // Scale eigenvectors by sqrt of eigenvalues
      const scale1 = 2 * Math.sqrt(lambda1) * scaleX;
      const scale2 = 2 * Math.sqrt(lambda2) * scaleY;

      // Draw eigenvector 1 (major axis) - cyan
      ctx.strokeStyle = '#4ecdc4';
      ctx.lineWidth = 3;
      ctx.beginPath();
      ctx.moveTo(cx, cy);
      ctx.lineTo(cx + eigenvector1X * scale1, cy + eigenvector1Y * scale1);
      ctx.stroke();

      // Arrowhead for eigenvector 1
      const arrow1X = cx + eigenvector1X * scale1;
      const arrow1Y = cy + eigenvector1Y * scale1;
      const arrowSize = 8;
      ctx.fillStyle = '#4ecdc4';
      ctx.beginPath();
      ctx.moveTo(arrow1X, arrow1Y);
      ctx.lineTo(
        arrow1X - arrowSize * Math.cos(-angle - Math.PI / 6),
        arrow1Y - arrowSize * Math.sin(-angle - Math.PI / 6)
      );
      ctx.lineTo(
        arrow1X - arrowSize * Math.cos(-angle + Math.PI / 6),
        arrow1Y - arrowSize * Math.sin(-angle + Math.PI / 6)
      );
      ctx.closePath();
      ctx.fill();

      // Draw eigenvector 2 (minor axis) - yellow
      ctx.strokeStyle = '#ffe66d';
      ctx.lineWidth = 3;
      ctx.beginPath();
      ctx.moveTo(cx, cy);
      ctx.lineTo(cx + eigenvector2X * scale2, cy + eigenvector2Y * scale2);
      ctx.stroke();

      // Arrowhead for eigenvector 2
      const arrow2X = cx + eigenvector2X * scale2;
      const arrow2Y = cy + eigenvector2Y * scale2;
      ctx.fillStyle = '#ffe66d';
      ctx.beginPath();
      ctx.moveTo(arrow2X, arrow2Y);
      ctx.lineTo(
        arrow2X - arrowSize * Math.cos(-angle + Math.PI / 2 - Math.PI / 6),
        arrow2Y - arrowSize * Math.sin(-angle + Math.PI / 2 - Math.PI / 6)
      );
      ctx.lineTo(
        arrow2X - arrowSize * Math.cos(-angle + Math.PI / 2 + Math.PI / 6),
        arrow2Y - arrowSize * Math.sin(-angle + Math.PI / 2 + Math.PI / 6)
      );
      ctx.closePath();
      ctx.fill();

      // Update technical data
      const correlation = covXY / (Math.sqrt(covXX) * Math.sqrt(covYY));
      const isValid = det >= 0 && !isNaN(correlation) && Math.abs(correlation) <= 1;

      document.getElementById('techLambda1').textContent = lambda1.toFixed(3);
      document.getElementById('techLambda2').textContent = lambda2.toFixed(3);
      document.getElementById('techAngle').textContent = (angle * 180 / Math.PI).toFixed(1);
      document.getElementById('techRx').textContent = Math.sqrt(lambda1).toFixed(2);
      document.getElementById('techRy').textContent = Math.sqrt(lambda2).toFixed(2);
      document.getElementById('techDet').textContent = det.toFixed(3);
      document.getElementById('techTrace').textContent = trace.toFixed(3);
      document.getElementById('techCorr').textContent = correlation.toFixed(3);
      document.getElementById('techValid').textContent = isValid ? '‚úì' : '‚úó';

      // Color the valid indicator
      const validEl = document.getElementById('techValid');
      validEl.style.color = isValid ? '#4ecdc4' : '#ff6b6b';
    }
  }

  // Live update state
  let liveUpdateEnabled = false;

  // Live button toggle
  const liveBtn = document.getElementById('liveUpdateBtn');
  liveBtn.addEventListener('click', function() {
    liveUpdateEnabled = !liveUpdateEnabled;
    if (liveUpdateEnabled) {
      this.style.borderColor = '#4ecdc4';
      this.style.color = '#4ecdc4';
      this.style.boxShadow = '0 0 8px rgba(78, 205, 196, 0.6)';
    } else {
      this.style.borderColor = 'var(--grid)';
      this.style.color = 'var(--muted)';
      this.style.boxShadow = 'none';
    }
  });

  // Submatrix slider listeners with live update support
  function applyToDataIfLive() {
    if (liveUpdateEnabled) {
      // Build custom correlation matrix
      const [f1, f2] = selectedFeaturePair;
      const customCorr = [
        [1, 0, 0, 0],
        [0, 1, 0, 0],
        [0, 0, 1, 0],
        [0, 0, 0, 1]
      ];

      // Convert variances and covariance to correlation
      const stdX = Math.sqrt(submatrixState.varX);
      const stdY = Math.sqrt(submatrixState.varY);
      const correlation = submatrixState.cov / (stdX * stdY);

      customCorr[f1][f2] = correlation;
      customCorr[f2][f1] = correlation;

      editableCorr = customCorr;
      document.getElementById('corrModeIndicator').style.display = 'block';
      currentData = generateData(editableCorr);
      drawAll(currentData);
    }
  }

  document.getElementById('submatrixVarX').addEventListener('input', function(e) {
    submatrixState.varX = parseFloat(e.target.value);
    document.getElementById('submatrixVarXValue').textContent = submatrixState.varX.toFixed(2);
    drawSubmatrixVisualizations();
    applyToDataIfLive();
  });

  document.getElementById('submatrixVarY').addEventListener('input', function(e) {
    submatrixState.varY = parseFloat(e.target.value);
    document.getElementById('submatrixVarYValue').textContent = submatrixState.varY.toFixed(2);
    drawSubmatrixVisualizations();
    applyToDataIfLive();
  });

  document.getElementById('submatrixCov').addEventListener('input', function(e) {
    submatrixState.cov = parseFloat(e.target.value);
    document.getElementById('submatrixCovValue').textContent = submatrixState.cov.toFixed(2);
    drawSubmatrixVisualizations();
    applyToDataIfLive();
  });

  // Feature pair selection
  document.querySelectorAll('.feature-pair-btn').forEach(btn => {
    btn.addEventListener('click', function() {
      document.querySelectorAll('.feature-pair-btn').forEach(b => {
        b.style.fontWeight = 'normal';
        b.style.opacity = '0.6';
      });
      this.style.fontWeight = 'bold';
      this.style.opacity = '1';

      selectedFeaturePair = this.dataset.pair.split(',').map(Number);
      drawSubmatrixVisualizations();
      applyToDataIfLive();
    });
  });

  // Apply submatrix to data
  document.getElementById('applySubmatrix').addEventListener('click', function() {
    // Build custom correlation matrix
    const [f1, f2] = selectedFeaturePair;
    const customCorr = [
      [1, 0, 0, 0],
      [0, 1, 0, 0],
      [0, 0, 1, 0],
      [0, 0, 0, 1]
    ];

    // Convert variances and covariance to correlation
    const stdX = Math.sqrt(submatrixState.varX);
    const stdY = Math.sqrt(submatrixState.varY);
    const correlation = submatrixState.cov / (stdX * stdY);

    customCorr[f1][f2] = correlation;
    customCorr[f2][f1] = correlation;

    editableCorr = customCorr;
    document.getElementById('corrModeIndicator').style.display = 'block';
    currentData = generateData(editableCorr);
    drawAll(currentData);

    // Visual feedback
    this.textContent = '‚úì Applied!';
    setTimeout(() => {
      this.textContent = 'Apply to Data';
    }, 1500);
  });

  // Reset submatrix
  document.getElementById('resetSubmatrix').addEventListener('click', function() {
    submatrixState = { varX: 0.5, varY: 0.5, cov: 0.0 };
    document.getElementById('submatrixVarX').value = '0.5';
    document.getElementById('submatrixVarY').value = '0.5';
    document.getElementById('submatrixCov').value = '0';
    document.getElementById('submatrixVarXValue').textContent = '0.50';
    document.getElementById('submatrixVarYValue').textContent = '0.50';
    document.getElementById('submatrixCovValue').textContent = '0.00';
    drawSubmatrixVisualizations();
  });

  // Initialize default feature pair button
  document.querySelector('.feature-pair-btn').style.fontWeight = 'bold';
  document.querySelector('.feature-pair-btn').style.opacity = '1';

  // Flower info toggle
  document.getElementById('flowerInfoBtn').addEventListener('click', function() {
    const infoDiv = document.getElementById('flowerInfo');
    const isVisible = infoDiv.style.display !== 'none';
    infoDiv.style.display = isVisible ? 'none' : 'block';
    this.textContent = isVisible ? 'info' : 'hide';
    this.style.color = isVisible ? 'var(--muted)' : 'var(--accent)';
  });

  // Show flower tuner when link is clicked
  document.getElementById('showFlowerTuner').addEventListener('click', function(e) {
    e.preventDefault();
    const tunerDiv = document.getElementById('flowerTuning');
    if (tunerDiv) {
      tunerDiv.style.display = tunerDiv.style.display === 'none' ? 'block' : 'none';
    }
  });

  // Event listeners

  document.getElementById('btnResetCorr').addEventListener('click', () => {
    editableCorr = null;
    document.getElementById('corrModeIndicator').style.display = 'none';
    currentData = generateData(); // Regenerate with default (no correlation)
    drawAll(currentData);
  });

  // Interactive example buttons
  document.getElementById('btnWeakCorr').addEventListener('click', () => {
    // Weak correlations: small off-diagonal values
    // This will show that Term 0 (I) + Term 1 (R) capture most of the action
    editableCorr = [
      [1.00,  0.15, -0.10,  0.05],
      [0.15,  1.00,  0.08, -0.12],
      [-0.10, 0.08,  1.00,  0.20],
      [0.05, -0.12,  0.20,  1.00]
    ];
    document.getElementById('corrModeIndicator').style.display = 'block';
    currentData = generateData(editableCorr);
    drawAll(currentData);

    // Notify parent window
    if (window.parent !== window) {
      window.parent.postMessage({ type: 'dataRegenerated', data: currentData }, '*');
    }
  });

  document.getElementById('btnStrongCorr').addEventListener('click', () => {
    // Strong correlations: large off-diagonal values
    // This requires higher-order terms for accuracy
    editableCorr = [
      [1.00,  0.75,  0.60, -0.50],
      [0.75,  1.00,  0.65, -0.45],
      [0.60,  0.65,  1.00, -0.70],
      [-0.50, -0.45, -0.70, 1.00]
    ];
    document.getElementById('corrModeIndicator').style.display = 'block';
    currentData = generateData(editableCorr);
    drawAll(currentData);

    // Notify parent window
    if (window.parent !== window) {
      window.parent.postMessage({ type: 'dataRegenerated', data: currentData }, '*');
    }
  });

  document.getElementById('btnUncorrelated').addEventListener('click', () => {
    // Identity matrix: no correlations
    // Only Term 0 matters! (all others are zero)
    editableCorr = [
      [1.00, 0.00, 0.00, 0.00],
      [0.00, 1.00, 0.00, 0.00],
      [0.00, 0.00, 1.00, 0.00],
      [0.00, 0.00, 0.00, 1.00]
    ];
    document.getElementById('corrModeIndicator').style.display = 'block';
    currentData = generateData(editableCorr);
    drawAll(currentData);

    // Notify parent window
    if (window.parent !== window) {
      window.parent.postMessage({ type: 'dataRegenerated', data: currentData }, '*');
    }
  });

  document.getElementById('btnTight').addEventListener('click', () => {
    // Low variance (tight distribution) with weak correlations
    // Shows precision matrix effect
    editableCorr = [
      [0.30,  0.05, -0.03,  0.02],
      [0.05,  0.25,  0.04, -0.03],
      [-0.03, 0.04,  0.35,  0.06],
      [0.02, -0.03,  0.06,  0.20]
    ];
    document.getElementById('corrModeIndicator').style.display = 'block';
    currentData = generateData(editableCorr);
    drawAll(currentData);

    // Notify parent window
    if (window.parent !== window) {
      window.parent.postMessage({ type: 'dataRegenerated', data: currentData }, '*');
    }
  });

  document.getElementById('btnSingular').addEventListener('click', () => {
    // Nearly singular matrix: features are almost perfectly correlated
    // Determinant approaches 0
    editableCorr = [
      [1.00,  0.95,  0.90,  0.85],
      [0.95,  1.00,  0.95,  0.90],
      [0.90,  0.95,  1.00,  0.95],
      [0.85,  0.90,  0.95,  1.00]
    ];
    document.getElementById('corrModeIndicator').style.display = 'block';
    currentData = generateData(editableCorr);
    drawAll(currentData);

    // Notify parent window
    if (window.parent !== window) {
      window.parent.postMessage({ type: 'dataRegenerated', data: currentData }, '*');
    }
  });

  document.getElementById('samplesPerClass').addEventListener('change', e => {
    gmmConfig.nPerClass = parseInt(e.target.value);
    regenerateAll();
  });

  // Ellipse toggle button
  document.getElementById('toggleEllipses').addEventListener('click', function() {
    showEllipses = !showEllipses;
    this.style.background = showEllipses ? '#161b22' : 'transparent';
    this.style.color = showEllipses ? 'var(--text)' : 'var(--muted)';
    drawAll(currentData);
  });

  document.getElementById('spreadSlider').addEventListener('input', e => {
    gmmConfig.spreadMultiplier = parseFloat(e.target.value);
    document.getElementById('spreadValue').textContent = gmmConfig.spreadMultiplier.toFixed(1);
    updateSpreads();
    regenerateAll();
  });

  document.getElementById('separationSlider').addEventListener('input', e => {
    gmmConfig.separationMultiplier = parseFloat(e.target.value);
    document.getElementById('separationValue').textContent = gmmConfig.separationMultiplier.toFixed(1);
    regenerateAll();
  });

  document.getElementById('skewSlider').addEventListener('input', e => {
    gmmConfig.versicolorSkew = parseFloat(e.target.value);
    document.getElementById('skewValue').textContent = gmmConfig.versicolorSkew.toFixed(1);
    regenerateAll();
  });

  // Axis scale slider for ellipse calculation (controls removed from UI)
  /*
  document.getElementById('axisScaleSlider').addEventListener('input', e => {
    gmmConfig.ellipseAxisScale = parseFloat(e.target.value);
    document.getElementById('axisScaleValue').textContent = gmmConfig.ellipseAxisScale.toFixed(2);
    drawEllipseCalculation(currentData);
  });

  document.getElementById('resetAxisScale').addEventListener('click', () => {
    gmmConfig.ellipseAxisScale = 1.0;
    document.getElementById('axisScaleSlider').value = '1';
    document.getElementById('axisScaleValue').textContent = '1.00';
    drawEllipseCalculation(currentData);
  });
  */

  // Regenerate on canvas click
  canvases.forEach(c => {
    c.addEventListener('click', regenerateAll);
  });

  // Redraw on resize
  window.addEventListener('resize', () => {
    drawAll(currentData);
  });

  // Toggle equation view (compact vs full)
  document.getElementById('btnToggleEquation').addEventListener('click', () => {
    const panel = document.getElementById('equationPanel');
    const btn = document.getElementById('btnToggleEquation');

    if (panel.classList.contains('compact')) {
      panel.classList.remove('compact');
      btn.textContent = 'hide';
      btn.style.color = 'var(--accent)';
    } else {
      panel.classList.add('compact');
      btn.textContent = 'info';
      btn.style.color = 'var(--muted)';
    }
  });

  // Draw example covariance visualizations in info panel
  function drawExampleVisualizations() {
    const examples = [
      { id: 'exampleCanvas1', covXX: 0.5, covYY: 0.5, covXY: 0, color: '#8b949e', nPoints: 30 },
      { id: 'exampleCanvas2', covXX: 0.5, covYY: 0.5, covXY: 0.35, color: '#4ecdc4', nPoints: 30 },
      { id: 'exampleCanvas3', covXX: 0.5, covYY: 0.5, covXY: -0.35, color: '#ff6b6b', nPoints: 30 }
    ];

    examples.forEach(ex => {
      const canvas = document.getElementById(ex.id);
      if (!canvas) return;

      const ctx = canvas.getContext('2d');
      const w = canvas.width;
      const h = canvas.height;

      // Clear
      ctx.fillStyle = 'rgba(0,0,0,0.3)';
      ctx.fillRect(0, 0, w, h);

      // Generate example points using Cholesky decomposition
      const L = choleskyDecomposition([[ex.covXX, ex.covXY], [ex.covXY, ex.covYY]]);
      const points = [];
      for (let i = 0; i < ex.nPoints; i++) {
        const z1 = gaussianRandom();
        const z2 = gaussianRandom();
        const x = L[0][0] * z1 + L[0][1] * z2;
        const y = L[1][0] * z1 + L[1][1] * z2;
        points.push([x, y]);
      }

      // Find range
      let minX = -2, maxX = 2, minY = -2, maxY = 2;

      const pad = 10;

      // Draw ellipse
      const cx = w / 2;
      const cy = h / 2;

      // Eigenvalue decomposition
      const a = ex.covXX, b = ex.covXY, d = ex.covYY;
      const trace = a + d;
      const det = a * d - b * b;
      const discriminant = Math.sqrt(Math.max(0, trace * trace / 4 - det));
      const lambda1 = trace / 2 + discriminant;
      const lambda2 = trace / 2 - discriminant;

      let angle;
      if (Math.abs(b) < 1e-10) {
        angle = a >= d ? 0 : Math.PI / 2;
      } else {
        angle = Math.atan2(lambda1 - a, b);
      }

      const scaleX = (w - 2 * pad) / (maxX - minX);
      const scaleY = (h - 2 * pad) / (maxY - minY);
      const rx = 2 * Math.sqrt(lambda1) * scaleX;
      const ry = 2 * Math.sqrt(lambda2) * scaleY;

      ctx.save();
      ctx.translate(cx, cy);
      ctx.rotate(-angle); // Negate for canvas Y-flip

      ctx.beginPath();
      ctx.ellipse(0, 0, rx, ry, 0, 0, Math.PI * 2);
      ctx.strokeStyle = ex.color + '80';
      ctx.lineWidth = 1.5;
      ctx.stroke();
      ctx.fillStyle = ex.color + '20';
      ctx.fill();

      ctx.restore();

      // Draw points
      for (const [x, y] of points) {
        const px = cx + x * scaleX;
        const py = cy - y * scaleY; // Flip Y

        ctx.fillStyle = ex.color;
        ctx.beginPath();
        ctx.arc(px, py, 2, 0, Math.PI * 2);
        ctx.fill();
      }
    });
  }

  // Draw examples on initial load if panel is open (when manually testing with panel visible)
  // Uncomment the line below if you want examples to render on page load:
  // setTimeout(drawExampleVisualizations, 100);

  // Interactive Scene 5: Euclidean vs Mahalanobis Distance
  (function() {
    const canvas = document.getElementById('euclideanVsMahalanobis');
    if (!canvas) return;

    const ctx = canvas.getContext('2d');
    const width = canvas.width;
    const height = canvas.height;

    // State
    const mu = { x: width / 2, y: height / 2 };
    let point = { x: width / 2 + 80, y: height / 2 + 50 };
    let isDragging = false;

    // Covariance matrix (for a tilted ellipse)
    const cov = [[3600, 1800], [1800, 1600]]; // Scaled for canvas

    // Compute precision matrix (inverse of covariance)
    function invertMatrix2x2(m) {
      const det = m[0][0] * m[1][1] - m[0][1] * m[1][0];
      return [
        [m[1][1] / det, -m[0][1] / det],
        [-m[1][0] / det, m[0][0] / det]
      ];
    }

    const precision = invertMatrix2x2(cov);

    function drawEllipse(ctx, cx, cy, cov, scale) {
      // Eigendecomposition for drawing ellipse
      const a = cov[0][0], b = cov[0][1], d = cov[1][1];
      const trace = a + d;
      const det = a * d - b * b;
      const lambda1 = trace / 2 + Math.sqrt(trace * trace / 4 - det);
      const lambda2 = trace / 2 - Math.sqrt(trace * trace / 4 - det);

      const angle = b === 0 ? 0 : Math.atan2(lambda1 - a, b);
      const rx = Math.sqrt(lambda1 * scale);
      const ry = Math.sqrt(lambda2 * scale);

      ctx.save();
      ctx.translate(cx, cy);
      ctx.rotate(angle);
      ctx.beginPath();
      ctx.ellipse(0, 0, rx, ry, 0, 0, 2 * Math.PI);
      ctx.restore();
    }

    function computeMahalanobis(p) {
      const dx = p.x - mu.x;
      const dy = p.y - mu.y;
      const d2 = precision[0][0] * dx * dx +
                 2 * precision[0][1] * dx * dy +
                 precision[1][1] * dy * dy;
      return Math.sqrt(Math.abs(d2));
    }

    function computeEuclidean(p) {
      const dx = p.x - mu.x;
      const dy = p.y - mu.y;
      return Math.sqrt(dx * dx + dy * dy);
    }

    function draw() {
      ctx.clearRect(0, 0, width, height);

      // Draw multiple ellipse contours (iso-Mahalanobis distance)
      ctx.strokeStyle = 'rgba(78, 205, 196, 0.3)';
      ctx.lineWidth = 1;
      for (let i = 1; i <= 3; i++) {
        drawEllipse(ctx, mu.x, mu.y, cov, i);
        ctx.stroke();
      }

      // Highlight the contour closest to current point
      const mahal = computeMahalanobis(point);
      const scale = mahal * mahal;
      ctx.strokeStyle = 'rgba(78, 205, 196, 0.8)';
      ctx.lineWidth = 2;
      drawEllipse(ctx, mu.x, mu.y, cov, scale);
      ctx.stroke();

      // Draw mean
      ctx.fillStyle = '#ff8800';
      ctx.beginPath();
      ctx.arc(mu.x, mu.y, 6, 0, 2 * Math.PI);
      ctx.fill();

      // Draw point
      ctx.fillStyle = '#58a6ff';
      ctx.beginPath();
      ctx.arc(point.x, point.y, 8, 0, 2 * Math.PI);
      ctx.fill();

      // Draw line from mu to point
      ctx.strokeStyle = 'rgba(88, 166, 255, 0.5)';
      ctx.lineWidth = 1;
      ctx.setLineDash([5, 5]);
      ctx.beginPath();
      ctx.moveTo(mu.x, mu.y);
      ctx.lineTo(point.x, point.y);
      ctx.stroke();
      ctx.setLineDash([]);

      // Update distance displays
      const euclidean = computeEuclidean(point);
      document.getElementById('euclideanDist').textContent = euclidean.toFixed(2);
      document.getElementById('mahalanobisDist').textContent = mahal.toFixed(2);
    }

    // Mouse handling - click anywhere to move point, or drag it
    canvas.addEventListener('mousedown', (e) => {
      const rect = canvas.getBoundingClientRect();
      const mx = e.clientX - rect.left;
      const my = e.clientY - rect.top;

      // Move point to mouse position
      point.x = mx;
      point.y = my;
      isDragging = true;
      draw();
    });

    canvas.addEventListener('mousemove', (e) => {
      if (isDragging) {
        const rect = canvas.getBoundingClientRect();
        point.x = e.clientX - rect.left;
        point.y = e.clientY - rect.top;
        draw();
      }
    });

    canvas.addEventListener('mouseup', () => {
      isDragging = false;
    });

    canvas.addEventListener('mouseleave', () => {
      isDragging = false;
    });

    // Initial draw
    setTimeout(draw, 0);
  })();

  // Comparative precision examples
  (function() {
    const configs = [
      { id: 'precisionLow', variance: 1.0 },
      { id: 'precisionMed', variance: 0.25 },
      { id: 'precisionHigh', variance: 0.04 }
    ];

    configs.forEach(config => {
      const canvas = document.getElementById(config.id);
      if (!canvas) return;

      const ctx = canvas.getContext('2d');
      const width = canvas.width;
      const height = canvas.height;
      const mu = { x: width / 2, y: height / 2 };
      const point = { x: width / 2 + 50, y: height / 2 }; // Fixed 50px offset

      ctx.clearRect(0, 0, width, height);

      const radius = Math.sqrt(config.variance) * 31.6; // Scale factor

      // Draw ellipse (circle)
      ctx.strokeStyle = 'rgba(78, 205, 196, 0.6)';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.arc(mu.x, mu.y, radius, 0, 2 * Math.PI);
      ctx.stroke();

      // Draw fainter outer contours
      ctx.strokeStyle = 'rgba(78, 205, 196, 0.25)';
      ctx.lineWidth = 1;
      for (let i = 2; i <= 3; i++) {
        ctx.beginPath();
        ctx.arc(mu.x, mu.y, radius * i, 0, 2 * Math.PI);
        ctx.stroke();
      }

      // Draw mean
      ctx.fillStyle = '#ff8800';
      ctx.beginPath();
      ctx.arc(mu.x, mu.y, 5, 0, 2 * Math.PI);
      ctx.fill();

      // Draw point
      ctx.fillStyle = '#58a6ff';
      ctx.beginPath();
      ctx.arc(point.x, point.y, 6, 0, 2 * Math.PI);
      ctx.fill();

      // Draw line from mu to point
      ctx.strokeStyle = 'rgba(88, 166, 255, 0.4)';
      ctx.lineWidth = 1;
      ctx.setLineDash([3, 3]);
      ctx.beginPath();
      ctx.moveTo(mu.x, mu.y);
      ctx.lineTo(point.x, point.y);
      ctx.stroke();
      ctx.setLineDash([]);
    });

    setTimeout(() => configs.forEach(c => {}), 0);
  })();

</script>
</body>
</html>
