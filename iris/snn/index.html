<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Iris SNN Pedagogy Demo</title>
  <link rel="stylesheet" href="styles.css">
</head>
<body>
<div id="app">
  <header>
    <div>
      <h1>Iris Rate-coded SNN Demo</h1>
      <div class="sub">4 → hidden → 3 network, 16 time bins with spike rasters, rate-coded interpretation</div>
    </div>
    <div class="sub">Pedagogical view: loss, confusion matrices, random vs trained, spot check</div>
  </header>

  <div id="main">
    <!-- Data Panel -->
    <div class="panel" id="dataPanel">
      <h2>Synthetic Dataset Visualization</h2>
      <div style="position: relative; width: 100%; height: 600px; border: 1px solid var(--grid); border-radius: 6px; overflow: hidden; background: var(--bg);">
        <iframe src="synthetic-iris.html" style="width: 100%; height: 100%; border: none;"></iframe>
      </div>
    </div>

    <!-- Controls -->
    <div class="panel" id="controlsPanel">
      <h2>Controls</h2>
      <div class="controls-group">
        <button id="btnInit">Reset weights</button>
        <button id="btnTrainToggle">Start training</button>
        <button id="btnStep">Single step</button>
      </div>
      <div class="controls-group">
        <label>
          <input type="checkbox" id="slowMode" checked>
          Slow mode (visual, 1 step / tick)
        </label>
        <label>
          Learning rate:
          <select id="lrSelect">
            <option value="0.02">0.02</option>
            <option value="0.05" selected>0.05</option>
            <option value="0.1">0.10</option>
          </select>
        </label>
        <label>
          Batch size:
          <select id="batchSelect">
            <option value="8">8</option>
            <option value="16" selected>16</option>
            <option value="32">32</option>
          </select>
        </label>
      </div>
      <div class="controls-group">
        <div style="font-size:11px;color:var(--muted);text-align:center;padding:6px 0;">
          Click <strong>?</strong> in bottom-right for detailed documentation
        </div>
      </div>
      <div id="stats"></div>

      <div id="samplePanel">
        <div style="display:flex;align-items:center;justify-content:space-between;">
          <div>Spot check sample</div>
          <button id="btnNextSample">Next sample</button>
        </div>
        <div id="sampleInfo"></div>
        <div class="prob-bars" id="sampleProbs"></div>
      </div>
    </div>

    <!-- Network -->
    <div class="panel" id="networkPanel">
      <h2>SNN view (rate bars + spike rasters)</h2>
      <div id="networkView"></div>
    </div>

    <!-- Metrics -->
    <div class="panel" id="metricsPanel">
      <h2>Training metrics</h2>
      <div class="metrics-section-title">Loss curve (cross-entropy)</div>
      <canvas id="lossCanvas" width="400" height="180"></canvas>

      <div class="metrics-section-title">Confusion matrices (3 classes)</div>
      <div id="confusionContainer">
        <div class="conf-panel">
          <div style="font-size:11px;margin-bottom:2px;">Random baseline (uniform guess)</div>
          <table id="confRandom" class="confusion"></table>
        </div>
        <div class="conf-panel">
          <div style="font-size:11px;margin-bottom:2px;">Current model</div>
          <table id="confModel" class="confusion"></table>
        </div>
      </div>

      <div class="metrics-section-title">ROC Curves &amp; AUC</div>
      <div style="position: relative; width: 100%; height: 580px; border: 1px solid var(--grid); border-radius: 6px; overflow: hidden; background: var(--bg);">
        <iframe id="rocIframe" src="roc.html" style="width: 100%; height: 100%; border: none;"></iframe>
      </div>
    </div>
  </div>
</div>

<!-- Documentation FAB and Modal -->
<button class="fab" id="docsFab" title="Documentation">?</button>

<div class="docs-modal" id="docsModal">
  <div class="docs-content">
    <div class="docs-header">
      <h2>SNN Demo Documentation</h2>
      <button class="close-btn" id="closeDocsModal">×</button>
    </div>
    <div class="docs-body" id="docsBody">
      <h3>SNN Interpretation</h3>
      <p>
        Each <strong>rate bar</strong> shows spike count over a 16-bin time window.
        The <strong>raster</strong> below each neuron shows one possible spike train consistent
        with that rate (Bernoulli sampling).
      </p>
      <p>
        <strong>Training</strong> uses the rate model (backprop on expected spike counts).
        In a true SNN, we would unroll time, simulate LIF dynamics, and use surrogate
        gradients through spikes (BPTT).
      </p>

      <h3>Rate-Coded vs. True SNN</h3>
      <ul>
        <li><strong>Rate Model (this demo):</strong> Neurons encode information as firing rates
          averaged over time. Training uses standard backpropagation on these rates.</li>
        <li><strong>True SNN:</strong> Would simulate discrete time steps with Leaky Integrate-and-Fire
          (LIF) dynamics, generate actual spikes, and use surrogate gradient descent through
          non-differentiable spike events.</li>
        <li><strong>Spike Rasters:</strong> The 16-cell visualization below each neuron shows
          one possible realization of spikes drawn from a Bernoulli distribution with probability
          equal to the firing rate.</li>
      </ul>

      <h3>Synthetic Dataset Generation</h3>
      <p>
        This demo uses a <strong>synthetic Iris-like dataset</strong> generated from 3 Gaussian
        clusters in ℝ⁴ space. We generate 50 samples per class (150 total) using a Box-Muller
        transform for Gaussian sampling.
      </p>

      <h4 style="font-size: 13px; color: var(--accent2); margin: 12px 0 6px 0;">Class Centers & Spreads</h4>
      <ul>
        <li><code>Setosa</code> — Center: [5.0, 3.4, 1.5, 0.2], Spread: [0.2, 0.2, 0.2, 0.05]</li>
        <li><code>Versicolor</code> — Center: [6.0, 2.8, 4.5, 1.3], Spread: [0.4, 0.3, 0.4, 0.2]</li>
        <li><code>Virginica</code> — Center: [6.7, 3.1, 5.5, 2.1], Spread: [0.5, 0.3, 0.6, 0.25]</li>
      </ul>

      <h4 style="font-size: 13px; color: var(--accent2); margin: 12px 0 6px 0;">Normalization</h4>
      <p>
        Features are <strong>z-score normalized</strong> (zero mean, unit variance) for training:
      </p>
      <p style="font-family: monospace; font-size: 11px; background: var(--bg); padding: 8px; border-radius: 4px;">
        x_normalized = (x - μ) / σ
      </p>
      <p>
        where μ is the mean and σ is the standard deviation computed across all 150 samples
        for each of the 4 features.
      </p>

      <h4 style="font-size: 13px; color: var(--accent2); margin: 12px 0 6px 0;">Why Synthetic Data?</h4>
      <ul>
        <li><strong>Pedagogical clarity:</strong> Simple, controlled distribution for teaching</li>
        <li><strong>Reproducible:</strong> Each page load generates fresh data with consistent properties</li>
        <li><strong>Tunable:</strong> Easy to adjust class separation and overlap</li>
        <li><strong>Comparison:</strong> Can swap with real Iris dataset to see difference</li>
      </ul>

      <h4 style="font-size: 13px; color: var(--accent2); margin: 12px 0 6px 0;">Visualization</h4>
      <p>
        Explore the synthetic data generation interactively:
      </p>
      <div style="width: 100%; height: 800px; border: 1px solid var(--grid); border-radius: 6px; overflow: auto; background: var(--bg); margin: 12px 0;">
        <iframe src="synthetic-iris.html" title="Synthetic Iris Data Visualization" style="width: 100%; min-height: 1200px; border: none; display: block;"></iframe>
      </div>
      <p style="text-align: center; margin: 8px 0;">
        <a href="synthetic-iris.html" target="_blank" style="color: var(--accent); text-decoration: none;">
          Open in new tab ↗
        </a>
      </p>

      <h3>Network Architecture</h3>
      <p>
        <strong>4 inputs → 6 hidden → 3 outputs</strong>
      </p>
      <ul>
        <li><strong>Input layer:</strong> 4 neurons encoding normalized features</li>
        <li><strong>Hidden layer:</strong> 6 neurons with sigmoid activation</li>
        <li><strong>Output layer:</strong> 3 neurons with softmax (class probabilities)</li>
        <li><strong>Training:</strong> Cross-entropy loss, mini-batch SGD</li>
      </ul>

      <h3>Confusion Matrix</h3>
      <p>
        The <strong>random baseline</strong> shows performance of a uniform random classifier
        (33.3% accuracy for 3 classes). The <strong>current model</strong> matrix updates
        in real-time as the network trains.
      </p>
      <p>
        Diagonal cells (green) are correct predictions; off-diagonal cells (red) are errors.
      </p>

      <h3>ROC Curves &amp; AUC</h3>
      <p>
        <strong>Receiver Operating Characteristic (ROC)</strong> curves visualize the trade-off
        between true positive rate (TPR) and false positive rate (FPR) across all decision thresholds.
      </p>
      <p>
        For multi-class classification, we use the <strong>one-vs-rest</strong> strategy:
        each class is treated as "positive" vs all others as "negative", producing 3 binary ROC curves.
      </p>
      <ul>
        <li><strong>TPR (Sensitivity):</strong> TP / (TP + FN) — fraction of positives correctly identified</li>
        <li><strong>FPR:</strong> FP / (FP + TN) — fraction of negatives incorrectly classified as positive</li>
        <li><strong>AUC (Area Under Curve):</strong> Scalar summary of classifier performance
          <ul>
            <li>0.5 = random classifier (diagonal line)</li>
            <li>0.7-0.8 = acceptable discrimination</li>
            <li>0.8-0.9 = excellent discrimination</li>
            <li>&gt;0.9 = outstanding discrimination</li>
          </ul>
        </li>
      </ul>
      <p>
        <strong>Probabilistic interpretation:</strong> AUC = Pr(s(x⁺) &gt; s(x⁻)), the probability
        that the classifier scores a random positive sample higher than a random negative sample.
      </p>
      <p>
        A perfect classifier has AUC = 1.0 and its curve hugs the top-left corner (100% TPR at 0% FPR).
      </p>
    </div>
  </div>
</div>

<script>
  // ----- configuration -----
  const CONFIG = {
    NUM_INPUT: 4,
    NUM_HIDDEN: 6,
    NUM_OUTPUT: 3,
    RATE_LEVELS: 16,
    MAX_LOSS_POINTS: 500,
    LEARNING_RATE: 0.05,
    BATCH_SIZE: 16
  };

  const LAYOUT = {
    NEURON_HEIGHT: 96,
    NEURON_WIDTH: 44,
    RASTER_HEIGHT: 12,
    RASTER_BOTTOM: 2,
    LABEL_BOTTOM: 18,
    FILL_BOTTOM: 16
  };

  const NEURON_STYLES = {
    input: { baseHue: 210, hueRange: 0, saturation: 80, lightness: 55 },
    hidden: { baseHue: 210, hueRange: 150, saturation: 80, lightness: 55 },
    output: { baseHue: 40, hueRange: 40, saturation: 80, lightness: 55 }
  };

  const LABELS = {
    input: ['Sepal L', 'Sepal W', 'Petal L', 'Petal W'],
    output: ['Setosa', 'Versicolor', 'Virginica']
  };

  // State objects
  const network = {
    W1: null,
    b1: null,
    W2: null,
    b2: null
  };

  const dataset = {
    samples: [],
    featureMin: new Array(CONFIG.NUM_INPUT).fill(Infinity),
    featureMax: new Array(CONFIG.NUM_INPUT).fill(-Infinity)
  };

  const training = {
    lossHistory: [],
    valLossHistory: [],
    stepCount: 0,
    timer: null,
    isTraining: false,
    randomConfusion: null
  };

  const ui = {
    neuronLayers: { input: [], hidden: [], output: [] },
    connections: [],
    currentSampleIndex: 0
  };

  // ----- Helper functions -----

  // DOM helpers
  function createElement(tag, className, content = '') {
    const el = document.createElement(tag);
    if (className) el.className = className;
    if (content) el.textContent = content;
    return el;
  }

  function createNeuronRasterCell() {
    return createElement('div', 'neuron-raster-cell');
  }

  // Color and gradient helpers
  function makeGradient(hue, sat = 80, light = 55) {
    return `linear-gradient(180deg, hsla(${hue},${sat}%,${light}%,0.9), hsla(${hue},${sat}%,${light - 20}%,0.15))`;
  }

  function getRGBAGradient(r, g, b) {
    return `linear-gradient(180deg, rgba(${r},${g},${b},0.9), rgba(${r},${g},${b},0.1))`;
  }

  function getNeuronColor(layerType, frac) {
    const style = NEURON_STYLES[layerType];
    if (!style) return getRGBAGradient(88, 166, 255);

    if (layerType === 'input') {
      return getRGBAGradient(88, 166, 255);
    }

    const hue = style.baseHue - frac * style.hueRange;
    return makeGradient(hue, style.saturation, style.lightness);
  }

  // Gaussian RNG for synthetic clusters
  let _gaussSpare = null;
  function gaussianRandom() {
    if (_gaussSpare !== null) {
      const v = _gaussSpare;
      _gaussSpare = null;
      return v;
    }
    let u = 0, v = 0;
    while (u === 0) u = Math.random();
    while (v === 0) v = Math.random();
    const mag = Math.sqrt(-2.0 * Math.log(u));
    const z0 = mag * Math.cos(2 * Math.PI * v);
    const z1 = mag * Math.sin(2 * Math.PI * v);
    _gaussSpare = z1;
    return z0;
  }

  function generateSyntheticIris() {
    // Approximate class centers and spreads in original Iris ranges
    const centers = [
      [5.0, 3.4, 1.5, 0.2], // setosa
      [6.0, 2.8, 4.5, 1.3], // versicolor
      [6.7, 3.1, 5.5, 2.1]  // virginica
    ];
    const spreads = [
      [0.2, 0.2, 0.2, 0.05],
      [0.4, 0.3, 0.4, 0.2],
      [0.5, 0.3, 0.6, 0.25]
    ];
    const nPerClass = 50;
    const data = [];
    dataset.featureMin.fill(Infinity);
    dataset.featureMax.fill(-Infinity);
    for (let c = 0; c < CONFIG.NUM_OUTPUT; c++) {
      for (let n = 0; n < nPerClass; n++) {
        const raw = [];
        for (let d = 0; d < CONFIG.NUM_INPUT; d++) {
          const val = centers[c][d] + spreads[c][d] * gaussianRandom();
          raw.push(val);
          if (val < dataset.featureMin[d]) dataset.featureMin[d] = val;
          if (val > dataset.featureMax[d]) dataset.featureMax[d] = val;
        }
        data.push({ raw, y: c });
      }
    }
    // z-score normalization for training
    const mean = new Array(CONFIG.NUM_INPUT).fill(0);
    const std = new Array(CONFIG.NUM_INPUT).fill(0);
    const N = data.length;
    for (const s of data) {
      for (let d = 0; d < CONFIG.NUM_INPUT; d++) {
        mean[d] += s.raw[d];
      }
    }
    for (let d = 0; d < CONFIG.NUM_INPUT; d++) {
      mean[d] /= N;
    }
    for (const s of data) {
      for (let d = 0; d < CONFIG.NUM_INPUT; d++) {
        const diff = s.raw[d] - mean[d];
        std[d] += diff * diff;
      }
    }
    for (let d = 0; d < CONFIG.NUM_INPUT; d++) {
      std[d] = Math.sqrt(std[d] / N) || 1.0;
    }
    for (const s of data) {
      const x = new Array(CONFIG.NUM_INPUT);
      for (let d = 0; d < CONFIG.NUM_INPUT; d++) {
        x[d] = (s.raw[d] - mean[d]) / std[d];
      }
      s.x = x;
    }
    return data;
  }

  // ----- network math -----
  function initNetwork() {
    network.W1 = new Array(CONFIG.NUM_HIDDEN);
    network.b1 = new Array(CONFIG.NUM_HIDDEN);
    network.W2 = new Array(CONFIG.NUM_OUTPUT);
    network.b2 = new Array(CONFIG.NUM_OUTPUT);
    for (let j = 0; j < CONFIG.NUM_HIDDEN; j++) {
      network.W1[j] = new Array(CONFIG.NUM_INPUT);
      for (let i = 0; i < CONFIG.NUM_INPUT; i++) {
        network.W1[j][i] = (Math.random() - 0.5) * 0.5;
      }
      network.b1[j] = 0;
    }
    for (let k = 0; k < CONFIG.NUM_OUTPUT; k++) {
      network.W2[k] = new Array(CONFIG.NUM_HIDDEN);
      for (let j = 0; j < CONFIG.NUM_HIDDEN; j++) {
        network.W2[k][j] = (Math.random() - 0.5) * 0.5;
      }
      network.b2[k] = 0;
    }
    training.lossHistory = [];
    training.stepCount = 0;
  }

  function sigmoid(x) {
    return 1 / (1 + Math.exp(-x));
  }
  function softmax(logits) {
    let maxLogit = -Infinity;
    for (let i = 0; i < logits.length; i++) {
      if (logits[i] > maxLogit) maxLogit = logits[i];
    }
    const exps = new Array(logits.length);
    let sum = 0;
    for (let i = 0; i < logits.length; i++) {
      const e = Math.exp(logits[i] - maxLogit);
      exps[i] = e;
      sum += e;
    }
    const probs = new Array(logits.length);
    for (let i = 0; i < logits.length; i++) {
      probs[i] = exps[i] / sum;
    }
    return probs;
  }
  function forwardSingle(x) {
    const z1 = new Array(CONFIG.NUM_HIDDEN);
    const h = new Array(CONFIG.NUM_HIDDEN);
    for (let j = 0; j < CONFIG.NUM_HIDDEN; j++) {
      let sum = network.b1[j];
      for (let i = 0; i < CONFIG.NUM_INPUT; i++) {
        sum += network.W1[j][i] * x[i];
      }
      z1[j] = sum;
      h[j] = sigmoid(sum);
    }
    const z2 = new Array(CONFIG.NUM_OUTPUT);
    for (let k = 0; k < CONFIG.NUM_OUTPUT; k++) {
      let sum = network.b2[k];
      for (let j = 0; j < CONFIG.NUM_HIDDEN; j++) {
        sum += network.W2[k][j] * h[j];
      }
      z2[k] = sum;
    }
    const probs = softmax(z2);
    return { z1, h, z2, probs };
  }
  function argmax(arr) {
    let best = 0;
    let bestVal = arr[0];
    for (let i = 1; i < arr.length; i++) {
      if (arr[i] > bestVal) {
        bestVal = arr[i];
        best = i;
      }
    }
    return best;
  }

  function trainStep() {
    if (!dataset.samples || dataset.samples.length === 0) return;
    const batchSize = CONFIG.BATCH_SIZE;
    const n = dataset.samples.length;
    const z1Batch = new Array(batchSize);
    const hBatch = new Array(batchSize);
    const z2Batch = new Array(batchSize);
    const pBatch = new Array(batchSize);
    const yBatch = new Array(batchSize);
    const xBatch = new Array(batchSize);

    // sample batch
    for (let s = 0; s < batchSize; s++) {
      const idx = Math.floor(Math.random() * n);
      const sample = dataset.samples[idx];
      xBatch[s] = sample.x.slice();
      yBatch[s] = sample.y;
    }

    // forward
    let loss = 0;
    for (let s = 0; s < batchSize; s++) {
      const x = xBatch[s];
      const { z1, h, z2, probs } = forwardSingle(x);
      z1Batch[s] = z1;
      hBatch[s] = h;
      z2Batch[s] = z2;
      pBatch[s] = probs;
      loss += -Math.log(probs[yBatch[s]] + 1e-9);
    }
    loss /= batchSize;

    // backward
    const dW2 = new Array(CONFIG.NUM_OUTPUT);
    const db2 = new Array(CONFIG.NUM_OUTPUT).fill(0);
    const dW1 = new Array(CONFIG.NUM_HIDDEN);
    const db1 = new Array(CONFIG.NUM_HIDDEN).fill(0);
    for (let k = 0; k < CONFIG.NUM_OUTPUT; k++) {
      dW2[k] = new Array(CONFIG.NUM_HIDDEN).fill(0);
    }
    for (let j = 0; j < CONFIG.NUM_HIDDEN; j++) {
      dW1[j] = new Array(CONFIG.NUM_INPUT).fill(0);
    }

    for (let s = 0; s < batchSize; s++) {
      const probs = pBatch[s];
      const h = hBatch[s];
      const x = xBatch[s];
      const y = yBatch[s];

      const dZ2 = new Array(CONFIG.NUM_OUTPUT);
      for (let k = 0; k < CONFIG.NUM_OUTPUT; k++) {
        dZ2[k] = probs[k] - (k === y ? 1 : 0);
      }
      // output layer grads
      for (let k = 0; k < CONFIG.NUM_OUTPUT; k++) {
        db2[k] += dZ2[k];
        for (let j = 0; j < CONFIG.NUM_HIDDEN; j++) {
          dW2[k][j] += dZ2[k] * h[j];
        }
      }
      // hidden layer
      const dH = new Array(CONFIG.NUM_HIDDEN).fill(0);
      for (let j = 0; j < CONFIG.NUM_HIDDEN; j++) {
        let sum = 0;
        for (let k = 0; k < CONFIG.NUM_OUTPUT; k++) {
          sum += dZ2[k] * network.W2[k][j];
        }
        dH[j] = sum;
      }
      for (let j = 0; j < CONFIG.NUM_HIDDEN; j++) {
        const sig = h[j];
        const dZ1 = dH[j] * sig * (1 - sig);
        db1[j] += dZ1;
        for (let i = 0; i < CONFIG.NUM_INPUT; i++) {
          dW1[j][i] += dZ1 * x[i];
        }
      }
    }

    const scale = CONFIG.LEARNING_RATE / batchSize;
    for (let k = 0; k < CONFIG.NUM_OUTPUT; k++) {
      network.b2[k] -= scale * db2[k];
      for (let j = 0; j < CONFIG.NUM_HIDDEN; j++) {
        network.W2[k][j] -= scale * dW2[k][j];
      }
    }
    for (let j = 0; j < CONFIG.NUM_HIDDEN; j++) {
      network.b1[j] -= scale * db1[j];
      for (let i = 0; i < CONFIG.NUM_INPUT; i++) {
        network.W1[j][i] -= scale * dW1[j][i];
      }
    }

    if (training.lossHistory.length >= CONFIG.MAX_LOSS_POINTS) training.lossHistory.shift();
    training.lossHistory.push({ step: training.stepCount, loss });

    // Compute validation loss every 5 steps
    if (training.stepCount % 5 === 0) {
      let valLoss = 0;
      const valSize = Math.min(30, dataset.samples.length);
      for (let i = 0; i < valSize; i++) {
        const idx = Math.floor(Math.random() * dataset.samples.length);
        const sample = dataset.samples[idx];
        const { probs } = forwardSingle(sample.x);
        valLoss += -Math.log(probs[sample.y] + 1e-9);
      }
      valLoss /= valSize;
      if (training.valLossHistory.length >= CONFIG.MAX_LOSS_POINTS) training.valLossHistory.shift();
      training.valLossHistory.push({ step: training.stepCount, loss: valLoss });
    }

    training.stepCount++;
  }

  // ----- visualization helpers -----
  function createNeuron(labelText, layerKey) {
    const wrapper = createElement('div', 'neuron');
    const fill = createElement('div', 'neuron-fill');
    const label = createElement('div', 'neuron-label', labelText);
    const level = createElement('div', 'neuron-level', `0/${CONFIG.RATE_LEVELS - 1}`);

    // Create spike raster (16 time bins)
    const raster = createElement('div', 'neuron-raster');
    const rasterCells = [];
    for (let t = 0; t < CONFIG.RATE_LEVELS; t++) {
      const cell = createNeuronRasterCell();
      raster.appendChild(cell);
      rasterCells.push(cell);
    }

    wrapper.appendChild(fill);
    wrapper.appendChild(label);
    wrapper.appendChild(level);
    wrapper.appendChild(raster);
    ui.neuronLayers[layerKey].push({ wrapper, fill, level, rasterCells });
    return wrapper;
  }

  function buildNetworkDiagram() {
    const panel = document.getElementById('networkView');
    panel.innerHTML = '';
    ui.neuronLayers.input.length = 0;
    ui.neuronLayers.hidden.length = 0;
    ui.neuronLayers.output.length = 0;
    ui.connections.length = 0;

    const inputLayer = createElement('div', 'layer');
    const hiddenLayer = createElement('div', 'layer');
    const outputLayer = createElement('div', 'layer');

    const inTitle = createElement('div', 'layer-title', 'Inputs (features)');
    const hTitle = createElement('div', 'layer-title', 'Hidden (rate neurons)');
    const outTitle = createElement('div', 'layer-title', 'Outputs (classes)');

    inputLayer.appendChild(inTitle);
    hiddenLayer.appendChild(hTitle);
    outputLayer.appendChild(outTitle);

    for (let i = 0; i < CONFIG.NUM_INPUT; i++) {
      inputLayer.appendChild(createNeuron(LABELS.input[i], 'input'));
    }
    for (let j = 0; j < CONFIG.NUM_HIDDEN; j++) {
      hiddenLayer.appendChild(createNeuron('H' + (j + 1), 'hidden'));
    }
    for (let k = 0; k < CONFIG.NUM_OUTPUT; k++) {
      outputLayer.appendChild(createNeuron(LABELS.output[k], 'output'));
    }

    panel.appendChild(inputLayer);
    panel.appendChild(hiddenLayer);
    panel.appendChild(outputLayer);

    // connections as offset divs with single borders
    requestAnimationFrame(() => {
      layoutConnections(panel);
      updateConnectionStyles();
      updateNetworkVisualization();
    });
  }

  function layoutConnections(panel) {
    const panelRect = panel.getBoundingClientRect();
    function connect(layerFrom, layerTo, matrixName) {
      for (let dst = 0; dst < layerTo.length; dst++) {
        const dstElem = layerTo[dst].wrapper;
        const dr = dstElem.getBoundingClientRect();
        const y2 = dr.top + dr.height / 2 - panelRect.top;
        const x2 = dr.left - panelRect.left;
        for (let src = 0; src < layerFrom.length; src++) {
          const srcElem = layerFrom[src].wrapper;
          const sr = srcElem.getBoundingClientRect();
          const y1 = sr.top + sr.height / 2 - panelRect.top;
          const x1 = sr.right - panelRect.left;
          const dx = x2 - x1;
          const dy = y2 - y1;
          const len = Math.sqrt(dx * dx + dy * dy);
          const angle = Math.atan2(dy, dx) * 180 / Math.PI;
          const line = createElement('div', 'connection');
          line.style.left = x1 + 'px';
          line.style.top = y1 + 'px';
          line.style.width = len + 'px';
          line.style.transform = 'rotate(' + angle + 'deg)';
          panel.appendChild(line);
          ui.connections.push({ div: line, matrix: matrixName, src, dst });
        }
      }
    }
    connect(ui.neuronLayers.input, ui.neuronLayers.hidden, 'W1');
    connect(ui.neuronLayers.hidden, ui.neuronLayers.output, 'W2');
  }

  function activationToRateLevel(v) {
    const vClamped = Math.max(0, Math.min(1, v));
    const level = Math.round(vClamped * (CONFIG.RATE_LEVELS - 1));
    const frac = level / (CONFIG.RATE_LEVELS - 1);
    return { level, frac };
  }

  // Generate spike train from rate using Bernoulli sampling
  function setRasterFromRate(neuron, rate) {
    if (!neuron.rasterCells) return;
    for (let t = 0; t < CONFIG.RATE_LEVELS; t++) {
      const cell = neuron.rasterCells[t];
      const spike = Math.random() < rate; // Bernoulli(rate)
      cell.classList.toggle('on', spike);
    }
  }

  // Unified neuron display update
  function updateNeuronDisplay(neuron, value, layerType) {
    const { level, frac } = activationToRateLevel(value);
    neuron.fill.style.height = (frac * 100).toFixed(1) + '%';
    neuron.fill.style.background = getNeuronColor(layerType, frac);
    neuron.level.textContent = level + '/' + (CONFIG.RATE_LEVELS - 1);
    setRasterFromRate(neuron, frac);
  }

  function updateNetworkVisualization() {
    if (!dataset.samples || dataset.samples.length === 0) return;
    const sample = dataset.samples[Math.floor(Math.random() * dataset.samples.length)];
    const res = forwardSingle(sample.x);

    // inputs: normalize raw features into [0,1] by min/max
    for (let d = 0; d < CONFIG.NUM_INPUT; d++) {
      const neuron = ui.neuronLayers.input[d];
      const min = dataset.featureMin[d];
      const max = dataset.featureMax[d];
      const value = (sample.raw[d] - min) / (max - min || 1);
      updateNeuronDisplay(neuron, value, 'input');
    }

    // hidden
    for (let j = 0; j < CONFIG.NUM_HIDDEN; j++) {
      const neuron = ui.neuronLayers.hidden[j];
      updateNeuronDisplay(neuron, res.h[j], 'hidden');
    }

    // outputs: probabilities
    for (let k = 0; k < CONFIG.NUM_OUTPUT; k++) {
      const neuron = ui.neuronLayers.output[k];
      updateNeuronDisplay(neuron, res.probs[k], 'output');
    }
  }

  function getMaxAbsWeight() {
    let maxAbs = 0;
    for (let j = 0; j < CONFIG.NUM_HIDDEN; j++) {
      for (let i = 0; i < CONFIG.NUM_INPUT; i++) {
        maxAbs = Math.max(maxAbs, Math.abs(network.W1[j][i]));
      }
    }
    for (let k = 0; k < CONFIG.NUM_OUTPUT; k++) {
      for (let j = 0; j < CONFIG.NUM_HIDDEN; j++) {
        maxAbs = Math.max(maxAbs, Math.abs(network.W2[k][j]));
      }
    }
    return Math.max(maxAbs, 1e-6);
  }

  function updateConnectionStyles() {
    if (!ui.connections.length) return;
    const maxAbs = getMaxAbsWeight();

    for (const conn of ui.connections) {
      const w = conn.matrix === 'W1'
        ? network.W1[conn.dst][conn.src]
        : network.W2[conn.dst][conn.src];

      const strength = Math.min(1, Math.abs(w) / maxAbs);
      const width = 0.6 + 4.0 * strength;
      const hue = w >= 0 ? 200 : 20; // blue vs red
      const alpha = 0.15 + 0.75 * strength;

      conn.div.style.borderTopWidth = `${width.toFixed(2)}px`;
      conn.div.style.borderTopColor = `hsla(${hue},80%,55%,${alpha.toFixed(2)})`;
    }
  }

  function drawLossCurve() {
    const canvas = document.getElementById('lossCanvas');
    const ctx = canvas.getContext('2d');
    const w = canvas.width;
    const h = canvas.height;
    ctx.clearRect(0, 0, w, h);

    const left = 32, right = w - 10;
    const top = 10, bottom = h - 20;

    // axes
    ctx.strokeStyle = '#4b5563';
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(left, top);
    ctx.lineTo(left, bottom);
    ctx.lineTo(right, bottom);
    ctx.stroke();

    if (training.lossHistory.length < 2) return;

    let minL = Infinity, maxL = -Infinity;
    for (const p of training.lossHistory) {
      if (p.loss < minL) minL = p.loss;
      if (p.loss > maxL) maxL = p.loss;
    }
    for (const p of training.valLossHistory) {
      if (p.loss < minL) minL = p.loss;
      if (p.loss > maxL) maxL = p.loss;
    }
    if (!isFinite(minL) || !isFinite(maxL)) return;
    if (minL === maxL) maxL = minL + 1;

    // Draw horizontal reference line at 50% of range
    const refLoss = minL + (maxL - minL) * 0.5;
    const refY = bottom - (bottom - top) * 0.5;
    ctx.setLineDash([4, 4]);
    ctx.strokeStyle = 'rgba(139,148,158,0.3)';
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(left, refY);
    ctx.lineTo(right, refY);
    ctx.stroke();
    ctx.setLineDash([]);

    // Label for reference line
    ctx.fillStyle = 'rgba(139,148,158,0.6)';
    ctx.font = '10px system-ui';
    ctx.fillText(refLoss.toFixed(2), left - 28, refY + 3);

    // Training loss curve
    ctx.strokeStyle = '#2ea043';
    ctx.lineWidth = 1.5;
    ctx.beginPath();
    for (let i = 0; i < training.lossHistory.length; i++) {
      const p = training.lossHistory[i];
      const tx = i / Math.max(1, training.lossHistory.length - 1);
      const x = left + (right - left) * tx;
      const ty = (p.loss - minL) / (maxL - minL);
      const y = bottom - (bottom - top) * ty;
      if (i === 0) ctx.moveTo(x, y);
      else ctx.lineTo(x, y);
    }
    ctx.stroke();

    // Validation loss curve
    if (training.valLossHistory.length > 1) {
      ctx.strokeStyle = '#f78166';
      ctx.lineWidth = 1.5;
      ctx.beginPath();
      for (let i = 0; i < training.valLossHistory.length; i++) {
        const p = training.valLossHistory[i];
        const tx = i / Math.max(1, training.valLossHistory.length - 1);
        const x = left + (right - left) * tx;
        const ty = (p.loss - minL) / (maxL - minL);
        const y = bottom - (bottom - top) * ty;
        if (i === 0) ctx.moveTo(x, y);
        else ctx.lineTo(x, y);
      }
      ctx.stroke();
    }

    // Legend
    ctx.fillStyle = '#2ea043';
    ctx.fillRect(right - 70, top + 2, 12, 2);
    ctx.fillStyle = '#e6edf3';
    ctx.font = '10px system-ui';
    ctx.fillText('Train', right - 54, top + 6);

    if (training.valLossHistory.length > 1) {
      ctx.fillStyle = '#f78166';
      ctx.fillRect(right - 70, top + 12, 12, 2);
      ctx.fillStyle = '#e6edf3';
      ctx.fillText('Val', right - 54, top + 16);
    }
  }

  function computeConfusion(useModel) {
    const M = [
      [0,0,0],
      [0,0,0],
      [0,0,0]
    ];
    if (!dataset.samples || dataset.samples.length === 0) return M;
    for (const s of dataset.samples) {
      let pred;
      if (useModel) {
        const { probs } = forwardSingle(s.x);
        pred = argmax(probs);
      } else {
        pred = Math.floor(Math.random() * CONFIG.NUM_OUTPUT);
      }
      M[s.y][pred] += 1;
    }
    return M;
  }

  function updateConfusionTables() {
    if (!training.randomConfusion) {
      training.randomConfusion = computeConfusion(false);
    }
    const modelConf = computeConfusion(true);
    renderConfusionTable(training.randomConfusion, 'confRandom');
    renderConfusionTable(modelConf, 'confModel');
  }

  function labelForClass(c) {
    return LABELS.output[c] || String(c);
  }

  function renderConfusionTable(M, elementId) {
    const el = document.getElementById(elementId);
    const total = M.flat().reduce((a,b) => a + b, 0) || 1;
    const correct = M[0][0] + M[1][1] + M[2][2];
    const acc = correct / total;

    let html = '<tr><th>True \\ Pred</th>';
    for (let p = 0; p < CONFIG.NUM_OUTPUT; p++) {
      html += '<th>' + p + '</th>';
    }
    html += '</tr>';
    for (let t = 0; t < CONFIG.NUM_OUTPUT; t++) {
      html += '<tr><th>' + labelForClass(t) + '</th>';
      for (let p = 0; p < CONFIG.NUM_OUTPUT; p++) {
        const cls = t === p ? 'diag' : (M[t][p] ? 'off' : '');
        html += '<td class="' + cls + '">' + M[t][p] + '</td>';
      }
      html += '</tr>';
    }
    html += '<tr><th colspan="' + (CONFIG.NUM_OUTPUT + 1) + '">Accuracy: ' +
      acc.toFixed(3) + '</th></tr>';
    el.innerHTML = html;
  }

  function updateStats() {
    const statsEl = document.getElementById('stats');
    const modelConf = computeConfusion(true);
    const total = modelConf.flat().reduce((a,b) => a + b, 0) || 1;
    const correct = modelConf[0][0] + modelConf[1][1] + modelConf[2][2];
    const acc = correct / total;
    const randomAcc = 1 / CONFIG.NUM_OUTPUT;
    const oddsRatio = acc / randomAcc;
    const lastLoss = training.lossHistory.length
      ? training.lossHistory[training.lossHistory.length - 1].loss
      : NaN;

    statsEl.innerHTML =
      'Steps: ' + training.stepCount +
      '<br>Last loss: ' + (isFinite(lastLoss) ? lastLoss.toFixed(4) : 'n/a') +
      '<br>Accuracy: ' + acc.toFixed(3) +
      ' (random baseline ' + randomAcc.toFixed(3) + ')' +
      '<br>Accuracy / random: ' + oddsRatio.toFixed(2) +
      '<br>Learning rate: ' + CONFIG.LEARNING_RATE.toFixed(3) +
      ' · Batch: ' + CONFIG.BATCH_SIZE;
  }

  function updateSampleView() {
    const infoEl = document.getElementById('sampleInfo');
    const probsEl = document.getElementById('sampleProbs');
    if (!dataset.samples || dataset.samples.length === 0) {
      infoEl.textContent = 'No data.';
      probsEl.innerHTML = '';
      return;
    }
    const idx = ui.currentSampleIndex % dataset.samples.length;
    const s = dataset.samples[idx];
    const { probs } = forwardSingle(s.x);
    const pred = argmax(probs);

    const f = s.raw.map(v => v.toFixed(2));
    infoEl.innerHTML =
      'Index: ' + idx +
      '<br>True class: ' + labelForClass(s.y) +
      '<br>Features: [ ' + f.join(', ') + ' ]';

    const lines = [];
    for (let k = 0; k < CONFIG.NUM_OUTPUT; k++) {
      const p = probs[k];
      lines.push({
        label: labelForClass(k),
        p,
        isPred: k === pred,
        isTrue: k === s.y
      });
    }
    probsEl.innerHTML = '';
    for (const row of lines) {
      const rowEl = createElement('div', 'prob-row');
      const labelEl = createElement('div', 'prob-label', (row.isTrue ? '★ ' : '') + row.label);
      const track = createElement('div', 'prob-bar-track');
      const fill = createElement('div', 'prob-bar-fill');
      fill.style.width = (row.p * 100).toFixed(1) + '%';
      if (row.isPred) {
        fill.style.background = 'linear-gradient(90deg,#58a6ff,#3fb950)';
      }
      track.appendChild(fill);
      const valEl = createElement('div', 'prob-val', row.p.toFixed(3));
      rowEl.appendChild(labelEl);
      rowEl.appendChild(track);
      rowEl.appendChild(valEl);
      probsEl.appendChild(rowEl);
    }
  }

  function updateROC() {
    if (!dataset.samples || dataset.samples.length === 0) return;

    // Collect scores and labels for all samples
    const scores = [];
    const labels = [];

    for (const sample of dataset.samples) {
      const { probs } = forwardSingle(sample.x);
      scores.push(probs);
      labels.push(sample.y);
    }

    // Send to ROC iframe
    const rocIframe = document.getElementById('rocIframe');
    if (rocIframe && rocIframe.contentWindow) {
      rocIframe.contentWindow.postMessage({
        type: 'updateROC',
        data: { scores, labels }
      }, '*');
    }
  }

  function updateAllVisuals() {
    updateConnectionStyles();
    updateNetworkVisualization();
    drawLossCurve();
    updateConfusionTables();
    updateStats();
    updateSampleView();
    updateROC();
  }

  // ----- training control -----
  function startTraining() {
    if (training.isTraining) return;
    training.isTraining = true;
    document.getElementById('btnTrainToggle').textContent = 'Stop training';
    const slow = document.getElementById('slowMode').checked;
    const delay = slow ? 400 : 60;
    const stepsPerTick = slow ? 1 : 10;
    training.timer = setInterval(() => {
      for (let i = 0; i < stepsPerTick; i++) {
        trainStep();
      }
      updateAllVisuals();
    }, delay);
  }

  function stopTraining() {
    if (!training.isTraining) return;
    training.isTraining = false;
    document.getElementById('btnTrainToggle').textContent = 'Start training';
    if (training.timer) {
      clearInterval(training.timer);
      training.timer = null;
    }
  }

  // ----- initialization -----
  function initApp() {
    dataset.samples = generateSyntheticIris();
    training.randomConfusion = computeConfusion(false);
    initNetwork();
    buildNetworkDiagram();
    drawLossCurve();
    updateConfusionTables();
    updateStats();
    setupSampleProbsSkeleton();
    updateSampleView();
    updateROC();

    document.getElementById('btnInit').addEventListener('click', () => {
      stopTraining();
      initNetwork();
      training.lossHistory = [];
      training.valLossHistory = [];
      training.stepCount = 0;
      training.randomConfusion = computeConfusion(false);
      drawLossCurve();
      updateConfusionTables();
      updateAllVisuals();
    });

    document.getElementById('btnTrainToggle').addEventListener('click', () => {
      if (training.isTraining) stopTraining();
      else startTraining();
    });

    document.getElementById('btnStep').addEventListener('click', () => {
      stopTraining();
      trainStep();
      updateAllVisuals();
    });

    document.getElementById('lrSelect').addEventListener('change', e => {
      CONFIG.LEARNING_RATE = parseFloat(e.target.value);
      updateStats();
    });

    document.getElementById('batchSelect').addEventListener('change', e => {
      CONFIG.BATCH_SIZE = parseInt(e.target.value, 10);
      updateStats();
    });

    document.getElementById('btnNextSample').addEventListener('click', () => {
      ui.currentSampleIndex = (ui.currentSampleIndex + 1) % dataset.samples.length;
      updateSampleView();
    });

    window.addEventListener('resize', () => {
      buildNetworkDiagram();
    });

    // Listen for data regeneration from iframe
    window.addEventListener('message', (event) => {
      if (event.data.type === 'dataRegenerated') {
        // Update our dataset with the new data from the iframe
        dataset.samples = event.data.data.map(d => ({
          raw: [...d.features],
          x: [...d.features], // Will be normalized below
          y: d.class
        }));

        // Re-normalize the data (same as generateSyntheticIris)
        const mean = new Array(CONFIG.NUM_INPUT).fill(0);
        const std = new Array(CONFIG.NUM_INPUT).fill(0);
        const N = dataset.samples.length;

        for (const s of dataset.samples) {
          for (let d = 0; d < CONFIG.NUM_INPUT; d++) {
            mean[d] += s.raw[d];
          }
        }
        for (let d = 0; d < CONFIG.NUM_INPUT; d++) {
          mean[d] /= N;
        }
        for (const s of dataset.samples) {
          for (let d = 0; d < CONFIG.NUM_INPUT; d++) {
            const diff = s.raw[d] - mean[d];
            std[d] += diff * diff;
          }
        }
        for (let d = 0; d < CONFIG.NUM_INPUT; d++) {
          std[d] = Math.sqrt(std[d] / N) || 1.0;
        }
        for (const s of dataset.samples) {
          const x = new Array(CONFIG.NUM_INPUT);
          for (let d = 0; d < CONFIG.NUM_INPUT; d++) {
            x[d] = (s.raw[d] - mean[d]) / std[d];
          }
          s.x = x;
        }

        // Update feature min/max
        dataset.featureMin.fill(Infinity);
        dataset.featureMax.fill(-Infinity);
        for (const s of dataset.samples) {
          for (let d = 0; d < CONFIG.NUM_INPUT; d++) {
            if (s.raw[d] < dataset.featureMin[d]) dataset.featureMin[d] = s.raw[d];
            if (s.raw[d] > dataset.featureMax[d]) dataset.featureMax[d] = s.raw[d];
          }
        }

        // Reset network and training
        initNetwork();
        training.lossHistory = [];
        training.valLossHistory = [];
        training.stepCount = 0;
        training.randomConfusion = computeConfusion(false);

        // Update all visuals
        updateAllVisuals();
      }
    });

    // Documentation modal
    const docsModal = document.getElementById('docsModal');
    const docsFab = document.getElementById('docsFab');
    const closeDocsModal = document.getElementById('closeDocsModal');

    docsFab.addEventListener('click', () => {
      docsModal.classList.add('active');
    });

    closeDocsModal.addEventListener('click', () => {
      docsModal.classList.remove('active');
    });

    docsModal.addEventListener('click', (e) => {
      if (e.target === docsModal) {
        docsModal.classList.remove('active');
      }
    });
  }

  function setupSampleProbsSkeleton() {
    const container = document.getElementById('sampleProbs');
    container.innerHTML = '';
    for (let k = 0; k < CONFIG.NUM_OUTPUT; k++) {
      const rowEl = createElement('div', 'prob-row');
      const labelEl = createElement('div', 'prob-label', labelForClass(k));
      const track = createElement('div', 'prob-bar-track');
      const fill = createElement('div', 'prob-bar-fill');
      track.appendChild(fill);
      const valEl = createElement('div', 'prob-val', '0.000');
      rowEl.appendChild(labelEl);
      rowEl.appendChild(track);
      rowEl.appendChild(valEl);
      container.appendChild(rowEl);
    }
  }

  document.addEventListener('DOMContentLoaded', initApp);
</script>
<script src="layout.js"></script>
</body>
</html>
