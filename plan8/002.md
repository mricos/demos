# Toward a Semantic Shell: Redefining the CLI with Present Working Context (PWC)

## Abstract

This paper proposes a reimagining of the traditional command-line interface (CLI) by extending the concept of the Present Working Directory (PWD) into a Present Working Context (PWC). This abstraction retains familiar affordances such as `cd`, `ls`, and `rm`, but generalizes them to operate over semantic entities like symbols, tags, and queries. We explore the data model, interface implications, and potential applications of this paradigm in agentic software development, particularly in conjunction with LLM-based tooling. A key innovation is the introduction of a "Tensor Cursor" model, enabling multidimensional symbolic traversal of a codebase.

## 1. Introduction

The hierarchical filesystem and CLI have endured as foundational abstractions for human-computer interaction. However, they were designed for physical disk layouts and human navigability, not semantic reasoning or AI-driven workflows. As machine agents become first-class participants in software development, a new abstraction is required—one that supports symbolic addressing, tag-based organization, and graph traversal.

## 2. Motivation

While the tree structure of the Unix filesystem enables intuitive manipulation (`cd`, `ls`, etc.), it lacks semantic expressiveness. Tag-based systems (e.g., Gmail labels) and content-addressable graphs (e.g., Git) offer more flexible data models, but often sacrifice usability. Our goal is to preserve the CLI interface while generalizing its semantics to operate over graph-based, symbolic data models. In doing so, we aim to unify human affordance with machine-contextual operations, especially those suited to language models and symbolic agents.

## 3. Conceptual Framework

### 3.1 Present Working Directory (PWD)

* Represents a hierarchical path on disk.
* Primary unit of navigation and context.
* Scalar, singular, and exclusive.

### 3.2 Present Working Context (PWC)

* Represents a symbolic, semantic, or graph-derived context.
* Examples: symbol `:add`, tag `@untested`, query `?type=Function&file=math.js`
* Can represent sets of objects and dynamic intersections.
* Supports symbolic selection, multi-entity scoping, and dimensionally multiplexed cursors.

## 4. Command Mapping

| Command | PWD Behavior             | PWC Behavior                                       |
| ------- | ------------------------ | -------------------------------------------------- |
| `cd`    | Change directory         | Change semantic context (symbol, tag, query)       |
| `ls`    | List directory contents  | List members of current context (symbols, links)   |
| `cat`   | Output file contents     | Output content of current node                     |
| `mv`    | Move/rename file         | Rebind symbol, rename tag, remap association       |
| `rm`    | Delete file              | Unbind symbol, remove tag                          |
| `find`  | Recursively search files | Graph query by type, usage, relationship           |
| `test`  | External toolchain       | Run tests bound to current symbol or scope         |
| `stat`  | File metadata            | Semantic metadata (hashes, coverage, ownership)    |
| `graph` | —                        | Explore local graph neighborhood                   |
| `touch` | Create empty file        | Create new symbolic node (function, tag, scaffold) |

## 5. Internal Data Structures

* **Abstract Syntax Tree (AST)**: Parsed representation of code structure per file. Provides the ground truth for identifying and indexing all symbols, their types, scopes, and relationships. Enables semantic navigation, graph extraction, and change tracking at the symbol level.
* **Graph**: Nodes (files, functions, symbols), Edges (calls, defines, tests). Enables graph-based navigation and neighborhood queries.
* **Symbol Table**: Mapping of `symbol → location, hash, doc`
* **Tag Index**: Mapping of `@tag → nodes`
* **Query Engine**: Supports `?field=value` filtering over metadata

## 6. CLI Behavior

### 6.1 Working Context Navigation

```bash
cd :parseHeader         # Navigate to a function by symbol
cd @critical            # Work inside all tagged critical paths (multi-entity context)
cd ?type=Function&test=missing
```

> **Note:** A context like `cd @critical` selects a set of symbols or entities. All subsequent operations (e.g., `ls`, `test`, `graph`) operate over that set. This enables multidimensional cursor behavior — a "Tensor Cursor" — addressing sets of entities across multiple axes (e.g., tag, type, dependency).

### 6.2 Contextual Operations

```bash
ls                      # List contents of current context
cat                     # View symbol definition
rm :tempUtil            # Unbind a symbol
mv :foo :bar            # Rename symbol
graph                   # View semantic neighbors (e.g., callees, tests)
touch :newFunction      # Create scaffold for a new function in current context
```

## 7. Cursor Model: Tensor Cursor Semantics

The Present Working Context can represent a single node (like a file or symbol), a set of nodes (e.g., all tagged `@critical`), or a dynamically defined selection (e.g., `?type=Test&calls=:parseHeader`).

We call this a **Tensor Cursor**: a generalization of the PWD to a higher-dimensional selection context. Each axis of the tensor corresponds to a selection domain:

* **File** (e.g., `math.js`, `lexer.js`, `router.js`)
* **Function** (e.g., `add`, `parse`, `validate`)
* **Test** (e.g., `test_add`, `test_parse`, `test_validate`)

A Tensor Cursor enables operations across the Cartesian product or aligned diagonals of these dimensions. It is conceptually influenced by category theory, where tensoring refers to bifunctorial composition in a monoidal category. The shell becomes a compositional engine over codebase structure.

### 7.1 Physical Tensor Cursor

Consider a 3×3×3 cube:

* 3 source files
* Each with 3 functions
* Each function with 3 tests

We can select:

```bash
cd file[i] & func[i] & test[i]          # Diagonal: aligned triplets
cd file[i] & func[j]                    # Cross-product of files and functions
cd func[i] & test[i]                    # Aligned function-test pairs
```

| CLI Expression                   | Description                           |
| -------------------------------- | ------------------------------------- |
| `cd file[i]`                     | Slice along file axis                 |
| `cd func[i]`                     | Slice along function axis             |
| `cd file[i] & func[j]`           | 2D grid across files and functions    |
| `cd file[i] & func[i] & test[i]` | Diagonal traversal through all layers |

### 7.2 Logical Cursor Examples

| Command                     | Resulting Context | Description                              |
| --------------------------- | ----------------- | ---------------------------------------- |
| `cd :parseHeader`           | single node       | single function symbol                   |
| `cd @critical`              | set of nodes      | all symbols tagged `@critical`           |
| `cd ?type=Test`             | set of nodes      | all test functions                       |
| `cd @todo & ?type=Function` | set of nodes      | all functions tagged `@todo`             |
| `cd ?calls=:parseHeader`    | set of nodes      | all call sites referencing `parseHeader` |

Operations apply to this working set according to their semantics:

* `ls`: lists members of the current set
* `test`: runs all tests reachable from current set
* `graph`: shows local subgraph (call edges, test links, etc.)
* `rm`, `tag`, etc.: apply per node or with optional broadcast semantics

This model enables the shell to scale up from path-bound interaction to symbolic and semantic interaction across a rich and interlinked codebase.

## 8. Applications

* **LLM Agent Integration**: Inject and retrieve context semantically
* **Version Tracking**: Graph deltas and symbol history over time
* **Semantic Testing**: Run tests scoped to symbol or tag
* **IDE Integration**: Symbolic shell backed by static analysis tools
* **Matrix Traversal**: Iteratively explore file-function-test planes

## 9. Prior Work

| System                                                            | Related Concept         | Limitation                             |
| ----------------------------------------------------------------- | ----------------------- | -------------------------------------- |
| [`git`](https://git-scm.com/book/en/v2/Git-Internals-Git-Objects) | DAG of commits and refs | File-level only; not semantic entities |
| [BeOS BFS](https://en.wikipedia.org/wiki/Be_File_System)          | Queryable metadata FS   | No symbolic or functional addressing   |
| [RDF/SPARQL](https://www.w3.org/TR/rdf11-concepts/)               | Semantic queries        | No usable CLI abstraction              |
| [SWE-agent](https://arxiv.org/abs/2307.07924)                     | Symbol-based navigation | Internal only, not surfaced as a shell |

## 10. Future Work

* Formal CLI spec (command grammar)
* Virtual filesystem mounts of semantic trees
* LLM-aware context managers
* User-space implementation over Git or SQLite
* Cursor compression and broadcasting patterns

## 11. Conclusion

The PWC abstraction offers a powerful middle ground between hierarchical structure and semantic flexibility. By retaining familiar CLI interfaces while extending their scope to symbolic, graph-based data, we can support human and machine agents alike in navigating, manipulating, and reasoning about software systems. The Tensor Cursor offers a powerful new lens on context: not merely where you are, but what set of interrelated meanings you are standing in.

## Appendix: PWC Grammar

* Symbols: `:symbol`
* Tags: `@tag`
* Queries: `?field=value&...`
* Paths: `/path/to/file` (retained for compatibility)
* UUIDs: `uuid:xxxx` (for content-addressed nodes)
* Tensor notation: `dim[i]` for indexed traversal, `&` for conjunction

## References

* [Git Object Model](https://git-scm.com/book/en/v2/Git-Internals-Git-Objects)
* [RDF 1.1 Concepts and Abstract Syntax](https://www.w3.org/TR/rdf11-concepts/)
* [SQLite virtual tables](https://sqlite.org/vtab.html)
* [SWE-agent architecture](https://arxiv.org/abs/2307.07924)
* [BeOS File System Design](https://en.wikipedia.org/wiki/Be_File_System)
