Here is the final document, revised with the `auth` service and the 4-player Pong example.

-----

## Plan8: A Detailed Sketch of Plan 9 in JavaScript

### Abstract

Plan8 is a conceptual framework and proof-of-concept that reimagines the core principles of Plan 9 from Bell Labs using modern web technologies. Implemented with **Bash**, **Node.js**, and **browser JavaScript**, it translates Plan 9's philosophy‚Äî"everything is a file," per-process namespaces, and message-passing via plumbing‚Äîinto a tangible, inspectable system. Plan8 is not an OS; it's a language for system design that makes the compositional power of Plan 9 accessible in any browser, demonstrating its relevance for building complex, decoupled applications.

-----

### 1\. The Plan 9 Philosophy üìú

Plan 9's design is guided by a few powerful aphorisms that favor simplicity and composition over complex, monolithic policies. This philosophy is the foundation of Plan8.

| Aphorism | Interpretation |
| :--- | :--- |
| **"Everything is a file."** | All resources‚Äîhardware, services, processes‚Äîare represented as files in a hierarchical namespace. |
| **"A name is a handle on a computation."** | What you can name, you can operate on. Namespaces are the primary tool for controlling the environment. |
| **"No superuser."** | Authority is granular and contextual, derived from access to files, not from a global, all-powerful user. |
| **"Separate mechanism from policy."** | The system should provide fundamental tools (mechanisms), leaving it to the user or application to decide how they are used (policy). |

-----

### 2\. Core Concepts

Plan8 adapts Plan 9's core components to a web-native architecture, translating kernel-level concepts into JavaScript objects and services.

| Concept | Plan 9 Implementation | Plan8 Implementation |
| :--- | :--- | :--- |
| **File-as-Interface** | All resources are files. | Structured JS objects with `async read()`/`write()` methods. |
| **Namespace** | Per-process, built via `bind`. | Per-browser-tab, via a JS `Map` (`plan8.ns`). |
| **Service Registry** | `/srv`, `srvfs`, 9P protocol. | A global JS `Map` (`plan8.srv`). |
| **Shell** | `rc`, `/dev/cons` | `plan8.rc()` + DOM terminal. |
| **Plumbing** | `plumber(1)` daemon. | `plan8.plumb(src, dst)`. |
| **Authentication** | `factotum` agent. | The **`auth`** service. |
| **Logging** | `/dev/log` device. | A write-only **Log** service mounted at `/dev/log`. |

-----

### 3\. Plan8 Architecture: Files, Services, and Namespaces

The entire system is built from three interacting components that together create isolated, dynamic environments for each user session.

#### The Service Registry (`plan8.srv`)

`plan8.srv` is a global `Map` that acts as the system's "phonebook." When a new service starts (like a game server or an authentication agent), it registers its file-based interfaces here under a well-known path.

  * **Example**: A new shell service registers its I/O files: `plan8.srv.set('/srv/wshell/0.in', shellInputFileObject)`.

#### The Namespace (`plan8.ns`)

Each browser tab or user session gets its own private namespace, an empty `Map` called `plan8.ns`. This namespace is the session's entire view of the world. It's populated by **mounting** files from the global service registry into a private, local path.

  * **Mounting**: The act of creating a reference in the local namespace to a file in the service registry. This is the primary mechanism for granting access to resources.
  * **Example**: A session mounts the shell's input file: `plan8.ns.set('/mnt/shell', plan8.srv.get('/srv/wshell/0.in'))`. Now, within this session, writing to `/mnt/shell` communicates with the shell service. No other session has this path.

#### The Structured File Interface

In Plan8, a "file" is not a raw byte stream but a structured JavaScript object with a defined interface. This abstraction allows any resource‚Äîa WebSocket, a user input field, a game state‚Äîto be treated uniformly.

The core interface for a Plan8 file includes `async` methods, which allows JavaScript's single-threaded event loop to perfectly emulate Plan 9's efficient blocking I/O.

```javascript
// A conceptual Plan8 File interface
class Plan8File {
  /**
   * Asynchronously reads data from the resource.
   * The returned Promise resolves when data is available.
   * This emulates a blocking read() call without freezing the browser.
   */
  async read() { /* ... returns a Promise that resolves with data ... */ }

  /**
   * Asynchronously writes data to the resource.
   */
  async write(data) { /* ... returns a Promise that resolves on completion ... */ }

  /**
   * Closes the connection to the resource.
   */
  async close() { /* ... */ }
}
```

-----

### 4\. Core Services

Services in Plan8 are just programs that expose their functionality via file objects placed in the `/srv` registry.

#### Authentication: The `auth` Service üîë

The **`auth`** service is an authentication agent that manages keys and secrets. It exposes its interface via files, typically mounted at `/mnt/auth`.

  * `/mnt/auth/ctl`: A write-only file. A user adds a key by writing a command to it, e.g., `plan8.rc("echo 'add p9sk1 game_server_id secret123' > /mnt/auth/ctl")`.
  * `/mnt/auth/key`: A read-only file. An application retrieves a key by reading from it, which can trigger a challenge-response flow managed by the `auth` service.

#### Logging: The `/dev/log` Service ‚úçÔ∏è

Following Plan 9 tradition, logging is not a special function but another file-based service. A central **Log Service** registers a single, write-only file at `/srv/log`.

  * **Mounting**: Each application or session mounts this service into its private namespace at `/dev/log`.
  * **Usage**: To log a message, a program simply opens and writes to its local `/dev/log` file. The Log Service receives all writes and can route them to the console, a database, or another persistent store.
  * **Example**: `plan8.rc("echo 'User session started' > /dev/log")`.

-----

### 5\. Example: 4-Player, 2-Ball Pong üïπÔ∏è

This example shows how all the pieces come together to create a complex, multi-user application.

#### Server Architecture: State as Files

The Pong server is a process that exposes all game components as individual files in the service registry. It is not aware of any specific clients, only of the files it manages.

1.  **Service Registration**: On startup, the server creates and registers all its files under `/srv/pong/`.
      * **Inputs**: Write-only files for each player: `/srv/pong/player1.in`, `/srv/pong/player2.in`, etc.
      * **State Broadcast**: A single read-only "broadcast" file, `/srv/pong/gamestate`, that will stream updates for all paddles, balls, and the score.
2.  **Game Loop**: The server runs its main loop:
      * Read any new data from the player input files (`player1.in`, etc.) to update paddle positions.
      * Calculate the new positions of the two balls and check for collisions or scores.
      * Log game events: `logFile.write('Player 2 scored. Score: 3-5')`.
      * Assemble a JSON object of the entire game state (`{paddles: [...], balls: [...], score: ...}`).
      * Write this state object as a single message to the `/srv/pong/gamestate` broadcast file. All listening clients will receive this update.

#### Client Architecture: Events via Blocking `read`

Each of the four players runs a client application in their own window.

1.  **Authentication and Mounting**: To join, the client first authenticates with the `auth` service to get a token. Then it mounts the necessary files into its private namespace.
      * `plan8.mount('/mnt/game/input', '/srv/pong/player1.in')` // Mounts the *write-only* input file for this player.
      * `plan8.mount('/mnt/game/state', '/srv/pong/gamestate')` // Mounts the *read-only* broadcast file.
2.  **Input Handling**: The client captures keyboard events and writes them to its input file: `input_file.write('up')`.
3.  **Render Loop**: The client's render loop is simple and efficient, driven by server-pushed events.

<!-- end list -->

```javascript
// Get a handle to the mounted game state file
const gameStateFile = plan8.fs.open('/mnt/game/state');

// This loop functions as an event handler
while (true) {
  // 'await' pauses the function. It sleeps efficiently, consuming no CPU,
  // until the server writes the next game state.
  const newState = await gameStateFile.read(); 

  if (!newState) break; // Server closed the connection

  // Once data arrives, the code wakes up and renders the new state.
  const gameState = JSON.parse(newState);
  drawPaddles(gameState.paddles);
  drawBalls(gameState.balls);
  updateScore(gameState.score);
}
```

This architecture is completely decoupled. The server only knows about its files, and the clients only know about the files in their private namespace. Adding a spectator is as simple as creating a client that only mounts and reads from `/srv/pong/gamestate`.

-----

### 6\. Summary Tables

#### Component Crosswalk

| System Element | Plan 9 Implementation | Plan8 Implementation |
| :--- | :--- | :--- |
| **File Interface** | Everything is a file. | Structured objects with `async` methods. |
| **Shell** | `rc` | `plan8.rc(cmd)` |
| **Namespace** | Process-specific, kernel-managed. | Tab/session-specific via `plan8.ns` `Map`. |
| **Window Manager** | `rio`, `/dev/cons` | `plan8.newwin(id)` (DOM terminal). |
| **IPC** | Pipes, 9P messages. | `async` file I/O, WebSockets, plumbing. |
| **Logging** | `/dev/log` | Mounted file service. |

#### Service Feature Table

| Plan9 Service | Plan8 Realization | Extension Path |
| :--- | :--- | :--- |
| **factotum** | **`auth`** Service | Add more auth protocols (OAuth, etc.). |
| **srvfs** | `plan8.srv` `Map` | Back with a distributed key-value store. |
| **logfs** | **Log** Service | Add log levels, filtering, remote syslog. |

-----

### 7\. Concluding Remarks

Plan8 provides a technical, extensible demonstration of Plan 9‚Äôs radical design in modern environments. It achieves:

  * **File-based Composition**: All system actions and services are exposed as files with a uniform, asynchronous interface.
  * **Namespace Isolation**: Each session is a separate world, modifiable by mounting and binding.
  * **Efficient Event Handling**: Emulates Plan 9's blocking I/O with `async/await`, enabling simple code to handle server-pushed events efficiently.
  * **Composable Services**: Core functionalities like authentication and logging are not built-in features but are simply services that can be mounted and used like any other.

Plan8 is not an operating system, but a practical, reproducible grammar of interaction‚Äîdemonstrating that Plan 9‚Äôs insights are not only viable but highly productive in any programmable environment.
