<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Diffusion Models - State Space</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      font-family: system-ui, sans-serif;
      background: #111827;
      color: #fff;
      min-height: 100vh;
      padding: 24px;
    }
    h1 { text-align: center; font-size: 1.875rem; margin-bottom: 8px; }
    .subtitle { text-align: center; color: #9ca3af; margin-bottom: 24px; }
    .container { max-width: 900px; margin: 0 auto; }
    .tabs { display: flex; justify-content: center; gap: 8px; margin-bottom: 24px; flex-wrap: wrap; }
    .tab-btn {
      padding: 10px 16px; border: none; border-radius: 8px;
      font-weight: 500; cursor: pointer; transition: all 0.2s;
      background: #374151; color: #d1d5db;
    }
    .tab-btn:hover { background: #4b5563; }
    .tab-btn.active { background: #2563eb; color: #fff; }
    .card { background: #1f2937; border-radius: 12px; padding: 24px; margin-bottom: 16px; }
    .card h2 { font-size: 1.25rem; margin-bottom: 16px; }
    .equation {
      background: #111827; border-radius: 8px; padding: 16px;
      font-family: monospace; text-align: center; font-size: 1.125rem; margin-bottom: 16px;
    }
    .blue { color: #60a5fa; } .yellow { color: #fbbf24; }
    .green { color: #4ade80; } .red { color: #f87171; } .purple { color: #a78bfa; }
    .legend { display: grid; grid-template-columns: 1fr 1fr; gap: 12px; margin-bottom: 16px; }
    .legend-item { padding: 12px; border-radius: 8px; font-size: 0.875rem; }
    .legend-item.blue-bg { background: rgba(37, 99, 235, 0.2); }
    .legend-item.yellow-bg { background: rgba(234, 179, 8, 0.2); }
    .legend-item.green-bg { background: rgba(34, 197, 94, 0.2); }
    .legend-item.red-bg { background: rgba(239, 68, 68, 0.2); }
    canvas { width: 100%; border-radius: 8px; margin-bottom: 16px; background: #1a1a2e; }
    .slider-row { display: flex; align-items: center; gap: 16px; }
    .slider-row input { flex: 1; }
    .info { text-align: center; color: #9ca3af; margin-top: 8px; }
    .math-box { font-family: monospace; font-size: 0.875rem; padding: 12px; border-radius: 8px; margin-bottom: 12px; }
    .math-box.blue-bg { background: rgba(37, 99, 235, 0.15); }
    .math-box.green-bg { background: rgba(34, 197, 94, 0.15); }
    .math-box.purple-bg { background: rgba(147, 51, 234, 0.15); }
    .math-box .label { font-weight: 600; margin-bottom: 4px; }
    .math-box .hint { color: #6b7280; font-size: 0.75rem; margin-top: 4px; }
    .step {
      display: flex; align-items: flex-start; gap: 16px;
      background: rgba(17, 24, 39, 0.5); padding: 16px; border-radius: 8px; margin-bottom: 12px;
    }
    .step-num {
      width: 32px; height: 32px; border-radius: 50%;
      display: flex; align-items: center; justify-content: center;
      font-weight: 700; flex-shrink: 0;
    }
    .step-num.blue { background: #2563eb; }
    .step-num.green { background: #16a34a; }
    .step-num.purple { background: #9333ea; }
    .step-num.red { background: #dc2626; }
    .step p:first-child { font-weight: 600; }
    .step p:last-child { color: #9ca3af; font-size: 0.875rem; }
    .insight {
      background: rgba(234, 179, 8, 0.15); border: 1px solid #ca8a04;
      border-radius: 12px; padding: 24px;
    }
    .insight h3 { color: #fbbf24; margin-bottom: 8px; }
    .gen-btn {
      width: 100%; padding: 12px; border: none; border-radius: 8px;
      font-weight: 700; font-size: 1rem; cursor: pointer;
      background: #2563eb; color: #fff; transition: all 0.2s;
    }
    .gen-btn:hover:not(:disabled) { background: #3b82f6; }
    .gen-btn:disabled { background: #4b5563; cursor: not-allowed; }
    .grid-2 { display: grid; grid-template-columns: 1fr 1fr; gap: 16px; }
    @media (max-width: 640px) { .grid-2, .legend { grid-template-columns: 1fr; } }
    .chart { height: 180px; background: #111827; border-radius: 8px; padding: 16px; }
    .footer { text-align: center; color: #6b7280; font-size: 0.875rem; margin-top: 24px; }
  </style>
</head>
<body>
  <h1>Diffusion Models: State Space Formulation</h1>
  <p class="subtitle">Understanding diffusion through linear transformations</p>
  <div class="container" id="app"></div>

<script>
// ============================================================================
// Respond.js - Minimal Reactive UI
// ============================================================================
const Respond = (() => {
  let currentObserver = null;

  function responsive(initial) {
    const subs = new Map();
    return new Proxy(initial, {
      get(t, k) {
        if (currentObserver) {
          if (!subs.has(k)) subs.set(k, new Set());
          subs.get(k).add(currentObserver);
        }
        return t[k];
      },
      set(t, k, v) {
        if (t[k] === v) return true;
        t[k] = v;
        const s = subs.get(k);
        if (s) s.forEach(fn => fn());
        return true;
      }
    });
  }

  function observe(fn) {
    const run = () => { currentObserver = run; fn(); currentObserver = null; };
    run();
    return run;
  }

  function computed(fn) {
    const box = responsive({ value: undefined });
    observe(() => { box.value = fn(); });
    return box;
  }

  function bind(el, bindings) {
    for (const [key, val] of Object.entries(bindings)) {
      const f = typeof val === 'function' ? val : () => val;
      if (key === 'text') observe(() => { el.textContent = f(); });
      else if (key === 'html') observe(() => { el.innerHTML = f(); });
      else if (key === 'class') observe(() => { el.className = f(); });
      else if (key === 'style') observe(() => {
        const s = f();
        if (!s) el.removeAttribute('style');
        else if (typeof s === 'string') el.style.cssText = s;
        else for (const [k, v] of Object.entries(s)) el.style[k] = v;
      });
      else if (key === 'visible') observe(() => { el.style.display = f() ? '' : 'none'; });
      else if (key === 'value') observe(() => { const v = f(); if (el.value !== v) el.value = v; });
      else if (key.startsWith('on')) el.addEventListener(key.slice(2).toLowerCase(), val);
      else observe(() => { el[key] = f(); });
    }
    return el;
  }

  function el(tag, bindings = {}, children = []) {
    const node = document.createElement(tag);
    bind(node, bindings);
    children.forEach(c => node.append(c instanceof Node ? c : document.createTextNode(c)));
    return node;
  }

  function mount(root, container) {
    const target = typeof container === 'string' ? document.querySelector(container) : container;
    target.appendChild(typeof root === 'function' ? root() : root);
  }

  return { responsive, observe, computed, bind, el, mount };
})();

// ============================================================================
// Trace - Redux-like State Management
// ============================================================================
const Trace = (() => {
  function createStore(reducer, initialState) {
    const state = Respond.responsive({ ...initialState });
    const history = [];
    let historyIndex = -1;

    function dispatch(action) {
      // Save current state to history
      history.splice(historyIndex + 1);
      history.push(JSON.parse(JSON.stringify(state)));
      historyIndex++;

      // Apply reducer
      const changes = reducer(state, action);
      if (changes) Object.assign(state, changes);

      return state;
    }

    function undo() {
      if (historyIndex > 0) {
        historyIndex--;
        Object.assign(state, history[historyIndex]);
      }
    }

    function redo() {
      if (historyIndex < history.length - 1) {
        historyIndex++;
        Object.assign(state, history[historyIndex]);
      }
    }

    // Initialize history
    history.push(JSON.parse(JSON.stringify(state)));
    historyIndex = 0;

    return { state, dispatch, undo, redo, getHistory: () => history };
  }

  return { createStore };
})();

Object.assign(window, Respond);
</script>

<script>
// ============================================================================
// DIFFUSION MODEL CONSTANTS & HELPERS
// ============================================================================
const T = 100;

const getAlphaBar = t => {
  const s = 0.008;
  const f_t = Math.cos(((t / T + s) / (1 + s)) * Math.PI / 2) ** 2;
  const f_0 = Math.cos((s / (1 + s)) * Math.PI / 2) ** 2;
  return f_t / f_0;
};

const sqrtAB = t => Math.sqrt(getAlphaBar(t));
const sqrtOMab = t => Math.sqrt(1 - getAlphaBar(t));
const seededRandom = seed => { const x = Math.sin(seed) * 10000; return x - Math.floor(x); };

// Generate original points (two clusters)
const originalPoints = Array.from({ length: 200 }, (_, i) => {
  const cluster = i % 2;
  const cx = cluster === 0 ? 0.3 : 0.7;
  const cy = cluster === 0 ? 0.3 : 0.7;
  return {
    x: cx + (seededRandom(i * 4 + 1) - 0.5) * 0.15,
    y: cy + (seededRandom(i * 4 + 2) - 0.5) * 0.15
  };
});

// ============================================================================
// STORE SETUP (Redux-like)
// ============================================================================
const reducer = (state, action) => {
  switch (action.type) {
    case 'SET_TAB':
      return { tab: action.payload };
    case 'SET_TIMESTEP':
      return { timestep: action.payload };
    case 'START_GENERATION':
      return { isGenerating: true, genStep: 0 };
    case 'GENERATION_TICK':
      return { genStep: Math.min(state.genStep + 2, T) };
    case 'STOP_GENERATION':
      return { isGenerating: false };
    default:
      return null;
  }
};

const store = Trace.createStore(reducer, {
  tab: 'forward',
  timestep: 50,
  genStep: 0,
  isGenerating: false
});

const { state, dispatch } = store;

// Actions
const actions = {
  setTab: tab => dispatch({ type: 'SET_TAB', payload: tab }),
  setTimestep: t => dispatch({ type: 'SET_TIMESTEP', payload: t }),
  startGeneration: () => dispatch({ type: 'START_GENERATION' }),
  tick: () => dispatch({ type: 'GENERATION_TICK' }),
  stopGeneration: () => dispatch({ type: 'STOP_GENERATION' })
};

// ============================================================================
// CANVAS RENDERERS
// ============================================================================
function drawForward(canvas) {
  const ctx = canvas.getContext('2d');
  const w = canvas.width, h = canvas.height;

  observe(() => {
    const t = state.timestep;
    ctx.fillStyle = '#1a1a2e';
    ctx.fillRect(0, 0, w, h);

    const sab = sqrtAB(t), somab = sqrtOMab(t);

    ctx.globalAlpha = 0.6;
    originalPoints.forEach((p, i) => {
      const u1 = seededRandom(i * 2 + 1), u2 = seededRandom(i * 2 + 2);
      const nx = Math.sqrt(-2 * Math.log(u1)) * Math.cos(2 * Math.PI * u2) * 0.15;
      const ny = Math.sqrt(-2 * Math.log(u1)) * Math.sin(2 * Math.PI * u2) * 0.15;

      const x_t = sab * p.x + somab * nx + 0.5 * (1 - sab);
      const y_t = sab * p.y + somab * ny + 0.5 * (1 - sab);

      ctx.fillStyle = 'rgba(74,158,255,0.2)';
      ctx.beginPath(); ctx.arc(p.x * w, p.y * h, 4, 0, Math.PI * 2); ctx.fill();

      ctx.fillStyle = '#ff6b6b';
      ctx.beginPath(); ctx.arc(x_t * w, y_t * h, 5, 0, Math.PI * 2); ctx.fill();
    });

    ctx.globalAlpha = 1;
    ctx.fillStyle = '#fff';
    ctx.font = 'bold 14px monospace';
    ctx.fillText(`t = ${t}`, 10, 25);
    ctx.fillText(`âˆšá¾±â‚œ = ${sab.toFixed(3)}`, 10, 45);
    ctx.fillText(`âˆš(1-á¾±â‚œ) = ${somab.toFixed(3)}`, 10, 65);
  });
}

function drawGeneration(canvas) {
  const ctx = canvas.getContext('2d');
  const w = canvas.width, h = canvas.height;

  observe(() => {
    const step = state.genStep;
    ctx.fillStyle = '#1a1a2e';
    ctx.fillRect(0, 0, w, h);

    const progress = 1 - Math.pow(1 - step / T, 2);

    ctx.globalAlpha = 0.7;
    for (let i = 0; i < 200; i++) {
      const cluster = i < 100 ? 0 : 1;
      const tx = cluster === 0 ? 0.3 : 0.7;
      const ty = cluster === 0 ? 0.3 : 0.7;

      const u1 = seededRandom(i * 2 + 1), u2 = seededRandom(i * 2 + 2);
      const nx = 0.5 + Math.sqrt(-2 * Math.log(u1)) * Math.cos(2 * Math.PI * u2) * 0.2;
      const ny = 0.5 + Math.sqrt(-2 * Math.log(u1)) * Math.sin(2 * Math.PI * u2) * 0.2;

      const cn = seededRandom(i * 3) * 0.15 - 0.075;
      const x = nx * (1 - progress) + (tx + cn) * progress;
      const y = ny * (1 - progress) + (ty + cn) * progress;

      ctx.fillStyle = `hsl(${200 + step * 1.5}, 70%, 60%)`;
      ctx.beginPath(); ctx.arc(x * w, y * h, 5, 0, Math.PI * 2); ctx.fill();
    }

    ctx.globalAlpha = 1;
    ctx.fillStyle = '#fff';
    ctx.font = 'bold 14px monospace';
    ctx.fillText(`Denoising step: ${step}/${T}`, 10, 25);
    ctx.fillText(`t: ${T - step} â†’ ${Math.max(0, T - step - 1)}`, 10, 45);
  });
}

function drawSchedule(svg) {
  let path1 = 'M 40 30', path2 = 'M 40 130';
  for (let i = 0; i <= 100; i++) {
    const x = 40 + (i / 100) * 340;
    path1 += ` L ${x} ${130 - sqrtAB(i) * 100}`;
    path2 += ` L ${x} ${130 - sqrtOMab(i) * 100}`;
  }
  svg.innerHTML = `
    <line x1="40" y1="130" x2="380" y2="130" stroke="#444"/>
    <line x1="40" y1="20" x2="40" y2="130" stroke="#444"/>
    <path d="${path1}" fill="none" stroke="#4ade80" stroke-width="2"/>
    <path d="${path2}" fill="none" stroke="#f87171" stroke-width="2"/>
    <text x="200" y="145" fill="#888" font-size="10" text-anchor="middle">timestep t</text>
    <text x="340" y="50" fill="#4ade80" font-size="10">âˆšá¾±â‚œ (signal)</text>
    <text x="340" y="115" fill="#f87171" font-size="10">âˆš(1-á¾±â‚œ) (noise)</text>
  `;
}

// ============================================================================
// GENERATION ANIMATION (side effect)
// ============================================================================
let genInterval = null;

observe(() => {
  if (state.isGenerating && !genInterval) {
    genInterval = setInterval(() => {
      if (state.genStep >= T) {
        clearInterval(genInterval);
        genInterval = null;
        actions.stopGeneration();
      } else {
        actions.tick();
      }
    }, 50);
  }
});

// ============================================================================
// UI COMPONENTS
// ============================================================================
const TabButton = (name, label) =>
  bind(el('button', {}, [label]), {
    class: () => 'tab-btn' + (state.tab === name ? ' active' : ''),
    onClick: () => actions.setTab(name)
  });

const ForwardTab = () => {
  const canvas = el('canvas', { width: 500, height: 300 });
  const slider = el('input', { type: 'range', min: 0, max: 100 });
  bind(slider, {
    value: () => state.timestep,
    onInput: e => actions.setTimestep(+e.target.value)
  });

  const info = el('p', { class: 'info' });
  bind(info, {
    text: () => {
      const t = state.timestep;
      return `At t=${t}: Signal is ${(sqrtAB(t) * 100).toFixed(1)}% preserved, Noise is ${(sqrtOMab(t) * 100).toFixed(1)}% magnitude`;
    }
  });

  drawForward(canvas);

  return el('div', {}, [
    el('div', { class: 'card' }, [
      el('h2', {}, ['The Forward Process as a Linear Transformation']),
      el('div', {
        class: 'equation',
        html: `<span class="blue">x</span><sub class="yellow">t</sub> = 
               <span class="green">âˆšá¾±</span><sub class="yellow">t</sub> Â· 
               <span class="blue">x</span><sub>0</sub> + 
               <span class="red">âˆš(1-á¾±</span><sub class="yellow">t</sub><span class="red">)</span> Â· 
               <span class="red">Îµ</span>`
      }),
      el('div', { class: 'legend' }, [
        el('div', { class: 'legend-item blue-bg', html: '<span class="blue"><b>xâ‚€</b></span>: Original clean data' }),
        el('div', { class: 'legend-item yellow-bg', html: '<span class="yellow"><b>t</b></span>: Timestep (0 to T)' }),
        el('div', { class: 'legend-item green-bg', html: '<span class="green"><b>âˆšá¾±â‚œ</b></span>: Signal scaling (decreases)' }),
        el('div', { class: 'legend-item red-bg', html: '<span class="red"><b>Îµ</b></span>: Gaussian noise ~ N(0, I)' })
      ]),
      el('p', { style: 'color: #9ca3af' }, [
        el('b', {}, ['Key insight: ']),
        'At any timestep t, we can jump directly from xâ‚€ to xâ‚œ using this linear equation.'
      ])
    ]),
    el('div', { class: 'card' }, [
      el('h3', { style: 'margin-bottom: 16px' }, ['Interactive Visualization']),
      el('p', { class: 'info', style: 'margin-bottom: 16px' }, ['Blue (faded) = original, Red = noised']),
      canvas,
      el('div', { class: 'slider-row' }, [
        el('span', {}, ['t = 0']), slider, el('span', {}, ['t = 100'])
      ]),
      info
    ])
  ]);
};

const MathTab = () => {
  const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
  svg.setAttribute('viewBox', '0 0 400 150');
  svg.style.cssText = 'width:100%;height:100%';
  drawSchedule(svg);

  return el('div', {}, [
    el('div', { class: 'card' }, [
      el('h2', {}, ['State Space Representation']),
      el('div', { class: 'math-box blue-bg' }, [
        el('p', { class: 'label blue' }, ['State Equation (Forward):']),
        el('p', {}, ['xâ‚œ = Aâ‚œ xâ‚€ + Bâ‚œ Îµ']),
        el('p', { class: 'hint' }, ['where Aâ‚œ = âˆšá¾±â‚œ I, Bâ‚œ = âˆš(1-á¾±â‚œ) I'])
      ]),
      el('div', { class: 'math-box green-bg' }, [
        el('p', { class: 'label green' }, ['Markov Form:']),
        el('p', {}, ['xâ‚œ = âˆšÎ±â‚œ xâ‚œâ‚‹â‚ + âˆš(1-Î±â‚œ) Îµâ‚œ']),
        el('p', { class: 'hint' }, ['Single step transition (Î±â‚œ is per-step, á¾±â‚œ is cumulative)'])
      ]),
      el('div', { class: 'math-box purple-bg' }, [
        el('p', { class: 'label purple' }, ['Noise Schedule (Cosine):']),
        el('p', {}, ['á¾±â‚œ = f(t)/f(0), where f(t) = cosÂ²((t/T + s)/(1+s) Â· Ï€/2)'])
      ]),
      el('div', { style: 'background:#111827;border-radius:8px;padding:16px' }, [
        el('h4', { class: 'yellow', style: 'margin-bottom:8px' }, ['Why State Space?']),
        el('ul', { style: 'color:#d1d5db;font-size:0.875rem;list-style:none' }, [
          el('li', {}, ['â€¢ Linear: Forward process is matrix multiplication + noise']),
          el('li', {}, ['â€¢ Closed form: Jump to any timestep without iteration']),
          el('li', {}, ['â€¢ Tractable: q(xâ‚œ|xâ‚€) is Gaussian with known mean/variance']),
          el('li', {}, ['â€¢ Efficient: Sample random t, compute loss directly'])
        ])
      ])
    ]),
    el('div', { class: 'card' }, [
      el('h3', { style: 'margin-bottom:16px' }, ['Coefficient Schedule']),
      el('div', { class: 'chart' }, [svg]),
      el('p', { class: 'info' }, ['Signal decreases, noise increases over time'])
    ])
  ]);
};

const TrainingTab = () => {
  const steps = [
    ['blue', 'Sample training data', 'Get xâ‚€ from your dataset'],
    ['blue', 'Sample random timestep t ~ Uniform(1, T)', 'Train on all noise levels'],
    ['blue', 'Sample noise Îµ ~ N(0, I)', 'Ground truth to predict'],
    ['green', 'Compute xâ‚œ = âˆšá¾±â‚œ xâ‚€ + âˆš(1-á¾±â‚œ) Îµ', 'State space equation - no iteration!'],
    ['purple', 'Predict noise: ÎµÌ‚ = ÎµÎ¸(xâ‚œ, t)', 'Neural net takes noisy input + timestep'],
    ['red', 'Compute loss: â€–Îµ - ÎµÌ‚â€–Â²', 'Simple MSE']
  ];

  return el('div', {}, [
    el('div', { class: 'card' }, [
      el('h2', {}, ['Training: Learn to Predict the Noise']),
      el('div', { class: 'equation' }, [
        el('span', { style: 'color:#9ca3af;display:block;margin-bottom:8px' }, ['Loss function:']),
        'L = E', el('sub', {}, ['t,xâ‚€,Îµ']), '[ â€–Îµ - Îµ', el('sub', {}, ['Î¸']), '(xâ‚œ, t)â€–Â² ]'
      ]),
      ...steps.map(([color, title, desc], i) =>
        el('div', { class: 'step' }, [
          el('div', { class: `step-num ${color}` }, [String(i + 1)]),
          el('div', {}, [el('p', {}, [title]), el('p', {}, [desc])])
        ])
      )
    ]),
    el('div', { class: 'insight' }, [
      el('h3', {}, ['ðŸ”‘ Key Insight']),
      el('p', { style: 'color:#d1d5db' }, [
        'The ', el('b', {}, ['linear state space']), ' lets us:'
      ]),
      el('ul', { style: 'color:#d1d5db;margin-top:8px;list-style:none' }, [
        el('li', {}, ['â€¢ Jump to any noise level in one step']),
        el('li', {}, ['â€¢ Train on random timesteps (not sequential)']),
        el('li', {}, ['â€¢ Use one network for all noise levels'])
      ])
    ])
  ]);
};

const GenerateTab = () => {
  const canvas = el('canvas', { width: 500, height: 300 });
  const btn = el('button', { class: 'gen-btn' });

  bind(btn, {
    text: () => state.isGenerating ? `Generating... ${state.genStep}/${T}` : 'Start Generation',
    disabled: () => state.isGenerating,
    onClick: () => actions.startGeneration()
  });

  drawGeneration(canvas);

  return el('div', {}, [
    el('div', { class: 'card' }, [
      el('h2', {}, ['Generation: Reverse the Process']),
      el('div', { class: 'equation' }, [
        el('span', { style: 'color:#9ca3af;display:block;margin-bottom:8px' }, ['Reverse sampling:']),
        el('span', { style: 'font-size:0.85rem' }, [
          'x', el('sub', {}, ['t-1']), ' = (1/âˆšÎ±', el('sub', {}, ['t']), ')(x', el('sub', {}, ['t']),
          ' - Î²', el('sub', {}, ['t']), '/âˆš(1-á¾±', el('sub', {}, ['t']), ') Îµ', el('sub', {}, ['Î¸']),
          ') + Ïƒ', el('sub', {}, ['t']), 'z'
        ])
      ]),
      canvas,
      btn
    ]),
    el('div', { class: 'grid-2' }, [
      el('div', { class: 'card' }, [
        el('h3', { style: 'margin-bottom:8px' }, ['Algorithm']),
        el('ol', { style: 'font-size:0.875rem;color:#d1d5db;padding-left:20px;line-height:1.8' }, [
          el('li', {}, ['x', el('sub', {}, ['T']), ' ~ N(0, I)']),
          el('li', {}, ['For t = T â†’ 1:']),
          el('li', { style: 'padding-left:16px' }, ['Predict Îµ', el('sub', {}, ['Î¸']), '(x', el('sub', {}, ['t']), ', t)']),
          el('li', { style: 'padding-left:16px' }, ['Compute x', el('sub', {}, ['t-1'])]),
          el('li', {}, ['Return x', el('sub', {}, ['0'])])
        ])
      ]),
      el('div', { class: 'card' }, [
        el('h3', { style: 'margin-bottom:8px' }, ['Why Iterative?']),
        el('p', { style: 'font-size:0.875rem;color:#d1d5db' }, [
          'Forward is linear, but ', el('b', {}, ['reverse is nonlinear']),
          ' â€” the neural network Îµ', el('sub', {}, ['Î¸']),
          ' requires small steps to stay on the learned manifold.'
        ])
      ])
    ])
  ]);
};

// ============================================================================
// MAIN APP
// ============================================================================
const tabs = { forward: ForwardTab, math: MathTab, training: TrainingTab, generate: GenerateTab };

function App() {
  const content = el('div');

  observe(() => {
    content.innerHTML = '';
    content.appendChild(tabs[state.tab]());
  });

  return el('div', {}, [
    el('div', { class: 'tabs' }, [
      TabButton('forward', '1. Forward'),
      TabButton('math', '2. Math'),
      TabButton('training', '3. Training'),
      TabButton('generate', '4. Generate')
    ]),
    content,
    el('p', { class: 'footer' }, ['Based on DDPM (Ho et al., 2020)'])
  ]);
}

mount(App, '#app');
</script>
</body>
</html>
