<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>Hilbert Transform Voice Simulator</title>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<style>
  :root { --fg:#e6e6e6; --bg:#111; --grid:#333; --accent:#8ad; --muted:#777; }
  body { margin:0; background:var(--bg); color:var(--fg); font:14px/1.4 system-ui, sans-serif; }
  header { padding:12px 16px; border-bottom:1px solid #222; }
  main { display:grid; grid-template-columns: 360px 1fr; gap:0; height: calc(100vh - 56px); }
  section#controls { padding:12px 16px; overflow:auto; border-right:1px solid #222; }
  section#views { position:relative; }
  h1 { font-size:16px; margin:0 0 6px 0; }
  fieldset { border:1px solid #222; padding:10px 12px; margin:12px 0; }
  legend { padding:0 6px; color:#bbb; }
  .row { display:grid; grid-template-columns: 140px 1fr 70px; align-items:center; gap:8px; margin:4px 0; }
  input[type="range"] { width:100%; }
  code { background:#0c0c0c; padding:2px 4px; border-radius:4px; color:#9ad; }
  .btn { display:inline-block; padding:6px 10px; border:1px solid #333; background:#141414; color:var(--fg); cursor:pointer; border-radius:6px; }
  .btn:active { filter:brightness(1.2); }
  canvas { width:100%; height:100%; display:block; background:linear-gradient(#0d0d0d,#0a0a0a); }
  .legend { position:absolute; right:10px; top:10px; font-size:12px; background:#0c0c0cb3; padding:6px 8px; border:1px solid #222; border-radius:6px; }
  .swatch { display:inline-block; width:10px; height:10px; margin-right:6px; border-radius:2px; }
</style>
</head>
<body>
<header>
  <h1>Hilbert Transform: Voiced + Narrowband Noise (Browser Demo)</h1>
</header>
<main>
  <section id="controls">
    <div class="row"><button id="startStop" class="btn">Start</button><div></div><span id="srOut">—</span></div>

    <fieldset>
      <legend>Source</legend>
      <div class="row"><label>Voicing f₀ (Hz)</label><input id="f0" type="range" min="60" max="300" step="1" value="140"><output id="f0o">140</output></div>
      <div class="row"><label>Harmonics</label><input id="nh" type="range" min="5" max="40" step="1" value="20"><output id="nho">20</output></div>
      <div class="row"><label>Noise center (Hz)</label><input id="nFc" type="range" min="500" max="8000" step="10" value="4000"><output id="nFco">4000</output></div>
      <div class="row"><label>Noise BW (Hz)</label><input id="nBw" type="range" min="50" max="4000" step="10" value="800"><output id="nBwo">800</output></div>
      <div class="row"><label>Noise gain</label><input id="nGain" type="range" min="0" max="1" step="0.01" value="0.2"><output id="nGaino">0.20</output></div>
      <div class="row"><label>Voiced gain</label><input id="vGain" type="range" min="0" max="1" step="0.01" value="0.6"><output id="vGaino">0.60</output></div>
      <div class="row"><label>Mix (noise↔voice)</label><input id="mix" type="range" min="0" max="1" step="0.01" value="0.4"><output id="mixo">0.40</output></div>
    </fieldset>

    <fieldset>
      <legend>Hilbert / Envelope</legend>
      <div class="row"><label>Hilbert taps (odd)</label><input id="htaps" type="range" min="31" max="301" step="2" value="129"><output id="htapso">129</output></div>
      <div class="row"><label>Windowed (Blackman)</label><input id="blackman" type="checkbox" checked><span></span><span></span></div>
      <div class="row"><label>Envelope LP win (ms)</label><input id="envMs" type="range" min="2" max="80" step="1" value="20"><output id="envMso">20</output></div>
      <div class="row"><label>Listen</label>
        <select id="listen">
          <option value="x">x(t) (original)</option>
          <option value="xh">x̂(t) (Hilbert)</option>
          <option value="env">A(t) (envelope)</option>
        </select>
        <span></span>
      </div>
      <div class="row"><label>Output gain</label><input id="outGain" type="range" min="0" max="1.5" step="0.01" value="0.9"><output id="outG">0.90</output></div>
    </fieldset>

    <fieldset>
      <legend>Notes</legend>
      <div>Hilbert FIR: <code>h[n]=2/(πn)</code> for odd <code>n≠0</code>, else <code>0</code>, windowed, zero at center tap.</div>
      <div>Analytic pair: <code>z[n]=x[n]+j·x̂[n]</code>, envelope <code>A[n]=|z[n]|</code>, averaged via moving window.</div>
    </fieldset>
  </section>

  <section id="views">
    <canvas id="scope"></canvas>
    <div class="legend">
      <div><span class="swatch" style="background:#8ad"></span>x(t)</div>
      <div><span class="swatch" style="background:#ad8"></span>x̂(t)</div>
      <div><span class="swatch" style="background:#d88"></span>|z(t)|</div>
      <div><span class="swatch" style="background:#aaa"></span>⟨|z|⟩ (LP)</div>
    </div>
  </section>
</main>

<script>
(() => {
  // --- UI bindings ---
  const $ = id => document.getElementById(id);
  const par = [
    ['f0','f0o'],['nh','nho'],['nFc','nFco'],['nBw','nBwo'],
    ['nGain','nGaino'],['vGain','vGaino'],['mix','mixo'],
    ['htaps','htapso'],['envMs','envMso'],['outGain','outG']
  ];
  par.forEach(([a,b])=>{
    const el=$(a), out=$(b);
    const fmt = v => (a==='htaps'||a==='nh'||a==='nFc'||a==='nBw'||a==='f0'||a==='envMs')? Math.round(v): (+v).toFixed(2);
    el.addEventListener('input',()=>out.textContent = fmt(el.value));
    out.textContent = fmt(el.value);
  });

  const scope = $('scope');
  const ctx2d = scope.getContext('2d');
  function resize() { scope.width = scope.clientWidth; scope.height = scope.clientHeight; }
  addEventListener('resize', resize, {passive:true}); resize();

  let audioCtx=null, scriptNode=null, gainNode=null;
  let sr=48000;
  let phase=0, twoPi=Math.PI*2;
  let harmPhases=[], harmW=[], nh=+$('nh').value;
  function initHarm(nh, f0){
    harmPhases = Array.from({length:nh},()=>Math.random()*twoPi);
    harmW = new Float32Array(nh);
    for(let k=0;k<nh;k++){ harmW[k]=1.0/(k+1); }
  }
  initHarm(nh, +$('f0').value);

  // --- Noise bandpass (biquad) ---
  class Biquad {
    constructor(){ this.b0=1; this.b1=0; this.b2=0; this.a1=0; this.a2=0; this.z1=0; this.z2=0; }
    setBandpass(fc, bw, fs){ // constant-peak bandpass
      const w0 = 2*Math.PI*fc/fs;
      const alpha = Math.sin(w0)*Math.sinh(Math.log(2)/2 * bw / fc * w0/Math.sin(w0));
      const cosw0 = Math.cos(w0);
      const b0 =  alpha;
      const b1 =  0;
      const b2 = -alpha;
      const a0 =  1 + alpha;
      const a1 = -2*cosw0;
      const a2 =  1 - alpha;
      this.b0=b0/a0; this.b1=b1/a0; this.b2=b2/a0; this.a1=a1/a0; this.a2=a2/a0;
    }
    process(x){
      const y = this.b0*x + this.z1;
      this.z1 = this.b1*x - this.a1*y + this.z2;
      this.z2 = this.b2*x - this.a2*y;
      return y;
    }
  }
  const noiseBP = new Biquad();

  // --- Hilbert FIR coefficients (odd length), windowed ---
  function blackman(N){
    const w = new Float32Array(N);
    for(let n=0;n<N;n++){
      w[n]=0.42 - 0.5*Math.cos(2*Math.PI*n/(N-1)) + 0.08*Math.cos(4*Math.PI*n/(N-1));
    }
    return w;
  }
  function hilbertTaps(L, useBlackman=true){
    if (L%2===0) L+=1;
    const h = new Float32Array(L); const M=(L-1)/2;
    const w = useBlackman? blackman(L): null;
    for(let n=-M;n<=M;n++){
      const i = n+M;
      if (n===0) { h[i]=0; continue; }
      if (n%2===0){ h[i]=0; continue; }
      h[i] = 2/(Math.PI*n);
      if (w) h[i]*=w[i];
    }
    // DC rejection is inherent; normalize for unit L2 is not required here.
    return h;
  }

  // --- FIR Convolver (direct form) for Hilbert ---
  class FIR {
    constructor(h){ this.h = Float32Array.from(h); this.L = h.length; this.d = new Float32Array(this.L); this.ptr=0; }
    reset(){ this.d.fill(0); this.ptr=0; }
    process(x){
      // circular buffer
      this.d[this.ptr] = x;
      let y=0, idx=this.ptr;
      for(let i=0;i<this.L;i++){
        y += this.h[i] * this.d[idx];
        idx--; if (idx<0) idx=this.L-1;
      }
      this.ptr++; if (this.ptr>=this.L) this.ptr=0;
      return y;
    }
  }

  // --- Moving-average (rectangular) for envelope smoothing ---
  class MovingAvg {
    constructor(N){ this.N=N; this.buf=new Float32Array(N); this.sum=0; this.i=0; }
    resize(N){
      this.N=N; this.buf=new Float32Array(N); this.sum=0; this.i=0;
    }
    proc(x){
      this.sum += x - this.buf[this.i];
      this.buf[this.i]=x;
      this.i++; if (this.i>=this.N) this.i=0;
      return this.sum / this.N;
    }
  }

  // Create initial Hilbert filter and envelope averager
  let H = new FIR(hilbertTaps(+$('htaps').value, $('blackman').checked));
  let envAvg = new MovingAvg(Math.max(1, Math.round(sr*(+$('envMs').value/1000))));

  $('htaps').addEventListener('input', ()=>{ H=new FIR(hilbertTaps(+$('htaps').value, $('blackman').checked)); });
  $('blackman').addEventListener('change', ()=>{ H=new FIR(hilbertTaps(+$('htaps').value, $('blackman').checked)); });
  $('envMs').addEventListener('input', ()=>{
    envAvg.resize(Math.max(1, Math.round(sr*(+$('envMs').value/1000))));
  });
  $('nh').addEventListener('input', ()=>{
    nh=+$('nh').value; initHarm(nh, +$('f0').value);
  });
  $('f0').addEventListener('input', ()=>{
    initHarm(nh, +$('f0').value);
  });

  // --- Audio graph: ScriptProcessorNode for portability ---
  $('startStop').addEventListener('click', async () => {
    if (!audioCtx) {
      audioCtx = new (window.AudioContext||window.webkitAudioContext)({sampleRate:48000});
      sr = audioCtx.sampleRate;
      $('srOut').textContent = sr + " Hz";
      noiseBP.setBandpass(+$('nFc').value, +$('nBw').value, sr);
      envAvg.resize(Math.max(1, Math.round(sr*(+$('envMs').value/1000))));
      scriptNode = audioCtx.createScriptProcessor(1024, 0, 2);
      gainNode = audioCtx.createGain(); gainNode.gain.value = +$('outGain').value;
      scriptNode.onaudioprocess = onAudio;
      scriptNode.connect(gainNode).connect(audioCtx.destination);
      $('startStop').textContent = "Stop";
      animate();
    } else {
      scriptNode.disconnect(); gainNode.disconnect(); audioCtx.close();
      audioCtx=null; cancelAnimationFrame(animId);
      $('startStop').textContent = "Start";
    }
  });
  $('outGain').addEventListener('input', ()=>{ if(gainNode) gainNode.gain.value= +$('outGain').value; });
  $('nFc').addEventListener('input', ()=>{ if(audioCtx) noiseBP.setBandpass(+$('nFc').value, +$('nBw').value, sr); });
  $('nBw').addEventListener('input', ()=>{ if(audioCtx) noiseBP.setBandpass(+$('nFc').value, +$('nBw').value, sr); });

  // --- Synthesis buffers for visualization ---
  const visLen = 2048;
  const visX    = new Float32Array(visLen);
  const visXh   = new Float32Array(visLen);
  const visEnv  = new Float32Array(visLen);
  const visEnvL = new Float32Array(visLen);
  let visPos=0;

  function onAudio(e){
    const outL = e.outputBuffer.getChannelData(0);
    const outR = e.outputBuffer.getChannelData(1);
    const N = outL.length;
    const f0 = +$('f0').value;
    const mix = +$('mix').value;
    const vGain = +$('vGain').value;
    const nGain = +$('nGain').value;
    const listen = $('listen').value;

    for (let n=0; n<N; n++){
      // ----- voiced source: harmonic sum (1/k amplitude) -----
      let t = (phase / twoPi) / sr;
      let voiced = 0.0;
      for (let k=1; k<=nh; k++){
        const w = twoPi*(k*f0)/sr;
        harmPhases[k-1] += w; if (harmPhases[k-1] > 1e9) harmPhases[k-1]-=1e9;
        voiced += harmW[k-1] * Math.sin(harmPhases[k-1]);
      }
      voiced *= vGain;

      // ----- narrowband noise -----
      const wn = (Math.random()*2-1);
      const nb = noiseBP.process(wn) * nGain;

      // ----- mix -----
      let x = (1-mix)*voiced + mix*nb;

      // ----- Hilbert FIR -----
      const xh = H.process(x);

      // ----- envelope and averaged envelope -----
      const env = Math.hypot(x, xh);
      const envL = envAvg.proc(env);

      // ----- output selection -----
      let y = x;
      if (listen==='xh') y = xh;
      else if (listen==='env') y = envL;

      // mild limiter
      y = Math.max(-1, Math.min(1, y));

      outL[n] = y;
      outR[n] = y;

      // ---- visualization ring buffer ----
      visX[visPos]    = x;
      visXh[visPos]   = xh;
      visEnv[visPos]  = env;
      visEnvL[visPos] = envL;
      visPos++; if (visPos>=visLen) visPos=0;

      phase += twoPi * f0 / sr;
      if (phase > 1e9) phase -= 1e9;
    }
  }

  // --- Visualization ---
  let animId=0;
  function animate(){
    animId = requestAnimationFrame(animate);
    const W = scope.width, Hh = scope.height, mid = Math.floor(Hh/2);
    ctx2d.clearRect(0,0,W,Hh);
    // grid
    ctx2d.strokeStyle='#1a1a1a'; ctx2d.lineWidth=1;
    ctx2d.beginPath(); for(let y=mid-60;y<=mid+60;y+=20){ ctx2d.moveTo(0,y); ctx2d.lineTo(W,y);} ctx2d.stroke();

    // extract most recent slice
    const N = visLen;
    const step = Math.max(1, Math.floor(N/W));
    const s = visPos;

    function draw(arr, color, scale=0.9){
      ctx2d.strokeStyle=color; ctx2d.lineWidth=1.5; ctx2d.beginPath();
      for(let i=0, xpix=0; xpix<W; xpix++, i+=step){
        const idx = (s - i + N) % N;
        const v = arr[idx];
        const y = mid - v * (Hh*0.45*scale);
        if (xpix===0) ctx2d.moveTo(xpix, y); else ctx2d.lineTo(xpix, y);
      }
      ctx2d.stroke();
    }
    draw(visX,   '#8ad', 1.0);   // x(t)
    draw(visXh,  '#ad8', 0.95);  // x̂(t)
    draw(visEnv, '#d88', 0.9);   // |z|
    draw(visEnvL,'#aaa', 0.9);   // averaged |z|
  }
})();
</script>
</body>
</html>
