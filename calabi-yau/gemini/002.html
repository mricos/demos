<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Advanced FSM Controlled Manifold</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: 'Inter', sans-serif;
            background-color: #000;
            color: white;
        }
        #container {
            width: 100vw;
            height: 100vh;
        }
        .panel {
            position: absolute;
            background-color: rgba(17, 24, 39, 0.8);
            padding: 20px;
            border-radius: 12px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(55, 65, 81, 0.5);
            transition: opacity 0.4s, transform 0.4s;
            width: 360px;
            max-width: 90vw;
        }
        #controls {
            top: 20px;
            left: 20px;
        }
        #info-display {
            top: 20px;
            right: 20px;
        }
        .is-hidden {
            opacity: 0;
            pointer-events: none;
            transform: scale(0.95);
        }
        .control-item {
            padding: 10px;
            border: 2px solid transparent;
            border-radius: 8px;
            margin-bottom: 10px;
            transition: all 0.3s;
        }
        .control-item.is-highlighted {
            border-color: #3b82f6;
            background-color: rgba(59, 130, 246, 0.1);
        }
        label {
            display: block;
            margin-bottom: 5px;
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
        }
        input[type="range"] {
            width: 100%;
            -webkit-appearance: none;
            appearance: none;
            height: 5px;
            background: #4b5563;
            border-radius: 5px;
            outline: none;
        }
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 18px;
            height: 18px;
            background: #d1d5db;
            cursor: pointer;
            border-radius: 50%;
            border: 2px solid #1f2937;
        }
        .value-display {
            display: inline-block;
            margin-left: 10px;
            font-weight: bold;
            color: #9ca3af;
        }
        .param-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 10px;
        }
        .nav-button {
            background-color: #4b5563;
            color: white;
            border: none;
            padding: 8px 12px;
            border-radius: 6px;
            cursor: pointer;
            transition: background-color 0.3s;
        }
        .nav-button:hover:not(:disabled) {
            background-color: #6b7280;
        }
    </style>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
</head>
<body>
    <div id="container"></div>

    <div id="controls" class="panel control-panel">
        <!-- Content generated by JS -->
    </div>

    <div id="info-display" class="panel control-panel is-hidden">
        <!-- Content generated by JS -->
    </div>

    <script type="importmap">{ "imports": { "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js", "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/" } }</script>
    <script type="module">
        import * as THREE from 'three';
        import { ParametricGeometry } from 'three/addons/geometries/ParametricGeometry.js';

        let scene, camera, renderer, manifold;
        let needsUpdate = false;

        const dom = {
            container: document.getElementById('container'),
            controlsPanel: document.getElementById('controls'),
            infoPanel: document.getElementById('info-display'),
        };

        const params = {
            'cameraX': { value: 5, min: -10, max: 10, step: 0.1, label: 'Camera X Position' },
            'cameraY': { value: 5, min: -10, max: 10, step: 0.1, label: 'Camera Y Position' },
            'objectZ': { value: 0, min: -5, max: 5, step: 0.1, label: 'Object Closer' },
            'paramN': { value: 2, min: 1, max: 7, step: 1, label: 'Param n' },
            'paramM': { value: 3, min: 1, max: 7, step: 1, label: 'Param m' },
            'separation': { value: 0.5, min: 0, max: 1.5, step: 0.01, label: 'Separation' },
            'paramA': { value: 1, min: 0.5, max: 5, step: 0.1, label: 'Param a' },
            'paramB': { value: 1, min: 0.5, max: 3, step: 0.1, label: 'Param b' },
            'paramC': { value: 1, min: 0.5, max: 3, step: 0.1, label: 'Param c' },
        };
        const modelParamKeys = ['paramN', 'paramM', 'separation', 'paramA', 'paramB', 'paramC'];

        const settingsManager = {
            key: 'calabiYauSettings_stable',
            save() {
                const settingsToSave = {};
                for (const key in params) {
                    settingsToSave[key] = params[key].value;
                }
                try {
                    localStorage.setItem(this.key, JSON.stringify(settingsToSave));
                } catch (e) {
                    console.error("Failed to save settings:", e);
                }
            },
            load() {
                try {
                    const storedSettings = localStorage.getItem(this.key);
                    if (storedSettings) {
                        const loadedSettings = JSON.parse(storedSettings);
                        for (const key in loadedSettings) {
                            if (params[key]) {
                                params[key].value = loadedSettings[key];
                            }
                        }
                    }
                } catch (e) {
                    console.error("Failed to load settings:", e);
                }
            }
        };

        function calabiYauFunction(u, v, target) {
            const p = {};
            Object.keys(params).forEach(k => p[k] = params[k].value);
            u *= Math.PI * 2;
            v *= Math.PI * 2;
            const cos_mu = Math.cos(p.paramM * u);
            const base = Math.abs(cos_mu);
            const r = 1 + p.separation * Math.pow(base, p.paramB);
            const x = r * Math.cos(p.paramN * u) * Math.cos(p.paramA * v);
            const y = r * Math.sin(p.paramN * u) * Math.cos(p.paramA * v);
            const z = p.paramC * p.separation * Math.sin(p.paramA * v) * (1 + cos_mu);
            target.set(x * 3, y * 3, z * 3);
        }

        function updateManifoldGeometry() {
            if (manifold) {
                scene.remove(manifold);
                manifold.geometry.dispose();
                manifold.material.dispose();
            }
            const geometry = new ParametricGeometry(calabiYauFunction, 128, 128);
            const colors = [];
            const color = new THREE.Color();
            const pos = geometry.attributes.position;
            for (let i = 0; i < pos.count; i++) {
                const hue = (Math.atan2(pos.getY(i), pos.getX(i)) / (2 * Math.PI)) + 0.5;
                color.setHSL(hue, 1.0, 0.5);
                colors.push(color.r, color.g, color.b);
            }
            geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
            const material = new THREE.MeshStandardMaterial({ 
                vertexColors: true, 
                side: THREE.DoubleSide, 
                wireframe: true, 
                roughness: 0.5, 
                metalness: 0.1 
            });
            manifold = new THREE.Mesh(geometry, material);
            manifold.position.z = params.objectZ.value;
            scene.add(manifold);
            needsUpdate = false;
        }

        function init() {
            settingsManager.load(); // Load settings on startup

            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = 15;
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            dom.container.appendChild(renderer.domElement);
            scene.add(new THREE.AmbientLight(0xffffff, 0.8));
            const dirLight = new THREE.DirectionalLight(0xffffff, 0.5);
            dirLight.position.set(5, 10, 7.5);
            scene.add(dirLight);

            buildUI();
            setupEventListeners();
            updateCameraPosition();
            updateManifoldGeometry();
            animate();
        }

        function animate() {
            requestAnimationFrame(animate);
            if (needsUpdate) {
                updateManifoldGeometry();
            }
            renderer.render(scene, camera);
        }

        function buildUI() {
            let controlsHTML = `<h2 class="text-lg font-bold mb-2">Controls</h2>`;
            ['cameraX', 'cameraY', 'objectZ'].forEach(key => {
                controlsHTML += createSliderHTML(key);
            });
            controlsHTML += `<h3 class="text-md font-semibold mt-4 mb-2 text-gray-300">Model Parameters</h3><div class="param-grid">`;
            modelParamKeys.forEach(key => {
                controlsHTML += createSliderHTML(key);
            });
            controlsHTML += `</div>
                <button id="toggle-info" class="nav-button w-full mt-4">Toggle Info</button>`;
            dom.controlsPanel.innerHTML = controlsHTML;
            
            infoManager.build();
        }

        function createSliderHTML(key) {
            const p = params[key];
            const isFloat = p.step < 1;
            return `<div class="control-item" id="control-${key}">
                <label for="slider-${key}">${p.label}: <span id="value-${key}" class="value-display">${p.value.toFixed(isFloat ? 2 : 0)}</span></label>
                <input type="range" id="slider-${key}" min="${p.min}" max="${p.max}" value="${p.value}" step="${p.step}">
            </div>`;
        }

        function setupEventListeners() {
            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });
            
            Object.keys(params).forEach(key => {
                const slider = document.getElementById(`slider-${key}`);
                if (slider) {
                    slider.addEventListener('input', () => updateParamValue(key, slider.value));
                }
            });

            document.getElementById('toggle-info').addEventListener('click', () => {
                dom.infoPanel.classList.toggle('is-hidden');
            });

            window.addEventListener('keydown', e => {
                if (e.shiftKey && e.ctrlKey) {
                    if (e.key.toLowerCase() === 'c') {
                        e.preventDefault();
                        dom.controlsPanel.classList.toggle('is-hidden');
                    }
                     if (e.key.toLowerCase() === 'i') {
                        e.preventDefault();
                        dom.infoPanel.classList.toggle('is-hidden');
                    }
                }
            });
            
            infoManager.setupNav();
        }

        function updateCameraPosition() {
            camera.position.x = params.cameraX.value;
            camera.position.y = params.cameraY.value;
            camera.lookAt(scene.position);
        }

        function updateParamValue(key, value) {
            const p = params[key];
            p.value = parseFloat(value);
            const valueDisplay = document.getElementById(`value-${key}`);
            if (valueDisplay) {
                valueDisplay.textContent = p.value.toFixed(p.step < 1 ? 2 : 0);
            }

            if (modelParamKeys.includes(key)) {
                needsUpdate = true;
            } else if (key.includes('camera')) {
                updateCameraPosition();
            } else if (key === 'objectZ') {
                if (manifold) manifold.position.z = p.value;
            }
            
            settingsManager.save(); // Save settings on any parameter change
        }
        
        const infoManager = {
            states: {
                'STATE_WELCOME': { title: "Welcome!", text: "Use the controls to change the camera and the shape. Click on any control's label to learn more about it.", highlight: null },
                'control-cameraX': { title: "Camera X Position", text: "Moves the camera left and right.", highlight: 'control-cameraX' },
                'control-cameraY': { title: "Camera Y Position", text: "Moves the camera up and down.", highlight: 'control-cameraY' },
                'control-objectZ': { title: "Object Closer", text: "Moves the object towards or away from the camera.", highlight: 'control-objectZ' },
                'control-paramN': { title: "Parameter 'n'", text: "Controls the number of major lobes.", highlight: 'control-paramN' },
                'control-paramM': { title: "Parameter 'm'", text: "Controls the frequency of the smaller twists.", highlight: 'control-paramM' },
                'control-separation': { title: "Separation", text: "Adjusts the size of the central hole.", highlight: 'control-separation' },
                'control-paramA': { title: "Parameter 'a'", text: "Modifies the shape's revolution frequency.", highlight: 'control-paramA' },
                'control-paramB': { title: "Parameter 'b'", text: "Acts as an exponent on the twists.", highlight: 'control-paramB' },
                'control-paramC': { title: "Parameter 'c'", text: "Scales the overall height of the manifold.", highlight: 'control-paramC' },
            },
            order: [],
            currentStateKey: null,
            lastHighlightedId: null,
            build() {
                this.order = Object.keys(this.states);
                this.currentStateKey = this.order[0];
                let html = `<div id="info-title" class="text-lg font-bold mb-2"></div>
                            <div id="info-text" class="text-sm text-gray-300 min-h-[100px]"></div>
                            <div class="flex justify-between mt-4 border-t border-gray-600 pt-4">
                                <button id="info-prev" class="nav-button">Prev</button>
                                <button id="info-next" class="nav-button">Next</button>
                            </div>`;
                dom.infoPanel.innerHTML = html;
                this.render();
            },
            render() {
                const state = this.states[this.currentStateKey];
                document.getElementById('info-title').textContent = state.title;
                document.getElementById('info-text').textContent = state.text;

                if (this.lastHighlightedId) {
                    document.getElementById(this.lastHighlightedId)?.classList.remove('is-highlighted');
                }
                if (state.highlight) {
                    document.getElementById(state.highlight)?.classList.add('is-highlighted');
                    this.lastHighlightedId = state.highlight;
                } else {
                    this.lastHighlightedId = null;
                }

                const currentIndex = this.order.indexOf(this.currentStateKey);
                document.getElementById('info-prev').disabled = currentIndex <= 0;
                document.getElementById('info-next').disabled = currentIndex >= this.order.length - 1;
            },
            setupNav() {
                document.getElementById('info-prev').addEventListener('click', () => this.navigate(-1));
                document.getElementById('info-next').addEventListener('click', () => this.navigate(1));

                document.querySelectorAll('.control-item label').forEach(label => {
                    const controlId = label.parentElement.id;
                    if (this.states[controlId]) {
                        label.addEventListener('click', () => this.setState(controlId));
                    }
                });
            },
            navigate(dir) {
                const currentIndex = this.order.indexOf(this.currentStateKey);
                const nextIndex = currentIndex + dir;
                if (nextIndex >= 0 && nextIndex < this.order.length) {
                    this.setState(this.order[nextIndex]);
                }
            },
            setState(key) {
                this.currentStateKey = key;
                this.render();
            }
        };

        init();
    </script>
</body>
</html>
