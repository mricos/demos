<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8" />
<title>Characteristic Function Explorer</title>

<link rel="stylesheet"
 href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css">
<script defer
 src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"></script>
<script defer
 src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js"></script>

<style>
*{box-sizing:border-box;margin:0;padding:0}
body{font-family:'Courier New',monospace;background:#111;color:#ddd;font-size:13px}

:root{
  --col-a:#ff6699;
  --col-b:#66ccff;
  --col-probe:#00d0ff;
  --col-param:#ffcc00;
  --col-bg:#111;
  --col-panel:#1a1a1a;
  --col-ctrl:#222;
  --col-border:#333;
  --sidebar-w:280px;
}

/* Controls bar */
#controls{
  display:flex;flex-wrap:wrap;align-items:center;gap:12px;
  padding:8px 16px;background:var(--col-ctrl);border-bottom:1px solid var(--col-border);
}
#controls label{white-space:nowrap}
#controls .group{
  display:flex;align-items:center;gap:6px;
  padding:4px 10px;border:1px solid var(--col-border);border-radius:4px;
}
#controls .group-a{border-color:var(--col-a)}
#controls .group-b{border-color:var(--col-b)}
#controls .group-b .b-inner{transition:opacity 0.15s}
#controls .group-b.disabled .b-inner{opacity:0.25;pointer-events:none}
.slider{width:100px;accent-color:var(--col-param)}
.slider-a{accent-color:var(--col-a)}
.slider-b{accent-color:var(--col-b)}
select{background:#333;color:#ddd;border:1px solid #555;padding:2px 4px;border-radius:3px;font-size:12px}
.val{display:inline-block;width:40px;text-align:right;color:var(--col-param);font-size:12px}
.label-a{color:var(--col-a)}
.label-b{color:var(--col-b)}

/* Grid layout */
#grid{
  display:grid;
  grid-template-columns:1fr 1fr 6px var(--sidebar-w);
  height:calc(100vh - 50px);
  gap:0;
}
.col{padding:12px;overflow-y:auto;border-right:1px solid var(--col-border)}
.col:last-child{border-right:none}
.col h3{font-size:13px;margin-bottom:8px;color:#999;text-transform:uppercase;letter-spacing:1px}
canvas{background:#000;display:block;width:100%;border-radius:3px;margin-bottom:10px}
.formula{margin-bottom:6px;min-height:1.6em}

/* Resize handle */
#resizeHandle{
  background:var(--col-border);cursor:col-resize;
  display:flex;align-items:center;justify-content:center;
  user-select:none;
}
#resizeHandle:hover,#resizeHandle.active{background:#555}
#resizeHandle::after{
  content:'';display:block;width:2px;height:32px;
  border-left:1px solid #666;border-right:1px solid #666;
}

/* Theory sidebar — font scales with width */
.col-theory{background:var(--col-panel);line-height:1.6}
.col-theory details{
  border-bottom:1px solid var(--col-border);padding:8px 0;
}
.col-theory summary{
  cursor:pointer;font-weight:bold;color:#aaa;padding:4px 0;
  list-style:none;
}
.col-theory summary::before{content:'\25b8 ';color:#666}
.col-theory details[open] summary::before{content:'\25be ';color:#999}
.col-theory .section-body{padding:6px 0 4px 0;color:#bbb}
.col-theory table{width:100%;border-collapse:collapse;margin:6px 0}
.col-theory td,.col-theory th{
  padding:3px 6px;border:1px solid var(--col-border);text-align:left;
}
.col-theory th{color:#999}
#currentValues .cv-row{margin:4px 0}
</style>
</head>
<body>

<div id="controls">
  <button id="playBtn" style="background:#333;color:#ddd;border:1px solid #555;border-radius:3px;padding:2px 8px;cursor:pointer;font-size:14px" title="Play/Pause t sweep">&#9654;</button>
  <label><span style="color:var(--col-param)">t</span>
    <input type="range" id="tSlider" min="-15" max="15" step="0.05" value="1" class="slider">
    <span id="tVal" class="val">1.00</span>
  </label>

  <div class="group group-a">
    <span class="label-a">A</span>
    <select id="typeA">
      <option value="gaussian">Gaussian</option>
      <option value="laplace">Laplace</option>
      <option value="uniform">Uniform</option>
      <option value="cauchy">Cauchy</option>
    </select>
    <label class="label-a">&mu;<input type="range" id="muA" min="-4" max="4" step="0.05" value="0" class="slider slider-a">
      <span id="muAVal" class="val">0.00</span></label>
    <label class="label-a">&sigma;<input type="range" id="sigA" min="0.2" max="4" step="0.05" value="1" class="slider slider-a">
      <span id="sigAVal" class="val">1.00</span></label>
  </div>

  <div class="group group-b disabled" id="groupB">
    <label><input type="checkbox" id="toggleB"> <span class="label-b">B</span></label>
    <span class="b-inner">
      <select id="typeB">
        <option value="gaussian">Gaussian</option>
        <option value="laplace" selected>Laplace</option>
        <option value="uniform">Uniform</option>
        <option value="cauchy">Cauchy</option>
      </select>
      <label class="label-b">&mu;<input type="range" id="muB" min="-4" max="4" step="0.05" value="0" class="slider slider-b">
        <span id="muBVal" class="val">0.00</span></label>
      <label class="label-b">&sigma;<input type="range" id="sigB" min="0.2" max="4" step="0.05" value="1" class="slider slider-b">
        <span id="sigBVal" class="val">1.00</span></label>
    </span>
  </div>
</div>

<div id="grid">

  <div class="col col-spatial">
    <h3>Spatial Domain</h3>
    <div id="formulaLeft" class="formula"></div>
    <canvas id="pdfCanvas" width="600" height="260"></canvas>
    <h3>Oscillatory Probe</h3>
    <div id="formulaProbe" class="formula"></div>
    <canvas id="probeCanvas" width="600" height="140"></canvas>
  </div>

  <div class="col col-dual">
    <h3>Dual Domain (Phasor)</h3>
    <div id="formulaRight" class="formula"></div>
    <canvas id="cfCanvas" width="600" height="300"></canvas>
    <h3>&phi;(t) vs t</h3>
    <canvas id="traceCanvas" width="600" height="200"></canvas>
  </div>

  <div id="resizeHandle"></div>

  <div class="col col-theory" id="theoryCol">
    <h3>Theory</h3>

    <details open>
      <summary>Definition</summary>
      <div class="section-body" id="secDefinition"></div>
    </details>

    <details>
      <summary>Eigenfunction of Translation</summary>
      <div class="section-body" id="secEigen"></div>
    </details>

    <details>
      <summary>Convolution Theorem</summary>
      <div class="section-body" id="secConvolution"></div>
    </details>

    <details>
      <summary>Uniqueness</summary>
      <div class="section-body" id="secUniqueness"></div>
    </details>

    <details>
      <summary>Tail &harr; CF Decay</summary>
      <div class="section-body" id="secDecay"></div>
    </details>

    <details open>
      <summary>Current Values</summary>
      <div class="section-body" id="currentValues"></div>
    </details>
  </div>

</div>

<script>
document.addEventListener("DOMContentLoaded", function(){

// ── Distribution Registry ──────────────────────────────────
const SQRT2PI = Math.sqrt(2*Math.PI);

const DISTRIBUTIONS = {
  gaussian: {
    label: "Gaussian",
    pdf: function(x, s){ return Math.exp(-0.5*(x/s)*(x/s)) / (s*SQRT2PI); },
    cf_re: function(t, s){ return Math.exp(-s*s*t*t/2); },
    cf_im: function(t, s){ return 0; },
    paramName: "\u03c3"
  },
  laplace: {
    label: "Laplace",
    pdf: function(x, b){ return Math.exp(-Math.abs(x)/b) / (2*b); },
    cf_re: function(t, b){ return 1/(1 + b*b*t*t); },
    cf_im: function(t, b){ return 0; },
    paramName: "b"
  },
  uniform: {
    label: "Uniform",
    pdf: function(x, a){ return Math.abs(x) <= a ? 1/(2*a) : 0; },
    cf_re: function(t, a){
      var ta = t*a;
      if(Math.abs(ta) < 1e-10) return 1;
      return Math.sin(ta)/ta;
    },
    cf_im: function(t, a){ return 0; },
    paramName: "a"
  },
  cauchy: {
    label: "Cauchy",
    pdf: function(x, g){ return 1/(Math.PI*g*(1+(x/g)*(x/g))); },
    cf_re: function(t, g){ return Math.exp(-g*Math.abs(t)); },
    cf_im: function(t, g){ return 0; },
    paramName: "\u03b3"
  }
};

// ── DOM refs ───────────────────────────────────────────────
var el = function(id){ return document.getElementById(id); };
var pdfCanvas  = el("pdfCanvas");
var probeCanvas= el("probeCanvas");
var cfCanvas   = el("cfCanvas");
var traceCanvas= el("traceCanvas");

var tSlider = el("tSlider");
var typeA=el("typeA"), muA=el("muA"), sigA=el("sigA");
var typeB=el("typeB"), muB=el("muB"), sigB=el("sigB");
var toggleB=el("toggleB"), groupB=el("groupB");
var theoryCol=el("theoryCol");

// ── State ──────────────────────────────────────────────────
function getState(){
  return {
    t: parseFloat(tSlider.value),
    a: { type:typeA.value, mu:parseFloat(muA.value), sig:parseFloat(sigA.value) },
    b: { type:typeB.value, mu:parseFloat(muB.value), sig:parseFloat(sigB.value), on:toggleB.checked }
  };
}

// ── CF with mean: φ_{X+μ}(t) = φ_X(t) · e^{iμt} ─────────
function cfWithMean(dist, t, sig, mu){
  var re0 = dist.cf_re(t, sig);
  var im0 = dist.cf_im(t, sig);
  var cosmt = Math.cos(mu*t);
  var sinmt = Math.sin(mu*t);
  return {
    re: re0*cosmt - im0*sinmt,
    im: re0*sinmt + im0*cosmt
  };
}

// ── Canvas helpers ─────────────────────────────────────────
function canvasSize(canvas){
  var r = canvas.getBoundingClientRect();
  var dpr = window.devicePixelRatio || 1;
  var bw = Math.round(r.width * dpr);
  var bh = Math.round(r.height * dpr);
  if(canvas.width !== bw || canvas.height !== bh){
    canvas.width = bw;
    canvas.height = bh;
  }
  var ctx = canvas.getContext("2d");
  ctx.setTransform(dpr,0,0,dpr,0,0);
  return {w:r.width, h:r.height, ctx:ctx};
}

// ── Draw PDF ───────────────────────────────────────────────
function drawPDF(s){
  var info=canvasSize(pdfCanvas);
  var w=info.w, h=info.h, ctx=info.ctx;
  ctx.clearRect(0,0,w,h);
  var xmin=-8, xmax=8;
  var baseline = h - 20;
  var scale = baseline - 20;

  // axis
  ctx.strokeStyle="#333";ctx.lineWidth=1;
  ctx.beginPath();ctx.moveTo(0,baseline);ctx.lineTo(w,baseline);ctx.stroke();
  for(var xi=Math.ceil(xmin);xi<=Math.floor(xmax);xi++){
    var px=(xi-xmin)/(xmax-xmin)*w;
    ctx.beginPath();ctx.moveTo(px,baseline);ctx.lineTo(px,baseline+5);ctx.stroke();
    if(xi%2===0){ctx.fillStyle="#555";ctx.font="10px monospace";ctx.textAlign="center";ctx.fillText(xi,px,baseline+14);}
  }

  function drawCurve(dist, mu, sig, color){
    ctx.strokeStyle=color;ctx.lineWidth=2;
    ctx.beginPath();
    for(var i=0;i<w;i++){
      var x = xmin + (i/w)*(xmax-xmin);
      var y = dist.pdf(x - mu, sig);
      var py = baseline - y*scale;
      if(i===0) ctx.moveTo(i,py); else ctx.lineTo(i,py);
    }
    ctx.stroke();
  }

  // ── Integration shading: p(x)·cos(tx) ──────────────────
  // Positive = green, negative = red — shows cancellation
  function drawIntegrand(dist, mu, sig, posColor, negColor){
    var prev = null;
    for(var i=0;i<w;i++){
      var x = xmin + (i/w)*(xmax-xmin);
      var p = dist.pdf(x - mu, sig);
      var v = p * Math.cos(s.t * x);  // integrand value
      var py = baseline - v * scale;
      if(prev !== null){
        ctx.fillStyle = v >= 0 ? posColor : negColor;
        ctx.beginPath();
        ctx.moveTo(i-1, baseline);
        ctx.lineTo(i-1, prev);
        ctx.lineTo(i, py);
        ctx.lineTo(i, baseline);
        ctx.closePath();
        ctx.fill();
      }
      prev = py;
    }
  }

  var distA = DISTRIBUTIONS[s.a.type];
  drawIntegrand(distA, s.a.mu, s.a.sig, "rgba(0,200,100,0.35)", "rgba(220,50,50,0.35)");

  if(s.b.on){
    var distB = DISTRIBUTIONS[s.b.type];
    drawIntegrand(distB, s.b.mu, s.b.sig, "rgba(0,150,220,0.25)", "rgba(180,80,200,0.25)");
  }

  // Draw PDF curves on top of shading
  drawCurve(DISTRIBUTIONS[s.a.type], s.a.mu, s.a.sig, "#ff6699");

  if(s.b.on){
    drawCurve(DISTRIBUTIONS[s.b.type], s.b.mu, s.b.sig, "#66ccff");
  }
}

// ── Draw Probe ─────────────────────────────────────────────
function drawProbe(s){
  var info=canvasSize(probeCanvas);
  var w=info.w, h=info.h, ctx=info.ctx;
  ctx.clearRect(0,0,w,h);
  var xmin=-8,xmax=8;
  var mid=h/2, amp=h/2-10;

  ctx.strokeStyle="#333";ctx.lineWidth=1;
  ctx.beginPath();ctx.moveTo(0,mid);ctx.lineTo(w,mid);ctx.stroke();

  ctx.strokeStyle="#00d0ff";ctx.lineWidth=1.5;
  ctx.beginPath();
  for(var i=0;i<w;i++){
    var x=xmin+(i/w)*(xmax-xmin);
    var y=Math.cos(s.t*x);
    if(i===0)ctx.moveTo(i,mid-y*amp);else ctx.lineTo(i,mid-y*amp);
  }
  ctx.stroke();

  ctx.strokeStyle="#00ff88";ctx.lineWidth=1.5;ctx.setLineDash([4,4]);
  ctx.beginPath();
  for(var i=0;i<w;i++){
    var x=xmin+(i/w)*(xmax-xmin);
    var y=Math.sin(s.t*x);
    if(i===0)ctx.moveTo(i,mid-y*amp);else ctx.lineTo(i,mid-y*amp);
  }
  ctx.stroke();
  ctx.setLineDash([]);

  ctx.font="11px monospace";
  ctx.fillStyle="#00d0ff";ctx.fillText("cos(tx)",6,14);
  ctx.fillStyle="#00ff88";ctx.fillText("sin(tx)",80,14);
}

// ── Draw Phasor (unit circle) ──────────────────────────────
function drawPhasor(s){
  var info=canvasSize(cfCanvas);
  var w=info.w, h=info.h, ctx=info.ctx;
  ctx.clearRect(0,0,w,h);
  var cx=w/2, cy=h/2, R=Math.min(w,h)/2-30;

  ctx.strokeStyle="#333";ctx.lineWidth=1;
  ctx.beginPath();ctx.arc(cx,cy,R,0,2*Math.PI);ctx.stroke();
  ctx.beginPath();ctx.moveTo(cx-R-10,cy);ctx.lineTo(cx+R+10,cy);ctx.stroke();
  ctx.beginPath();ctx.moveTo(cx,cy-R-10);ctx.lineTo(cx,cy+R+10);ctx.stroke();

  ctx.font="11px monospace";ctx.fillStyle="#555";
  ctx.textAlign="center";
  ctx.fillText("Re",cx+R+16,cy+4);
  ctx.fillText("Im",cx+4,cy-R-12);

  // ── Phasor trail: full parametric CF curve φ(t) ──────────
  function drawTrail(dist, sig, mu, color){
    var N = 400;
    var tmin = -15, tmax = 15;
    ctx.strokeStyle = color;
    ctx.lineWidth = 1;
    ctx.globalAlpha = 0.4;
    ctx.beginPath();
    for(var i=0;i<=N;i++){
      var tt = tmin + (i/N)*(tmax - tmin);
      var cf = cfWithMean(dist, tt, sig, mu);
      var px = cx + cf.re * R;
      var py = cy - cf.im * R;
      if(i===0) ctx.moveTo(px, py); else ctx.lineTo(px, py);
    }
    ctx.stroke();
    ctx.globalAlpha = 1.0;

    // Bright dot at current t on the trail
    var cfNow = cfWithMean(dist, s.t, sig, mu);
    ctx.fillStyle = color;
    ctx.beginPath();
    ctx.arc(cx + cfNow.re*R, cy - cfNow.im*R, 3, 0, 2*Math.PI);
    ctx.fill();
  }

  var distA = DISTRIBUTIONS[s.a.type];
  drawTrail(distA, s.a.sig, s.a.mu, "#ff6699");
  if(s.b.on){
    drawTrail(DISTRIBUTIONS[s.b.type], s.b.sig, s.b.mu, "#66ccff");
  }

  function drawArm(re, im, color, label){
    var mag=Math.sqrt(re*re+im*im);
    ctx.strokeStyle=color;ctx.lineWidth=2.5;
    ctx.beginPath();ctx.moveTo(cx,cy);ctx.lineTo(cx+re*R,cy-im*R);ctx.stroke();
    ctx.fillStyle=color;
    ctx.beginPath();ctx.arc(cx+re*R,cy-im*R,4,0,2*Math.PI);ctx.fill();
    ctx.font="11px monospace";ctx.fillStyle=color;ctx.textAlign="left";
    ctx.fillText(label+": |"+mag.toFixed(3)+"|",cx+re*R+8,cy-im*R-6);
  }

  var distA=DISTRIBUTIONS[s.a.type];
  var cfA=cfWithMean(distA,s.t,s.a.sig,s.a.mu);
  drawArm(cfA.re, cfA.im, "#ff6699", "A");

  if(s.b.on){
    var distB=DISTRIBUTIONS[s.b.type];
    var cfB=cfWithMean(distB,s.t,s.b.sig,s.b.mu);
    drawArm(cfB.re, cfB.im, "#66ccff", "B");
  }

  return cfA;
}

// ── Draw CF trace: Re, Im, |φ| vs t ────────────────────────
var TRACE_TMIN = -15, TRACE_TMAX = 15;

function drawTrace(s){
  var info=canvasSize(traceCanvas);
  var w=info.w, h=info.h, ctx=info.ctx;
  ctx.clearRect(0,0,w,h);
  var tmin=TRACE_TMIN, tmax=TRACE_TMAX;
  var margin=16;
  var mid=h/2;                       // y=0 line
  var yScale=(h/2 - margin);         // ±1 maps to ±yScale from mid

  function yOf(v){ return mid - v*yScale; }

  // grid lines
  ctx.strokeStyle="#333";ctx.lineWidth=1;
  ctx.beginPath();ctx.moveTo(0,yOf(0));ctx.lineTo(w,yOf(0));ctx.stroke();
  ctx.setLineDash([2,4]);
  ctx.beginPath();ctx.moveTo(0,yOf(1));ctx.lineTo(w,yOf(1));ctx.stroke();
  ctx.beginPath();ctx.moveTo(0,yOf(-1));ctx.lineTo(w,yOf(-1));ctx.stroke();
  ctx.setLineDash([]);

  ctx.font="10px monospace";ctx.fillStyle="#444";ctx.textAlign="right";
  ctx.fillText("1",14,yOf(1)+10);
  ctx.fillText("0",14,yOf(0)-3);
  ctx.fillText("-1",14,yOf(-1)-3);

  // t-axis ticks
  ctx.textAlign="center";
  for(var ti=-15;ti<=15;ti+=5){
    var px=(ti-tmin)/(tmax-tmin)*w;
    ctx.fillStyle="#444";ctx.fillText(ti,px,h-2);
  }

  var N=400;

  function drawCurve(valFn, color, dash){
    ctx.strokeStyle=color;ctx.lineWidth=1.5;
    if(dash) ctx.setLineDash(dash);
    ctx.beginPath();
    for(var i=0;i<=N;i++){
      var tt=tmin+(i/N)*(tmax-tmin);
      var v=valFn(tt);
      var px=(i/N)*w;
      if(i===0) ctx.moveTo(px,yOf(v)); else ctx.lineTo(px,yOf(v));
    }
    ctx.stroke();
    if(dash) ctx.setLineDash([]);
  }

  function drawDistCurves(dist, sig, mu, baseColor){
    // |φ| — solid bright
    drawCurve(function(tt){
      var cf=cfWithMean(dist,tt,sig,mu);
      return Math.sqrt(cf.re*cf.re+cf.im*cf.im);
    }, baseColor, null);

    // Re(φ) — dotted, slightly dimmer
    ctx.globalAlpha=0.6;
    drawCurve(function(tt){
      return cfWithMean(dist,tt,sig,mu).re;
    }, baseColor, [6,3]);
    ctx.globalAlpha=1.0;

    // Im(φ) — dashed, dimmer still
    ctx.globalAlpha=0.4;
    drawCurve(function(tt){
      return cfWithMean(dist,tt,sig,mu).im;
    }, baseColor, [2,3]);
    ctx.globalAlpha=1.0;
  }

  var distA=DISTRIBUTIONS[s.a.type];
  drawDistCurves(distA, s.a.sig, s.a.mu, "#ff6699");

  if(s.b.on){
    var distB=DISTRIBUTIONS[s.b.type];
    drawDistCurves(distB, s.b.sig, s.b.mu, "#66ccff");
  }

  // vertical indicator at current t
  var tpx=(s.t-tmin)/(tmax-tmin)*w;
  ctx.strokeStyle="#ffcc00";ctx.lineWidth=1;ctx.setLineDash([3,3]);
  ctx.beginPath();ctx.moveTo(tpx,yOf(1));ctx.lineTo(tpx,yOf(-1));ctx.stroke();
  ctx.setLineDash([]);
  ctx.fillStyle="#ffcc00";ctx.font="10px monospace";ctx.textAlign="center";
  ctx.fillText("t="+s.t.toFixed(1),tpx,h-2);

  // legend
  ctx.font="10px monospace";ctx.textAlign="left";
  ctx.fillStyle="#999";
  ctx.fillText("|φ| ——",6,12);
  ctx.setLineDash([6,3]);ctx.strokeStyle="#999";ctx.lineWidth=1;
  ctx.beginPath();ctx.moveTo(56,9);ctx.lineTo(76,9);ctx.stroke();
  ctx.setLineDash([]);
  ctx.fillText("Re",78,12);
  ctx.setLineDash([2,3]);ctx.beginPath();ctx.moveTo(96,9);ctx.lineTo(116,9);ctx.stroke();
  ctx.setLineDash([]);
  ctx.fillText("Im",118,12);
}

// ── Populate static theory sections ────────────────────────
function populateTheory(){
  el("secDefinition").innerHTML =
    '<p>The characteristic function of a random variable $X$ is:</p>' +
    '$$\\varphi_X(t) = E[e^{itX}] = \\int_{-\\infty}^{\\infty} e^{itx} f(x)\\,dx$$' +
    '<p>It is the Fourier transform of the PDF (with sign convention $e^{+itx}$). ' +
    'It always exists and $\\varphi(0)=1$.</p>';

  el("secEigen").innerHTML =
    '<p>The exponential $e^{itx}$ is an <strong>eigenfunction</strong> of the translation operator $T_\\mu$:</p>' +
    '$$T_\\mu[e^{itx}] = e^{it(x-\\mu)} = e^{-it\\mu} \\cdot e^{itx}$$' +
    '<p>Eigenvalue: $\\lambda = e^{-it\\mu}$</p>' +
    '<p>For the CF this means:</p>' +
    '$$\\varphi_{X+\\mu}(t) = e^{i\\mu t} \\cdot \\varphi_X(t)$$' +
    '<p><strong>Drag the $\\mu$ slider</strong> to see this: the phasor ' +
    '<em>rotates</em> (phase change) without changing length. ' +
    'The magnitude $|\\varphi|$ is shift-invariant.</p>';

  el("secConvolution").innerHTML =
    '<p>If $X$ and $Y$ are independent:</p>' +
    '$$\\varphi_{X+Y}(t) = \\varphi_X(t) \\cdot \\varphi_Y(t)$$' +
    '<p>Convolution in spatial domain becomes multiplication in the dual domain. ' +
    'This is why characteristic functions simplify the study of sums of ' +
    'independent random variables.</p>';

  el("secUniqueness").innerHTML =
    '<p>The CF uniquely determines the distribution:</p>' +
    '$$\\varphi_X = \\varphi_Y \\iff X \\stackrel{d}{=} Y$$' +
    '<p>Inversion formula:</p>' +
    '$$f(x) = \\frac{1}{2\\pi}\\int_{-\\infty}^{\\infty} e^{-itx}\\varphi(t)\\,dt$$';

  el("secDecay").innerHTML =
    '<p>Tail behavior of the PDF determines CF smoothness/decay:</p>' +
    '<table>' +
    '<tr><th>Distribution</th><th>PDF tail</th><th>$|\\varphi(t)|$ decay</th></tr>' +
    '<tr><td>Gaussian</td><td>$e^{-x^2/2}$</td><td>$e^{-t^2/2}$ (Gaussian)</td></tr>' +
    '<tr><td>Laplace</td><td>$e^{-|x|}$</td><td>$1/(1+t^2)$ (algebraic)</td></tr>' +
    '<tr><td>Uniform</td><td>compact</td><td>$\\text{sinc}(t)$ (oscillating)</td></tr>' +
    '<tr><td>Cauchy</td><td>$1/x^2$ (heavy)</td><td>$e^{-|t|}$ (exponential)</td></tr>' +
    '</table>' +
    '<p>Heavier tails $\\Rightarrow$ smoother CF. Lighter tails $\\Rightarrow$ faster CF decay.</p>';

  renderMathInElement(document.querySelector(".col-theory"),{
    delimiters:[
      {left:"$$",right:"$$",display:true},
      {left:"$",right:"$",display:false}
    ],
    throwOnError:false
  });
}

// ── Update dynamic "Current Values" section ────────────────
function updateCurrentValues(s, cfA, cfB){
  var magA=Math.sqrt(cfA.re*cfA.re+cfA.im*cfA.im);
  var angA=Math.atan2(cfA.im,cfA.re);
  var html =
    '<div class="cv-row" style="color:#ff6699">' +
    '<strong>A (' + DISTRIBUTIONS[s.a.type].label + ')</strong><br>' +
    '&mu;=' + s.a.mu.toFixed(2) + ', ' + DISTRIBUTIONS[s.a.type].paramName + '=' + s.a.sig.toFixed(2) + '<br>' +
    '&phi;<sub>A</sub>(' + s.t.toFixed(2) + ') = ' + cfA.re.toFixed(4) + ' + ' + cfA.im.toFixed(4) + 'i<br>' +
    '|&phi;| = ' + magA.toFixed(4) + ', &ang; = ' + (angA*180/Math.PI).toFixed(1) + '&deg;' +
    '</div>';
  if(s.b.on && cfB){
    var magB=Math.sqrt(cfB.re*cfB.re+cfB.im*cfB.im);
    var angB=Math.atan2(cfB.im,cfB.re);
    html +=
      '<div class="cv-row" style="color:#66ccff">' +
      '<strong>B (' + DISTRIBUTIONS[s.b.type].label + ')</strong><br>' +
      '&mu;=' + s.b.mu.toFixed(2) + ', ' + DISTRIBUTIONS[s.b.type].paramName + '=' + s.b.sig.toFixed(2) + '<br>' +
      '&phi;<sub>B</sub>(' + s.t.toFixed(2) + ') = ' + cfB.re.toFixed(4) + ' + ' + cfB.im.toFixed(4) + 'i<br>' +
      '|&phi;| = ' + magB.toFixed(4) + ', &ang; = ' + (angB*180/Math.PI).toFixed(1) + '&deg;' +
      '</div>';
  }
  el("currentValues").innerHTML = html;
}

// ── B toggle ───────────────────────────────────────────────
function updateBState(){
  if(toggleB.checked) groupB.classList.remove("disabled");
  else groupB.classList.add("disabled");
}

// ── Sidebar font scaling ───────────────────────────────────
function scaleSidebarFont(){
  var w = theoryCol.offsetWidth;
  // base 12px at 280px width, grow fast: 3px per 100px wider
  var sz = Math.max(11, 12 + (w - 280) * 0.06);
  theoryCol.style.fontSize = sz + "px";
  // KaTeX scales too
  var katexEls = theoryCol.querySelectorAll(".katex");
  for(var i=0;i<katexEls.length;i++){
    katexEls[i].style.fontSize = (sz * 0.92) + "px";
  }
}

// ── Resize handle drag ────────────────────────────────────
(function(){
  var handle = el("resizeHandle");
  var grid = el("grid");
  var dragging = false;

  handle.addEventListener("mousedown", function(e){
    e.preventDefault();
    dragging = true;
    handle.classList.add("active");
    document.body.style.cursor = "col-resize";
    document.body.style.userSelect = "none";
  });

  window.addEventListener("mousemove", function(e){
    if(!dragging) return;
    var gridRect = grid.getBoundingClientRect();
    var sidebarW = gridRect.right - e.clientX;
    sidebarW = Math.max(180, Math.min(sidebarW, gridRect.width * 0.6));
    document.documentElement.style.setProperty("--sidebar-w", sidebarW + "px");
    scaleSidebarFont();
    update();
  });

  window.addEventListener("mouseup", function(){
    if(!dragging) return;
    dragging = false;
    handle.classList.remove("active");
    document.body.style.cursor = "";
    document.body.style.userSelect = "";
  });
})();

// ── Main update ────────────────────────────────────────────
function update(){
  var s=getState();

  el("tVal").textContent=s.t.toFixed(2);
  el("muAVal").textContent=s.a.mu.toFixed(2);
  el("sigAVal").textContent=s.a.sig.toFixed(2);
  el("muBVal").textContent=s.b.mu.toFixed(2);
  el("sigBVal").textContent=s.b.sig.toFixed(2);

  updateBState();
  drawPDF(s);
  drawProbe(s);
  var cfA=drawPhasor(s);
  drawTrace(s);

  // ── Three KaTeX equations (matching gpt.html style) ──────
  var distLabel = DISTRIBUTIONS[s.a.type].label;
  var pName = DISTRIBUTIONS[s.a.type].paramName;
  el("formulaLeft").innerHTML =
    '\\[\\textcolor{#ff6699}{p(x)} \\sim \\text{' + distLabel + '}' +
    '\\;(\\mu=' + s.a.mu.toFixed(1) + ',\\,' + pName + '=' + s.a.sig.toFixed(1) + ')\\]';

  el("formulaProbe").innerHTML =
    '\\[\\textcolor{#00d0ff}{e^{i\\,\\textcolor{#ffcc00}{t}\\,x}}' +
    '= \\cos(\\textcolor{#ffcc00}{t}x)' +
    '+ i\\sin(\\textcolor{#ffcc00}{t}x)\\]';

  el("formulaRight").innerHTML =
    '\\[\\varphi(\\textcolor{#ffcc00}{t})' +
    '= \\int' +
    '\\textcolor{#00d0ff}{e^{i\\,\\textcolor{#ffcc00}{t}x}}' +
    '\\,\\textcolor{#ff6699}{p(x)}\\,dx\\]';

  renderMathInElement(el("formulaLeft"),{
    delimiters:[{left:"\\[",right:"\\]",display:true}], throwOnError:false});
  renderMathInElement(el("formulaProbe"),{
    delimiters:[{left:"\\[",right:"\\]",display:true}], throwOnError:false});
  renderMathInElement(el("formulaRight"),{
    delimiters:[{left:"\\[",right:"\\]",display:true}], throwOnError:false});

  var cfB=null;
  if(s.b.on){
    var distB=DISTRIBUTIONS[s.b.type];
    cfB=cfWithMean(distB,s.t,s.b.sig,s.b.mu);
  }
  updateCurrentValues(s, cfA, cfB);
}

// ── Play/pause animation ───────────────────────────────────
var playBtn = el("playBtn");
var animating = false;
var animId = null;
var animSpeedMin = 0.06;  // slow when magnitude near 1
var animSpeedMax = 0.30;  // fast when magnitude near 0

playBtn.addEventListener("click", function(){
  animating = !animating;
  playBtn.innerHTML = animating ? "&#9646;&#9646;" : "&#9654;";
  if(animating) animStep();
  else if(animId){ cancelAnimationFrame(animId); animId=null; }
});

function animStep(){
  if(!animating) return;
  var t = parseFloat(tSlider.value);
  // compute magnitude of dist A at current t
  var s = getState();
  var distA = DISTRIBUTIONS[s.a.type];
  var cf = cfWithMean(distA, t, s.a.sig, s.a.mu);
  var mag = Math.sqrt(cf.re*cf.re + cf.im*cf.im);
  // high mag → slow, low mag → fast (sqrt curve: slows down sooner)
  var speed = animSpeedMax - Math.sqrt(mag) * (animSpeedMax - animSpeedMin);
  t += speed;
  if(t > 15) t = -15;
  tSlider.value = t.toFixed(2);
  update();
  animId = requestAnimationFrame(animStep);
}

// ── Wire controls ──────────────────────────────────────────
var sliders = [tSlider,muA,sigA,muB,sigB];
for(var i=0;i<sliders.length;i++) sliders[i].addEventListener("input",update);
var selects = [typeA,typeB];
for(var i=0;i<selects.length;i++){
  selects[i].addEventListener("input",update);
  selects[i].addEventListener("change",update);
}
toggleB.addEventListener("change",update);
toggleB.addEventListener("input",update);

window.addEventListener("resize", function(){ scaleSidebarFont(); update(); });

// ── Mouse hover on trace canvas sets t ─────────────────────
traceCanvas.addEventListener("mousemove", function(e){
  if(animating) return; // don't fight the animation
  var rect = traceCanvas.getBoundingClientRect();
  var mx = e.clientX - rect.left;
  var t = TRACE_TMIN + (mx / rect.width) * (TRACE_TMAX - TRACE_TMIN);
  t = Math.max(TRACE_TMIN, Math.min(TRACE_TMAX, t));
  tSlider.value = t.toFixed(2);
  update();
});
traceCanvas.style.cursor = "crosshair";

// ── Keyboard: space=play/pause, arrows=fine t ──────────────
window.addEventListener("keydown", function(e){
  if(e.target.tagName === "INPUT" || e.target.tagName === "SELECT") return;
  if(e.code === "Space"){
    e.preventDefault();
    playBtn.click();
  } else if(e.code === "ArrowRight"){
    e.preventDefault();
    tSlider.value = Math.min(15, parseFloat(tSlider.value) + 0.1).toFixed(2);
    update();
  } else if(e.code === "ArrowLeft"){
    e.preventDefault();
    tSlider.value = Math.max(-15, parseFloat(tSlider.value) - 0.1).toFixed(2);
    update();
  }
});

// ── Init ───────────────────────────────────────────────────
populateTheory();
scaleSidebarFont();
update();

});
</script>
</body>
</html>
