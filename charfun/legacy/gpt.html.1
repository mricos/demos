<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8" />
<title>Characteristic Function – Parameterized Distributions</title>

<link rel="stylesheet"
 href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css">

<script defer
 src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"></script>

<script defer
 src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js"></script>

<style>
body { margin:0; font-family:sans-serif; background:#111; color:#ddd; }
#controls { padding:15px; background:#222; }
#layout { display:flex; height:85vh; }
#left,#right { flex:1; padding:20px; overflow:auto; }
canvas { background:#000; display:block; margin:auto; }
.slider { width:250px; }
select { margin-right:20px; }
.param { color:#ffcc00; }
.mass { color:#ff6699; }
.probe { color:#00d0ff; }
</style>
</head>
<body>

<div id="controls">
  Distribution:
  <select id="distSelect">
    <option value="gaussian">Gaussian</option>
    <option value="uniform">Uniform</option>
    <option value="multimodal">Multimodal</option>
  </select>

  <br><br>

  Dual parameter <span class="param">t</span>:
  <input type="range" id="tSlider" min="-15" max="15" step="0.1" value="1" class="slider">
  <span id="tVal"></span>

  <br><br>

  Shape parameter:
  <input type="range" id="shapeSlider" min="-5" max="5" step="0.1" value="0" class="slider">
  <span id="shapeVal"></span>
</div>

<div id="layout">

<div id="left">
  <h3>Spatial Domain</h3>
  <div id="formulaLeft"></div>
  <canvas id="pdfCanvas" width="500" height="230"></canvas>

  <h4>Oscillatory Probe</h4>
  <div id="formulaProbe"></div>
  <canvas id="probeCanvas" width="500" height="120"></canvas>

  <div id="explainLeft"></div>
</div>

<div id="right">
  <h3>Dual Domain</h3>
  <div id="formulaRight"></div>
  <canvas id="cfCanvas" width="500" height="300"></canvas>
  <div id="explainRight"></div>
</div>

</div>

<script>
document.addEventListener("DOMContentLoaded", function(){

const pdfCtx=document.getElementById("pdfCanvas").getContext("2d");
const probeCtx=document.getElementById("probeCanvas").getContext("2d");
const cfCtx=document.getElementById("cfCanvas").getContext("2d");

const tSlider=document.getElementById("tSlider");
const shapeSlider=document.getElementById("shapeSlider");
const distSelect=document.getElementById("distSelect");

function gaussian(x,mu=0,sigma=1){
  return Math.exp(-0.5*((x-mu)/sigma)**2)/(sigma*Math.sqrt(2*Math.PI));
}

function uniform(x,width){
  return (x>=-width && x<=width) ? 1/(2*width) : 0;
}

function multimodal(x,d){
  return 0.5*gaussian(x,-d,0.6)+0.5*gaussian(x,d,0.6);
}

function pdf(x){
  const type=distSelect.value;
  const s=parseFloat(shapeSlider.value);

  if(type==="gaussian") return gaussian(x,s,1);
  if(type==="uniform") return uniform(x,Math.abs(s)+0.5);
  if(type==="multimodal") return multimodal(x,Math.abs(s)+0.5);
}

function computeCF(t){
  let re=0, im=0;
  const N=2000;
  const xmin=-8, xmax=8;
  const dx=(xmax-xmin)/N;
  for(let i=0;i<N;i++){
    const x=xmin+i*dx;
    const p=pdf(x);
    re+=p*Math.cos(t*x)*dx;
    im+=p*Math.sin(t*x)*dx;
  }
  return {re,im};
}

function drawPDF(){
  pdfCtx.clearRect(0,0,500,230);
  pdfCtx.strokeStyle="white";
  pdfCtx.beginPath();
  for(let i=0;i<500;i++){
    const x=(i/500)*16-8;
    const y=pdf(x);
    const py=200-y*150;
    if(i===0) pdfCtx.moveTo(i,py);
    else pdfCtx.lineTo(i,py);
  }
  pdfCtx.stroke();
}

function drawProbe(t){
  probeCtx.clearRect(0,0,500,120);
  probeCtx.strokeStyle="#00d0ff";
  probeCtx.beginPath();
  for(let i=0;i<500;i++){
    const x=(i/500)*16-8;
    const y=Math.sin(t*x);
    const py=60 - y*40;
    if(i===0) probeCtx.moveTo(i,py);
    else probeCtx.lineTo(i,py);
  }
  probeCtx.stroke();
}

function drawCF(t){
  cfCtx.clearRect(0,0,500,300);
  const {re,im}=computeCF(t);
  const cx=250, cy=150, R=100;

  cfCtx.strokeStyle="#444";
  cfCtx.beginPath();
  cfCtx.arc(cx,cy,R,0,2*Math.PI);
  cfCtx.stroke();

  cfCtx.strokeStyle="#00ffcc";
  cfCtx.beginPath();
  cfCtx.moveTo(cx,cy);
  cfCtx.lineTo(cx+re*R, cy-im*R);
  cfCtx.stroke();

  return {re,im};
}

function renderMath(){
  renderMathInElement(document.body,{
    delimiters:[
      {left:"\\[",right:"\\]",display:true},
      {left:"$",right:"$",display:false}
    ]
  });
}

function update(){
  const t=parseFloat(tSlider.value);
  const s=parseFloat(shapeSlider.value);

  document.getElementById("tVal").textContent=t.toFixed(2);
  document.getElementById("shapeVal").textContent=s.toFixed(2);

  drawPDF();
  drawProbe(t);
  const {re,im}=drawCF(t);

  document.getElementById("formulaLeft").innerHTML=
  `\\[
  \\textcolor{#ff6699}{p(x)} \\text{ with shape parameter } ${s.toFixed(2)}
  \\]`;

  document.getElementById("formulaProbe").innerHTML=
  `\\[
  \\textcolor{#00d0ff}{e^{i\\,\\textcolor{#ffcc00}{t}\\,x}}
  =
  \\cos(\\textcolor{#ffcc00}{t}x)
  + i\\sin(\\textcolor{#ffcc00}{t}x)
  \\]`;

  document.getElementById("formulaRight").innerHTML=
  `\\[
  \\varphi(\\textcolor{#ffcc00}{t})
  =
  \\int
  \\textcolor{#00d0ff}{e^{i\\,\\textcolor{#ffcc00}{t}x}}
  \\textcolor{#ff6699}{p(x)} dx
  \\]`;

  document.getElementById("explainLeft").innerHTML=
  `
  Shape parameter meaning:
  <br>
  Gaussian → mean μ
  <br>
  Uniform → half-width
  <br>
  Multimodal → mode separation
  `;

  document.getElementById("explainRight").innerHTML=
  `
  φ(t)=(${re.toFixed(3)}, ${im.toFixed(3)})
  <br>
  |φ(t)|=${Math.sqrt(re*re+im*im).toFixed(3)}
  <br><br>
  Translation changes phase linearly.
  <br>
  Separation introduces interference.
  <br>
  Width increases cancellation rate.
  `;

  renderMath();
}

tSlider.addEventListener("input",update);
shapeSlider.addEventListener("input",update);
distSelect.addEventListener("change",update);

update();

});
</script>
</body>
</html>
