<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Synthetic Iris Data Visualization</title>
  <link rel="stylesheet" href="styles.css">

  <!-- KaTeX for math rendering -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.css">
  <script defer src="https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.js"></script>
  <style>
    body {
      margin: 0;
      padding: 16px;
      display: flex;
      flex-direction: column;
      gap: 12px;
      overflow: auto;
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", "Roboto", "Helvetica Neue", Arial, sans-serif;
    }
    /* Wikipedia math equation images - invert for dark mode */
    .mwe-math-fallback-image-inline,
    .mwe-math-fallback-image-display,
    img[src*="wikimedia.org/api/rest_v1/media/math"] {
      filter: invert(1) hue-rotate(180deg);
      opacity: 0.9;
    }
    .controls {
      display: flex;
      gap: 12px;
      align-items: center;
      justify-content: center;
      padding: 6px 10px;
      background: transparent;
      border: 1px solid var(--grid);
      border-radius: 4px;
      flex-wrap: wrap;
    }
    .controls button {
      padding: 4px 8px;
      background: var(--panel);
      border: 1px solid var(--grid);
      border-radius: 3px;
      color: var(--text);
      cursor: pointer;
      font-size: 10px;
      font-weight: 600;
    }
    .controls button:hover {
      background: var(--accent);
      border-color: var(--accent);
    }
    .controls label {
      font-size: 10px;
      display: flex;
      align-items: center;
      gap: 6px;
      font-weight: 500;
      margin-right: 4px;
    }
    .controls select {
      font-size: 10px;
      padding: 2px 4px;
    }
    /* Range slider styling */
    input[type="range"] {
      -webkit-appearance: none;
      background: transparent;
      cursor: pointer;
    }
    input[type="range"]::-webkit-slider-track {
      background: var(--grid);
      height: 4px;
      border-radius: 2px;
    }
    input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none;
      background: rgba(88, 166, 255, 0.5);
      border: 1.5px solid var(--accent);
      width: 8px;
      height: 16px;
      border-radius: 2px;
      margin-top: -4px;
      cursor: pointer;
    }
    input[type="range"]::-moz-range-track {
      background: var(--grid);
      height: 4px;
      border-radius: 2px;
    }
    input[type="range"]::-moz-range-thumb {
      background: rgba(88, 166, 255, 0.5);
      border: 1.5px solid var(--accent);
      width: 8px;
      height: 16px;
      border-radius: 2px;
      cursor: pointer;
    }

    .controls input[type="range"] {
      width: 80px;
    }
    .controls #spreadValue {
      min-width: 28px;
      font-weight: 600;
    }
    .controls input[type="checkbox"] {
      -webkit-appearance: none;
      appearance: none;
      width: 14px;
      height: 14px;
      border: 1px solid var(--grid);
      background: var(--bg);
      border-radius: 2px;
      cursor: pointer;
      position: relative;
    }
    .controls input[type="checkbox"]:checked {
      background: var(--accent);
      border-color: var(--accent);
    }
    .controls input[type="checkbox"]:checked::after {
      content: '‚úì';
      position: absolute;
      color: var(--bg);
      font-size: 11px;
      font-weight: bold;
      top: -1px;
      left: 2px;
    }
    .viz-container {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 16px;
      margin-bottom: 16px;
    }
    .plot-wrapper {
      display: flex;
      flex-direction: column;
      gap: 4px;
    }
    .plot-title {
      font-size: 11px;
      color: var(--muted);
      text-align: center;
    }
    canvas {
      width: 100%;
      height: 220px;
      border: 1px solid var(--grid);
      border-radius: 6px;
      background: var(--panel);
      cursor: pointer;
    }
    .info {
      font-size: 11px;
      color: var(--muted);
      padding: 8px;
      background: transparent;
      border: 1px solid var(--grid);
      border-radius: 4px;
      text-align: center;
    }
    .legend {
      display: flex;
      gap: 30px;
      justify-content: center;
      font-size: 10px;
      padding: 6px;
      background: transparent;
    }
    .legend-item {
      display: flex;
      align-items: center;
      gap: 7px;
    }
    .flower-icon {
      position: relative;
      width: 20px;
      height: 20px;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    .flower-icon .petal {
      position: absolute;
      background: currentColor;
      border-radius: 50%;
      z-index: 2;
    }
    .flower-icon .sepal {
      position: absolute;
      background: #5cdb5c;
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
      border: 1.5px solid #1a2a1f;
      box-shadow: 0 0 2px rgba(0, 0, 0, 0.5), inset 0 1px 1px rgba(255, 255, 255, 0.3);
      z-index: 3;
    }
    .flower-icon .center {
      position: absolute;
      background: #ffd700;
      border-radius: 50%;
      width: 5px;
      height: 5px;
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
      z-index: 3;
    }
    .matrix-section {
      display: grid;
      grid-template-columns: 380px 1fr;
      gap: 16px;
      margin-bottom: 16px;
    }
    @media (max-width: 1024px) {
      .matrix-section {
        grid-template-columns: 1fr;
      }
    }
    .matrix-panel {
      background: var(--panel);
      border: 1px solid var(--grid);
      border-radius: 6px;
      padding: 12px;
    }
    .matrix-title {
      font-size: 12px;
      color: var(--accent2);
      margin-bottom: 8px;
      text-align: center;
      font-weight: 600;
    }
    .corr-matrix {
      display: grid;
      grid-template-columns: auto repeat(4, 1fr);
      gap: 2px;
      font-size: 10px;
      background: #0d1117;
      border-radius: 6px;
      padding: 8px;
    }
    .corr-cell {
      padding: 8px;
      text-align: center;
      border-radius: 3px;
      transition: all 0.2s ease;
    }
    .corr-header {
      font-weight: 600;
      color: var(--muted);
      background: #1b1f27;
      border: 1px solid var(--grid);
    }
    .corr-value {
      font-family: monospace;
      color: var(--text);
      border: 1px solid var(--grid);
      cursor: ns-resize;
      user-select: none;
      position: relative;
    }
    .corr-value:hover {
      transform: scale(1.05);
      box-shadow: 0 2px 8px rgba(88, 166, 255, 0.3);
      border-color: var(--accent);
    }
    .corr-value.adjusting {
      background: rgba(88, 166, 255, 0.2);
      border-color: var(--accent2);
    }
    .corr-value::after {
      content: '‚Üï';
      position: absolute;
      right: 2px;
      top: 2px;
      font-size: 8px;
      opacity: 0;
      transition: opacity 0.2s;
      color: var(--accent2);
    }
    .corr-value:hover::after {
      opacity: 0.7;
    }
    .corr-value.adjusting::after {
      opacity: 1;
      animation: pulse 0.5s ease-in-out infinite;
    }
    @keyframes pulse {
      0%, 100% { transform: translateY(-1px); }
      50% { transform: translateY(1px); }
    }
    .gmm-container {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 8px;
    }
    .gmm-feature-panel {
      background: var(--bg);
      border: 1px solid var(--grid);
      border-radius: 4px;
      padding: 8px;
    }
    .gmm-feature-header {
      font-size: 10px;
      font-weight: 600;
      margin-bottom: 6px;
      color: var(--accent2);
      text-align: center;
    }
    .gmm-curve-canvas {
      width: 100%;
      height: 80px;
      display: block;
      border-radius: 3px;
      background: #0d1117;
    }
    .gmm-legend {
      display: flex;
      justify-content: space-around;
      margin-top: 4px;
      font-size: 9px;
      gap: 4px;
    }
    .gmm-legend-item {
      display: flex;
      align-items: center;
      gap: 3px;
    }
    .gmm-legend-dot {
      width: 6px;
      height: 6px;
      border-radius: 50%;
    }
    .equation-panel {
      background: var(--panel);
      border: 1px solid var(--grid);
      border-radius: 6px;
      padding: 16px;
      margin-top: 16px;
      position: relative;
    }
    .equation-panel .equation {
      min-height: 1800px;
    }
    .equation-panel.compact .margin-note {
      display: none;
    }
    .equation-panel.compact .equation {
      min-height: auto;
    }
    .equation-panel.compact .contribution-analysis {
      display: none;
    }
    .equation-panel.compact .equation-explanation {
      display: none;
    }
    .margin-note {
      position: absolute;
      right: -220px;
      width: 200px;
      font-size: 12px;
      font-weight: 600;
      color: var(--text);
      background: rgba(88, 166, 255, 0.1);
      border-left: 4px solid var(--accent);
      padding: 10px;
      border-radius: 4px;
      line-height: 1.5;
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", "Roboto", "Helvetica Neue", Arial, sans-serif;
    }
    @media (max-width: 1400px) {
      .margin-note {
        position: static;
        width: 100%;
        margin: 8px 0;
      }
    }
    .equation-title {
      font-size: 16px;
      color: var(--accent2);
      margin-bottom: 12px;
      text-align: center;
      font-weight: 800;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", "Roboto", "Helvetica Neue", Arial, sans-serif;
    }
    .equation {
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 16px;
      flex-wrap: wrap;
      padding: 24px;
      background: #0d1117;
      border-radius: 6px;
      font-family: 'Times New Roman', serif;
      font-size: 20px;
      min-height: 80px;
    }
    .equation > div {
      margin: 4px 0;
    }
    .eq-element {
      display: inline-flex;
      align-items: center;
      color: var(--text);
      position: relative;
    }
    .eq-matrix {
      display: inline-grid;
      grid-template-columns: repeat(4, 1fr);
      gap: 6px;
      padding: 8px 12px;
      border-left: 3px solid var(--accent);
      border-right: 3px solid var(--accent);
      font-size: 12px;
      font-family: monospace;
      background: rgba(88, 166, 255, 0.05);
      border-radius: 4px;
    }
    .eq-matrix-small {
      font-size: 8px;
      gap: 3px;
      padding: 4px 6px;
      border-left: 2px solid var(--accent);
      border-right: 2px solid var(--accent);
    }
    .eq-matrix-small .eq-matrix-cell {
      min-width: 24px;
      font-size: 8px;
      padding: 1px;
    }
    .eq-matrix-cell {
      min-width: 36px;
      text-align: center;
      transition: all 0.3s ease;
      padding: 2px;
      border-radius: 2px;
    }
    .eq-matrix-cell:hover {
      color: var(--accent2);
      transform: scale(1.3);
      background: rgba(247, 129, 102, 0.1);
    }
    .contribution-analysis {
      background: #11151d;
      border: 1px solid var(--grid);
      border-radius: 6px;
      padding: 12px;
      margin: 12px 0;
      font-size: 11px;
    }
    .contribution-row {
      display: flex;
      align-items: center;
      gap: 8px;
      margin: 5px 0;
      padding: 4px;
    }
    .contribution-label {
      min-width: 70px;
      font-weight: 700;
      color: var(--accent2);
      font-size: 11px;
    }
    .contribution-bar {
      flex: 1;
      height: 16px;
      background: #0d1117;
      border-radius: 8px;
      overflow: hidden;
      position: relative;
      border: 1px solid var(--grid);
    }
    .contribution-fill {
      height: 100%;
      background: linear-gradient(90deg, var(--accent), var(--accent2));
      transition: width 0.3s ease;
    }
    .contribution-value {
      min-width: 95px;
      text-align: right;
      font-family: monospace;
      color: var(--text);
      font-weight: 600;
      font-size: 10px;
    }
    .eq-fraction {
      display: inline-flex;
      flex-direction: column;
      align-items: center;
      font-size: 16px;
      margin: 0 8px;
    }
    .eq-numerator {
      border-bottom: 2px solid var(--text);
      padding-bottom: 6px;
      margin-bottom: 6px;
    }
    .eq-denominator {
      padding-top: 6px;
      font-size: 18px;
      font-weight: 600;
    }
    .eq-exp {
      font-size: 24px;
      color: var(--accent2);
      font-weight: 600;
    }
    .eq-superscript {
      font-size: 14px;
      vertical-align: super;
      color: var(--accent);
    }
    .eq-subscript {
      font-size: 10px;
      vertical-align: sub;
      color: var(--muted);
    }
    .eq-sqrt {
      position: relative;
      padding: 6px 10px 6px 16px;
    }
    .eq-sqrt::before {
      content: '‚àö';
      position: absolute;
      left: 0;
      font-size: 24px;
      color: var(--accent);
    }
    .eq-sqrt::after {
      content: '';
      position: absolute;
      top: 4px;
      left: 16px;
      right: 0;
      height: 1px;
      background: var(--accent);
    }
    .eq-parentheses {
      font-size: 30px;
      color: var(--accent);
    }
    .var-sigma {
      color: #58a6ff;
      font-weight: 700;
    }
    .var-mu {
      color: #f78166;
      font-weight: 700;
    }
    .var-x {
      color: #3fb950;
      font-weight: 700;
    }
    .var-r {
      color: #bc8cff;
      font-weight: 700;
    }
    .eq-element .var-sigma,
    .eq-element .var-mu,
    .eq-element .var-x {
      font-size: 24px;
    }

    /* Global scrollbar styling for WebKit browsers (Chrome, Safari, Edge) */
    ::-webkit-scrollbar {
      width: 12px;
      height: 12px;
    }
    ::-webkit-scrollbar-track {
      background: var(--bg);
    }
    ::-webkit-scrollbar-thumb {
      background: var(--grid);
      border-radius: 6px;
      border: 2px solid var(--bg);
    }
    ::-webkit-scrollbar-thumb:hover {
      background: var(--muted);
    }
    ::-webkit-scrollbar-corner {
      background: var(--bg);
    }

    /* Firefox scrollbar styling */
    * {
      scrollbar-width: thin;
      scrollbar-color: var(--grid) var(--bg);
    }
  </style>
</head>
<body>
  <div class="info">
    <strong style="font-size:14pt">Synthetic Iris Dataset</strong>
    <span id="corrModeIndicator" style="margin-left: 12px; font-size: 10px; color: var(--accent2); display: none;">
      Using Custom Correlation Matrix
    </span>
  </div>

  <!-- Controls moved above plots -->
  <div style="position: sticky; top: 0; z-index: 100; background: var(--bg); border: 1px solid var(--grid); border-radius: 4px; padding: 12px; margin: 8px; margin-top: 0;">
    <div style="display: flex; flex-wrap: wrap; align-items: center; gap: 8px; row-gap: 12px;">
      <!-- Sliders group -->
      <div style="display: flex; flex-wrap: wrap; gap: 12px; flex: 1; min-width: 0;">
        <div style="flex: 1; min-width: 180px;">
          <label style="display: flex; align-items: center; gap: 6px; font-size: 11px;">
            <span style="color: var(--muted); min-width: 65px; white-space: nowrap;">Spread:</span>
            <input type="range" id="spreadSlider" min="0.1" max="5" step="0.1" value="1" style="flex: 1; margin: 0; min-width: 60px;">
            <span id="spreadValue" style="color: var(--text); min-width: 28px; text-align: right; font-variant-numeric: tabular-nums;">1.0</span>
          </label>
        </div>

        <div style="flex: 1; min-width: 180px;">
          <label style="display: flex; align-items: center; gap: 6px; font-size: 11px;">
            <span style="color: var(--muted); min-width: 65px; white-space: nowrap;">Separation:</span>
            <input type="range" id="separationSlider" min="0.3" max="2.0" step="0.1" value="1" style="flex: 1; margin: 0; min-width: 60px;">
            <span id="separationValue" style="color: var(--text); min-width: 28px; text-align: right; font-variant-numeric: tabular-nums;">1.0</span>
          </label>
        </div>

        <div style="flex: 1; min-width: 180px;">
          <label style="display: flex; align-items: center; gap: 6px; font-size: 11px;">
            <span style="color: var(--muted); min-width: 65px; white-space: nowrap;">Correlation:</span>
            <input type="range" id="skewSlider" min="-1.0" max="1.0" step="0.1" value="0" style="flex: 1; margin: 0; min-width: 60px;">
            <span id="skewValue" style="color: var(--text); min-width: 28px; text-align: right; font-variant-numeric: tabular-nums;">0.0</span>
          </label>
        </div>
      </div>

      <!-- Buttons group -->
      <div style="display: flex; gap: 8px; flex-shrink: 0;">
        <button id="dataInfoBtn" style="font-size: 10px; padding: 3px 8px; color: var(--muted); background: transparent; border: 1px solid var(--grid); border-radius: 3px; cursor: pointer; white-space: nowrap;">info</button>
      </div>
    </div>

    <div id="dataInfoPanel" style="display: none; margin-top: 12px; background: rgba(88, 166, 255, 0.08); border-radius: 6px; padding: 16px; font-size: 14px; line-height: 1.7; color: var(--text); border: 1px solid rgba(88, 166, 255, 0.2); max-height: 80vh; overflow-y: auto;">

      <!-- Header -->
      <div style="margin-bottom: 16px;">
        <strong style="color: var(--accent); font-size: 16px; letter-spacing: 0.5px;">How data points are generated</strong>
      </div>

      <p style="margin: 0 0 16px 0; color: var(--muted); line-height: 1.7; font-size: 14px;">
        Data points are generated using a <strong style="color: var(--text);"><a href="https://en.wikipedia.org/wiki/Mixture_model" style="color: var(--accent); text-decoration: none;"> Gaussian Mixture Model</a> (GMM)</strong>. Generation is a two-stage process: <strong style="color: var(--text);">first pick a&nbsp;species&nbsp;k</strong> with probability <span id="gmm_pik"></span>, then <strong style="color: var(--text);">sample features conditioned on that species</strong> from <span id="gmm_normal"></span> (a Gaussian distribution with mean Œº and covariance Œ£).
      </p>

      <!-- Tree and Histogram side by side -->
      <div style="display: flex; gap: 20px; align-items: flex-start; flex-wrap: wrap; margin: 20px 0;">

        <!-- Generation Process Tree -->
        <div style="flex: 1; min-width: 300px;">
          <svg viewBox="0 0 420 240" style="width: 100%; max-width: 450px; margin: 0 auto; display: block;">
            <!-- Start node -->
            <rect x="175" y="10" width="70" height="32" rx="4" fill="rgba(138, 180, 248, 0.15)" stroke="#8ab4f8" stroke-width="2"/>
            <text x="210" y="31" fill="#8ab4f8" font-size="13" text-anchor="middle" font-weight="bold">START</text>

            <!-- Vertical line down -->
            <line x1="210" y1="42" x2="210" y2="60" stroke="#666" stroke-width="1.5"/>

            <!-- Species selection node -->
            <rect x="130" y="60" width="160" height="28" rx="4" fill="rgba(255, 230, 109, 0.12)" stroke="#ffe66d" stroke-width="2"/>
            <text x="210" y="79" fill="#ffe66d" font-size="11" text-anchor="middle" font-weight="600">Pick Species (œÄ = 1/3 each)</text>

            <!-- Three branches -->
            <line x1="210" y1="88" x2="70" y2="110" stroke="#ff6b6b" stroke-width="1.5"/>
            <line x1="210" y1="88" x2="210" y2="110" stroke="#4ecdc4" stroke-width="1.5"/>
            <line x1="210" y1="88" x2="350" y2="110" stroke="#ffe66d" stroke-width="1.5"/>

            <!-- Setosa branch -->
            <g class="species-branch" data-species="0" style="cursor: pointer;">
              <rect x="10" y="110" width="120" height="26" rx="3" fill="rgba(255, 107, 107, 0.12)" stroke="#ff6b6b" stroke-width="1.5"/>
              <text x="70" y="127" fill="#ff6b6b" font-size="10" text-anchor="middle" font-weight="600">ùí©(Œº‚ÇÅ, Œ£‚ÇÅ) Setosa</text>
            </g>

            <!-- Versicolor branch -->
            <g class="species-branch" data-species="1" style="cursor: pointer;">
              <rect x="150" y="110" width="120" height="26" rx="3" fill="rgba(78, 205, 196, 0.12)" stroke="#4ecdc4" stroke-width="1.5"/>
              <text x="210" y="127" fill="#4ecdc4" font-size="10" text-anchor="middle" font-weight="600">ùí©(Œº‚ÇÇ, Œ£‚ÇÇ) Versicolor</text>
            </g>

            <!-- Virginica branch -->
            <g class="species-branch" data-species="2" style="cursor: pointer;">
              <rect x="290" y="110" width="120" height="26" rx="3" fill="rgba(255, 230, 109, 0.12)" stroke="#ffe66d" stroke-width="1.5"/>
              <text x="350" y="127" fill="#ffe66d" font-size="10" text-anchor="middle" font-weight="600">ùí©(Œº‚ÇÉ, Œ£‚ÇÉ) Virginica</text>
            </g>

            <!-- Converging lines to output box -->
            <line x1="70" y1="136" x2="120" y2="165" stroke="#666" stroke-width="1" opacity="0.5"/>
            <line x1="210" y1="136" x2="210" y2="165" stroke="#666" stroke-width="1" opacity="0.5"/>
            <line x1="350" y1="136" x2="300" y2="165" stroke="#666" stroke-width="1" opacity="0.5"/>

            <!-- Output: 4D feature vector box -->
            <rect x="90" y="155" width="240" height="85" rx="4" fill="rgba(138, 180, 248, 0.08)" stroke="var(--accent)" stroke-width="2" stroke-dasharray="3,3"/>
            <text x="210" y="172" fill="var(--accent)" font-size="10" text-anchor="middle" font-weight="bold">4D Feature Vector</text>

            <!-- Four features in a 2x2 grid - clickable -->
            <g class="feature-select" data-feature="0" style="cursor: pointer;">
              <rect x="100" y="180" width="100" height="22" rx="2" fill="rgba(138, 180, 248, 0.1)" stroke="var(--accent)" stroke-width="1"/>
              <text x="150" y="195" fill="var(--text)" font-size="9" text-anchor="middle">Sepal Length</text>
            </g>
            <g class="feature-select" data-feature="1" style="cursor: pointer;">
              <rect x="220" y="180" width="100" height="22" rx="2" fill="rgba(138, 180, 248, 0.1)" stroke="var(--accent)" stroke-width="1"/>
              <text x="270" y="195" fill="var(--text)" font-size="9" text-anchor="middle">Sepal Width</text>
            </g>
            <g class="feature-select" data-feature="2" style="cursor: pointer;">
              <rect x="100" y="210" width="100" height="22" rx="2" fill="rgba(138, 180, 248, 0.1)" stroke="var(--accent)" stroke-width="1"/>
              <text x="150" y="225" fill="var(--text)" font-size="9" text-anchor="middle">Petal Length</text>
            </g>
            <g class="feature-select" data-feature="3" style="cursor: pointer;">
              <rect x="220" y="210" width="100" height="22" rx="2" fill="rgba(138, 180, 248, 0.1)" stroke="var(--accent)" stroke-width="1"/>
              <text x="270" y="225" fill="var(--text)" font-size="9" text-anchor="middle">Petal Width</text>
            </g>
          </svg>
        </div>

        <!-- Histogram showing feature distribution -->
        <div style="flex: 1; min-width: 300px;">
          <div id="gmmHistogramTitle" style="text-align: center; margin-bottom: 8px; color: var(--muted); font-size: 13px;">
            Petal Length - All Species
          </div>
          <canvas id="gmmHistogram" width="500" height="240" style="width: 100%; height: auto; border-radius: 4px; background: rgba(0, 0, 0, 0.2); cursor: pointer;"></canvas>
          <div style="text-align: center; margin-top: 8px; font-size: 11px; color: var(--muted);">
            Click species or features in tree ‚Ä¢ Click histogram to reset
          </div>
        </div>

      </div>

          <p style="margin: 20px 0 16px 0; color: var(--muted); line-height: 1.7; font-size: 14px;">
            To generate correlated samples from a <a href="https://en.wikipedia.org/wiki/Multivariate_normal_distribution" style="color: var(--accent); text-decoration: none; font-weight: 600;">multivariate Gaussian</a>, <strong style="color: var(--text);"><a href="https://en.wikipedia.org/wiki/Cholesky_decomposition" style="color: var(--accent); text-decoration: none;">Cholesky decomposition</a></strong> is the standard approach.
          </p>

          <p style="margin: 16px 0; color: var(--muted); line-height: 1.7; font-size: 14px;">
            We decompose the <strong style="color: var(--text);"><a href="https://en.wikipedia.org/wiki/Covariance_matrix" style="color: var(--accent); text-decoration: none;">4√ó4 covariance matrix</a></strong>:
          </p>

            <!-- Cholesky Decomposition Visual -->
            <div style="display: flex; align-items: center; justify-content: center; gap: 16px; margin: 32px 0; flex-wrap: wrap;">
              <!-- Sigma matrix -->
              <div style="font-family: 'Courier New', monospace; font-size: 10px; color: var(--text);">
                <div style="text-align: center; margin-bottom: 8px; font-size: 20px; color: var(--accent); font-weight: bold;">Œ£<sub>k</sub></div>
                <div style="display: grid; grid-template-columns: auto 1fr auto; gap: 3px; align-items: center;">
                  <div style="font-size: 20px; color: var(--muted);">[</div>
                  <div style="display: grid; grid-template-rows: repeat(4, 1fr); gap: 2px;">
                    <div style="display: grid; grid-template-columns: repeat(4, 1fr); gap: 2px;">
                      <div style="padding: 4px; background: rgba(255,107,107,0.3); border-radius: 2px; text-align: center; font-size: 7px; min-width: 18px;">œÉ‚ÇÅ‚ÇÅ</div>
                      <div style="padding: 4px; background: rgba(78,205,196,0.2); border-radius: 2px; text-align: center; font-size: 7px; min-width: 18px;">œÉ‚ÇÅ‚ÇÇ</div>
                      <div style="padding: 4px; background: rgba(78,205,196,0.2); border-radius: 2px; text-align: center; font-size: 7px; min-width: 18px;">œÉ‚ÇÅ‚ÇÉ</div>
                      <div style="padding: 4px; background: rgba(78,205,196,0.2); border-radius: 2px; text-align: center; font-size: 7px; min-width: 18px;">œÉ‚ÇÅ‚ÇÑ</div>
                    </div>
                    <div style="display: grid; grid-template-columns: repeat(4, 1fr); gap: 2px;">
                      <div style="padding: 4px; background: rgba(78,205,196,0.2); border-radius: 2px; text-align: center; font-size: 7px; min-width: 18px;">œÉ‚ÇÇ‚ÇÅ</div>
                      <div style="padding: 4px; background: rgba(255,107,107,0.3); border-radius: 2px; text-align: center; font-size: 7px; min-width: 18px;">œÉ‚ÇÇ‚ÇÇ</div>
                      <div style="padding: 4px; background: rgba(78,205,196,0.2); border-radius: 2px; text-align: center; font-size: 7px; min-width: 18px;">œÉ‚ÇÇ‚ÇÉ</div>
                      <div style="padding: 4px; background: rgba(78,205,196,0.2); border-radius: 2px; text-align: center; font-size: 7px; min-width: 18px;">œÉ‚ÇÇ‚ÇÑ</div>
                    </div>
                    <div style="display: grid; grid-template-columns: repeat(4, 1fr); gap: 2px;">
                      <div style="padding: 4px; background: rgba(78,205,196,0.2); border-radius: 2px; text-align: center; font-size: 7px; min-width: 18px;">œÉ‚ÇÉ‚ÇÅ</div>
                      <div style="padding: 4px; background: rgba(78,205,196,0.2); border-radius: 2px; text-align: center; font-size: 7px; min-width: 18px;">œÉ‚ÇÉ‚ÇÇ</div>
                      <div style="padding: 4px; background: rgba(255,107,107,0.3); border-radius: 2px; text-align: center; font-size: 7px; min-width: 18px;">œÉ‚ÇÉ‚ÇÉ</div>
                      <div style="padding: 4px; background: rgba(78,205,196,0.2); border-radius: 2px; text-align: center; font-size: 7px; min-width: 18px;">œÉ‚ÇÉ‚ÇÑ</div>
                    </div>
                    <div style="display: grid; grid-template-columns: repeat(4, 1fr); gap: 2px;">
                      <div style="padding: 4px; background: rgba(78,205,196,0.2); border-radius: 2px; text-align: center; font-size: 7px; min-width: 18px;">œÉ‚ÇÑ‚ÇÅ</div>
                      <div style="padding: 4px; background: rgba(78,205,196,0.2); border-radius: 2px; text-align: center; font-size: 7px; min-width: 18px;">œÉ‚ÇÑ‚ÇÇ</div>
                      <div style="padding: 4px; background: rgba(78,205,196,0.2); border-radius: 2px; text-align: center; font-size: 7px; min-width: 18px;">œÉ‚ÇÑ‚ÇÉ</div>
                      <div style="padding: 4px; background: rgba(255,107,107,0.3); border-radius: 2px; text-align: center; font-size: 7px; min-width: 18px;">œÉ‚ÇÑ‚ÇÑ</div>
                    </div>
                  </div>
                  <div style="font-size: 20px; color: var(--muted);">]</div>
                </div>
              </div>

              <div style="font-size: 20px; color: var(--text); font-weight: bold;">=</div>

              <!-- L matrix (lower triangular) -->
              <div style="font-family: 'Courier New', monospace; font-size: 10px; color: var(--text);">
                <div style="text-align: center; margin-bottom: 8px; font-size: 20px; color: var(--accent); font-weight: bold;">L</div>
                <div style="display: grid; grid-template-columns: auto 1fr auto; gap: 3px; align-items: center;">
                  <div style="font-size: 20px; color: var(--muted);">[</div>
                  <div style="display: grid; grid-template-rows: repeat(4, 1fr); gap: 2px;">
                    <div style="display: grid; grid-template-columns: repeat(4, 1fr); gap: 2px;">
                      <div style="padding: 4px; background: rgba(138,180,248,0.3); border-radius: 2px; text-align: center; font-size: 7px; min-width: 18px;">l‚ÇÅ‚ÇÅ</div>
                      <div style="padding: 4px; background: rgba(0,0,0,0.4); border-radius: 2px; text-align: center; font-size: 7px; min-width: 18px; color: var(--muted);">0</div>
                      <div style="padding: 4px; background: rgba(0,0,0,0.4); border-radius: 2px; text-align: center; font-size: 7px; min-width: 18px; color: var(--muted);">0</div>
                      <div style="padding: 4px; background: rgba(0,0,0,0.4); border-radius: 2px; text-align: center; font-size: 7px; min-width: 18px; color: var(--muted);">0</div>
                    </div>
                    <div style="display: grid; grid-template-columns: repeat(4, 1fr); gap: 2px;">
                      <div style="padding: 4px; background: rgba(138,180,248,0.3); border-radius: 2px; text-align: center; font-size: 7px; min-width: 18px;">l‚ÇÇ‚ÇÅ</div>
                      <div style="padding: 4px; background: rgba(138,180,248,0.3); border-radius: 2px; text-align: center; font-size: 7px; min-width: 18px;">l‚ÇÇ‚ÇÇ</div>
                      <div style="padding: 4px; background: rgba(0,0,0,0.4); border-radius: 2px; text-align: center; font-size: 7px; min-width: 18px; color: var(--muted);">0</div>
                      <div style="padding: 4px; background: rgba(0,0,0,0.4); border-radius: 2px; text-align: center; font-size: 7px; min-width: 18px; color: var(--muted);">0</div>
                    </div>
                    <div style="display: grid; grid-template-columns: repeat(4, 1fr); gap: 2px;">
                      <div style="padding: 4px; background: rgba(138,180,248,0.3); border-radius: 2px; text-align: center; font-size: 7px; min-width: 18px;">l‚ÇÉ‚ÇÅ</div>
                      <div style="padding: 4px; background: rgba(138,180,248,0.3); border-radius: 2px; text-align: center; font-size: 7px; min-width: 18px;">l‚ÇÉ‚ÇÇ</div>
                      <div style="padding: 4px; background: rgba(138,180,248,0.3); border-radius: 2px; text-align: center; font-size: 7px; min-width: 18px;">l‚ÇÉ‚ÇÉ</div>
                      <div style="padding: 4px; background: rgba(0,0,0,0.4); border-radius: 2px; text-align: center; font-size: 7px; min-width: 18px; color: var(--muted);">0</div>
                    </div>
                    <div style="display: grid; grid-template-columns: repeat(4, 1fr); gap: 2px;">
                      <div style="padding: 4px; background: rgba(138,180,248,0.3); border-radius: 2px; text-align: center; font-size: 7px; min-width: 18px;">l‚ÇÑ‚ÇÅ</div>
                      <div style="padding: 4px; background: rgba(138,180,248,0.3); border-radius: 2px; text-align: center; font-size: 7px; min-width: 18px;">l‚ÇÑ‚ÇÇ</div>
                      <div style="padding: 4px; background: rgba(138,180,248,0.3); border-radius: 2px; text-align: center; font-size: 7px; min-width: 18px;">l‚ÇÑ‚ÇÉ</div>
                      <div style="padding: 4px; background: rgba(138,180,248,0.3); border-radius: 2px; text-align: center; font-size: 7px; min-width: 18px;">l‚ÇÑ‚ÇÑ</div>
                    </div>
                  </div>
                  <div style="font-size: 20px; color: var(--muted);">]</div>
                </div>
              </div>

              <div style="font-size: 20px; color: var(--text); font-weight: bold;">√ó</div>

              <!-- L^T matrix (upper triangular) -->
              <div style="font-family: 'Courier New', monospace; font-size: 10px; color: var(--text);">
                <div style="text-align: center; margin-bottom: 8px; font-size: 20px; color: var(--accent); font-weight: bold;">L<sup>T</sup></div>
                <div style="display: grid; grid-template-columns: auto 1fr auto; gap: 3px; align-items: center;">
                  <div style="font-size: 20px; color: var(--muted);">[</div>
                  <div style="display: grid; grid-template-rows: repeat(4, 1fr); gap: 2px;">
                    <div style="display: grid; grid-template-columns: repeat(4, 1fr); gap: 2px;">
                      <div style="padding: 4px; background: rgba(138,180,248,0.3); border-radius: 2px; text-align: center; font-size: 7px; min-width: 18px;">l‚ÇÅ‚ÇÅ</div>
                      <div style="padding: 4px; background: rgba(138,180,248,0.3); border-radius: 2px; text-align: center; font-size: 7px; min-width: 18px;">l‚ÇÇ‚ÇÅ</div>
                      <div style="padding: 4px; background: rgba(138,180,248,0.3); border-radius: 2px; text-align: center; font-size: 7px; min-width: 18px;">l‚ÇÉ‚ÇÅ</div>
                      <div style="padding: 4px; background: rgba(138,180,248,0.3); border-radius: 2px; text-align: center; font-size: 7px; min-width: 18px;">l‚ÇÑ‚ÇÅ</div>
                    </div>
                    <div style="display: grid; grid-template-columns: repeat(4, 1fr); gap: 2px;">
                      <div style="padding: 4px; background: rgba(0,0,0,0.4); border-radius: 2px; text-align: center; font-size: 7px; min-width: 18px; color: var(--muted);">0</div>
                      <div style="padding: 4px; background: rgba(138,180,248,0.3); border-radius: 2px; text-align: center; font-size: 7px; min-width: 18px;">l‚ÇÇ‚ÇÇ</div>
                      <div style="padding: 4px; background: rgba(138,180,248,0.3); border-radius: 2px; text-align: center; font-size: 7px; min-width: 18px;">l‚ÇÉ‚ÇÇ</div>
                      <div style="padding: 4px; background: rgba(138,180,248,0.3); border-radius: 2px; text-align: center; font-size: 7px; min-width: 18px;">l‚ÇÑ‚ÇÇ</div>
                    </div>
                    <div style="display: grid; grid-template-columns: repeat(4, 1fr); gap: 2px;">
                      <div style="padding: 4px; background: rgba(0,0,0,0.4); border-radius: 2px; text-align: center; font-size: 7px; min-width: 18px; color: var(--muted);">0</div>
                      <div style="padding: 4px; background: rgba(0,0,0,0.4); border-radius: 2px; text-align: center; font-size: 7px; min-width: 18px; color: var(--muted);">0</div>
                      <div style="padding: 4px; background: rgba(138,180,248,0.3); border-radius: 2px; text-align: center; font-size: 7px; min-width: 18px;">l‚ÇÉ‚ÇÉ</div>
                      <div style="padding: 4px; background: rgba(138,180,248,0.3); border-radius: 2px; text-align: center; font-size: 7px; min-width: 18px;">l‚ÇÑ‚ÇÉ</div>
                    </div>
                    <div style="display: grid; grid-template-columns: repeat(4, 1fr); gap: 2px;">
                      <div style="padding: 4px; background: rgba(0,0,0,0.4); border-radius: 2px; text-align: center; font-size: 7px; min-width: 18px; color: var(--muted);">0</div>
                      <div style="padding: 4px; background: rgba(0,0,0,0.4); border-radius: 2px; text-align: center; font-size: 7px; min-width: 18px; color: var(--muted);">0</div>
                      <div style="padding: 4px; background: rgba(0,0,0,0.4); border-radius: 2px; text-align: center; font-size: 7px; min-width: 18px; color: var(--muted);">0</div>
                      <div style="padding: 4px; background: rgba(138,180,248,0.3); border-radius: 2px; text-align: center; font-size: 7px; min-width: 18px;">l‚ÇÑ‚ÇÑ</div>
                    </div>
                  </div>
                  <div style="font-size: 20px; color: var(--muted);">]</div>
                </div>
              </div>
            </div>

            <p style="margin: 24px 0; color: var(--muted); line-height: 1.7; font-size: 16px;">
              Computers natively generate <strong style="color: var(--text);">independent uniform</strong> samples. The <strong style="color: var(--text);">Box‚ÄìMuller transform</strong> converts pairs of these uniforms into <strong style="color: var(--text);">independent N(0,1)</strong> samples. <strong style="color: var(--text);">Cholesky</strong> then introduces the desired correlations. You cannot use Œ£ directly, because x = Œº + Œ£z would give Cov(x) = <strong style="color: var(--text);">Œ£¬≤, not Œ£</strong>.
            </p>

            <p style="margin: 16px 0; color: var(--muted); line-height: 1.7; font-size: 16px;">
              The scalar analogy: if Z ~ N(0,1) and you want X ~ N(0, œÉ¬≤), you use X = œÉZ (<a href="https://en.wikipedia.org/wiki/Standard_deviation" style="color: var(--accent); text-decoration: none; font-weight: 600;">standard deviation</a>), not X = œÉ¬≤Z (<a href="https://en.wikipedia.org/wiki/Variance" style="color: var(--accent); text-decoration: none; font-weight: 600;">variance</a>). In the matrix case, you likewise need a matrix "square root" of Œ£. Cholesky provides this via Œ£ = LL<sup>T</sup>, and the transform <span id="gmm_transform"></span> produces x ~ N(Œº, Œ£), where each draw <strong style="color: var(--text);">x</strong> is one 4D iris measurement vector.
            </p>

            <!-- Before/After 2D visualization -->
            <div style="display: flex; gap: 20px; align-items: center; justify-content: center; margin: 24px 0; flex-wrap: wrap;">
              <div style="text-align: center;">
                <div style="font-size: 12px; color: var(--muted); margin-bottom: 8px;">Before (z): Independent</div>
                <canvas id="beforeTransform" width="150" height="150" style="border: 1px solid var(--grid); border-radius: 4px; background: rgba(0,0,0,0.2);"></canvas>
                <div style="font-size: 10px; color: var(--muted); margin-top: 4px;">Circular cloud (dims 0,2)</div>
              </div>
              <div style="font-size: 24px; color: var(--accent);">‚Üí</div>
              <div style="text-align: center;">
                <div style="font-size: 12px; color: var(--muted); margin-bottom: 8px;">After (x): Correlated</div>
                <canvas id="afterTransform" width="150" height="150" style="border: 1px solid var(--grid); border-radius: 4px; background: rgba(0,0,0,0.2);"></canvas>
                <div style="font-size: 10px; color: var(--muted); margin-top: 4px;">Elliptical cloud (sepal len, petal len)</div>
              </div>
            </div>

          <p style="margin: 16px 0 0 0; color: var(--muted); line-height: 1.7; font-size: 16px;">
            Each draw produces a full 4D <a href="https://en.wikipedia.org/wiki/Sample_(statistics)" style="color: var(--accent); text-decoration: none;">sample</a> with the correct correlations. <a href="https://en.wikipedia.org/wiki/Sampling_(statistics)" style="color: var(--accent); text-decoration: none;">Sampling</a> dimensions independently would create unrealistic flowers (e.g., tiny petals on huge sepals). The L transform enforces the natural relationships between measurements that real flowers exhibit.
          </p>
    </div>
  </div>

  <div style="border: 1px solid var(--grid); border-radius: 4px; padding: 8px; margin: 8px; margin-top: 0;">
    <div style="display: flex; align-items: center; gap: 12px; margin-bottom: 8px;">
      <div class="legend" id="flowerLegend" style="margin-bottom: 0; flex: 1; justify-content: center;">
        <div class="legend-item">
          <div class="flower-icon" id="flower-0" style="color: #ff6b6b;">
            <div class="sepal"></div>
            <div class="petal"></div>
            <div class="petal"></div>
            <div class="petal"></div>
            <div class="petal"></div>
          </div>
          <span>Setosa</span>
        </div>
        <div class="legend-item">
          <div class="flower-icon" id="flower-1" style="color: #4ecdc4;">
            <div class="sepal"></div>
            <div class="petal"></div>
            <div class="petal"></div>
            <div class="petal"></div>
            <div class="petal"></div>
          </div>
          <span>Versicolor</span>
        </div>
        <div class="legend-item">
          <div class="flower-icon" id="flower-2" style="color: #ffe66d;">
            <div class="sepal"></div>
            <div class="petal"></div>
            <div class="petal"></div>
            <div class="petal"></div>
            <div class="petal"></div>
          </div>
          <span>Virginica</span>
        </div>
      </div>
      <button id="flowerInfoBtn" style="font-size: 10px; padding: 3px 8px; color: var(--muted); background: transparent; border: 1px solid var(--grid); border-radius: 3px; cursor: pointer;">info</button>
    </div>

    <div id="flowerInfo" style="display: none; background: rgba(88, 166, 255, 0.08); border-radius: 4px; padding: 12px; font-size: 12px; line-height: 1.6; color: var(--text);">
    <div style="margin-bottom: 12px; font-size: 15px; line-height: 1.8; color: var(--text);">
      The genetics behind the formation of <a href="https://en.wikipedia.org/wiki/Petal" style="color: var(--accent); text-decoration: none;">petals</a>, in accordance with the <a href="https://en.wikipedia.org/wiki/ABC_model_of_flower_development" style="color: var(--accent); text-decoration: none;">ABC model</a> of flower development, are that sepals, petals, stamens, and carpels are modified versions of each other. It appears that the mechanisms to form petals evolved very few times (perhaps only once), rather than evolving repeatedly from stamens.
    </div>
    <div style="text-align: center; margin-bottom: 16px;">
      <img src="ABC_Model.svg" alt="ABC Model of Flower Development" style="max-width: 60%; height: auto; border: 1px solid var(--grid); border-radius: 4px; background: transparent; mix-blend-mode: lighten; display: block; margin: 0 auto;">
    </div>
    <div style="margin-bottom: 12px; font-size: 15px; line-height: 1.8; color: var(--text);">
      This biological hierarchy mirrors our <a href="https://en.wikipedia.org/wiki/Mixture_model" style="color: var(--accent); text-decoration: none;">Gaussian Mixture Model</a>: just as discrete <a href="https://en.wikipedia.org/wiki/Gene_expression" style="color: var(--accent); text-decoration: none;">gene combinations</a> in the ABC model unfold into continuous petal morphology, our GMM maps a discrete 3-class latent variable (species <a href="https://en.wikipedia.org/wiki/Genotype" style="color: var(--accent); text-decoration: none;">"genotype"</a>) to continuous 4D trait measurements (the observable <a href="https://en.wikipedia.org/wiki/Phenotype" style="color: var(--accent); text-decoration: none;">"phenotype"</a>). Both capture how low-dimensional genetic code generates high-dimensional observable features through a hierarchical developmental process.
    </div>
    <div style="text-align: right; margin-top: 8px; display: flex; gap: 8px; justify-content: flex-end;">
      <a href="#" id="showFlowerTuner" style="color: var(--muted); text-decoration: none; font-size: 10px; border: 1px solid var(--grid); padding: 3px 8px; border-radius: 3px; display: inline-block;">üîß flower tuner</a>
      <a href="#" id="showSliderStyles" style="color: var(--muted); text-decoration: none; font-size: 10px; border: 1px solid var(--grid); padding: 3px 8px; border-radius: 3px; display: inline-block;">‚öô slider styles</a>
    </div>
    </div>
  </div>

  <!-- Scatter Plots Section with Border and Controls -->
  <div style="border: 1px solid var(--grid); border-radius: 4px; padding: 12px; margin: 8px;">
    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 12px;">
      <h3 style="margin: 0; font-size: 13px; color: var(--text);">Feature Scatter Plots</h3>
      <div style="display: flex; gap: 8px;">
        <button id="toggleEllipses" style="font-size: 10px; padding: 3px 8px; color: var(--muted); background: transparent; border: 1px solid var(--grid); border-radius: 3px; cursor: pointer; min-width: 60px; white-space: nowrap;">Ellipse</button>
        <button id="scatterInfoBtn" style="font-size: 10px; padding: 3px 8px; color: var(--muted); background: transparent; border: 1px solid var(--grid); border-radius: 3px; cursor: pointer; white-space: nowrap;">info</button>
      </div>
    </div>

    <div id="scatterInfoPanel" style="display: none; background: linear-gradient(135deg, rgba(88, 166, 255, 0.06) 0%, rgba(78, 205, 196, 0.06) 100%); border-radius: 6px; padding: 16px; margin-bottom: 12px; font-size: 14px; line-height: 1.7; color: var(--text); border: 1px solid rgba(88, 166, 255, 0.2); max-height: 80vh; overflow-y: auto;">

      <!-- Header -->
      <div style="display: flex; align-items: center; gap: 8px; margin-bottom: 16px; padding-bottom: 10px; border-bottom: 2px solid rgba(88, 166, 255, 0.3);">
        <strong style="color: var(--accent); font-size: 18px; letter-spacing: 0.5px;">How Ellipses are Calculated</strong>
      </div>

      <!-- Two Column Layout -->
      <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap: 18px; margin-bottom: 16px;">

        <!-- Left Column: Process -->
        <div>
          <div style="margin-bottom: 14px; padding: 12px; background: rgba(0, 0, 0, 0.2); border-radius: 5px;">
            <p style="margin: 0; color: var(--muted); font-size: 14px; line-height: 1.7;">
              The <a href="https://en.wikipedia.org/wiki/Ellipse" style="color: var(--accent); text-decoration: none; font-weight: 600;">ellipses</a> are computed <strong style="color: var(--text);">from the actual generated points</strong> using the <strong style="color: var(--text);">empirical approach</strong>.
            </p>
          </div>

          <!-- Process Steps -->
          <div style="display: grid; gap: 10px;">
            <div style="display: flex; gap: 10px; padding: 10px 12px; background: rgba(255, 255, 255, 0.03); border-radius: 4px;">
              <div style="color: #ff6b6b; font-weight: bold; min-width: 28px; font-size: 16px;">1.</div>
              <div style="flex: 1; color: var(--muted); font-size: 14px; line-height: 1.6;">
                Calculate <a href="https://en.wikipedia.org/wiki/Covariance_matrix" style="color: var(--accent); text-decoration: none; font-weight: 600;">covariance matrix</a> and mean from points
              </div>
            </div>
          </div>

          <!-- Formulas -->
          <div style="margin-top: 14px;">
            <div style="margin-bottom: 10px; padding: 10px; background: rgba(255, 107, 107, 0.08); border-radius: 4px;">
              <div style="color: #ff6b6b; font-weight: bold; font-size: 13px; margin-bottom: 6px; letter-spacing: 0.5px;">MEAN VECTOR</div>
              <div class="katex-formula" style="font-size: 20px; color: #f5f5f0; padding: 8px; background: rgba(0,0,0,0.3); border-radius: 3px; text-align: center;">
                \color{#ffe66d}{\boldsymbol{\mu}} \color{#e8e8e8}{=} \color{#ffe66d}{\begin{bmatrix} \mu_1 \\ \mu_2 \end{bmatrix}} \color{#e8e8e8}{=} \color{#e8e8e8}{\frac{1}{N}} \color{#e8e8e8}{\sum_{i=1}^{N}} \color{#e8e8e8}{\mathbf{x}_i}
              </div>
            </div>

            <div style="margin-bottom: 10px; padding: 10px; background: rgba(78, 205, 196, 0.08); border-radius: 4px;">
              <div style="color: #4ecdc4; font-weight: bold; font-size: 13px; margin-bottom: 6px; letter-spacing: 0.5px;">COVARIANCE MATRIX</div>
              <div class="katex-formula" style="font-size: 20px; color: #f5f5f0; padding: 8px; background: rgba(0,0,0,0.3); border-radius: 3px; text-align: center;">
                \color{#ff6b6b}{\boldsymbol{\Sigma}_{jk}} \color{#e8e8e8}{=} \color{#e8e8e8}{\frac{1}{N}} \color{#e8e8e8}{\sum_{i=1}^{N}} \color{#e8e8e8}{(}x_{i,j} \color{#e8e8e8}{-} \color{#ffe66d}{\mu_j}\color{#e8e8e8}{)(}x_{i,k} \color{#e8e8e8}{-} \color{#ffe66d}{\mu_k}\color{#e8e8e8}{)}
              </div>
            </div>

            <!-- Process Steps (continued) -->
            <div style="display: grid; gap: 10px; margin-top: 14px;">
              <div style="display: flex; gap: 10px; padding: 10px 12px; background: rgba(255, 255, 255, 0.03); border-radius: 4px;">
                <div style="color: #4ecdc4; font-weight: bold; min-width: 28px; font-size: 16px;">2.</div>
                <div style="flex: 1; color: var(--muted); font-size: 14px; line-height: 1.6;">
                  Apply <a href="https://en.wikipedia.org/wiki/Eigendecomposition_of_a_matrix" style="color: var(--accent); text-decoration: none; font-weight: 600;">eigendecomposition</a> to find principal axes
                </div>
              </div>
            </div>

            <!-- Eigendecomposition -->
            <div style="margin-top: 10px; padding: 10px; background: rgba(78, 205, 196, 0.08); border-radius: 4px;">
              <div class="katex-formula" style="font-size: 20px; color: #f5f5f0; padding: 8px; background: rgba(0,0,0,0.3); border-radius: 3px; text-align: center;">
                \color{#ff6b6b}{\boldsymbol{\Sigma}} \color{#e8e8e8}{=} \color{#e8e8e8}{Q} \color{#e8e8e8}{\Lambda} \color{#e8e8e8}{Q^{\top}}
              </div>
              <div style="font-size: 14px; color: var(--muted); margin-top: 10px; line-height: 1.6;">
                <strong style="color: var(--text);">Eigenvectors</strong> <span style="font-family: 'Courier New', monospace; color: #f5f5f0;">Q = [v‚ÇÅ v‚ÇÇ]</span> give the <strong style="color: var(--text);">principal directions</strong> (ellipse axes rotation).<br>
                <strong style="color: var(--text);">Eigenvalues</strong> <span style="font-family: 'Courier New', monospace; color: #f5f5f0;">Œõ = [Œª‚ÇÅ 0; 0 Œª‚ÇÇ]</span> diagonal matrix of <strong style="color: var(--text);">variances</strong> along those axes (ellipse size).
              </div>
            </div>

            <!-- Full 4x4 Matrix Context -->
            <div style="margin-top: 10px; padding: 10px; background: rgba(255, 230, 109, 0.08); border-radius: 4px;">
              <div style="color: #ffe66d; font-weight: bold; font-size: 13px; margin-bottom: 6px; letter-spacing: 0.5px;">IRIS FULL 4√ó4 COVARIANCE</div>
              <div style="font-size: 12px; color: var(--muted); margin-bottom: 8px; line-height: 1.5;">
                Each scatter plot shows a <strong style="color: var(--text);">2√ó2 slice</strong> of the full 4√ó4 matrix:
              </div>

              <!-- 4x4 Matrix Visualization -->
              <div style="display: flex; justify-content: center; margin: 8px 0;">
                <div style="font-family: 'Courier New', monospace; font-size: 9px; color: var(--text);">
                  <div style="display: grid; grid-template-columns: auto 1fr auto; gap: 3px; align-items: center;">
                    <div style="font-size: 16px; color: var(--muted);">[</div>
                    <div style="display: grid; grid-template-rows: repeat(4, 1fr); gap: 1px;">
                      <div style="display: grid; grid-template-columns: repeat(4, 1fr); gap: 3px;">
                        <div style="padding: 3px 5px; background: rgba(255,107,107,0.3); border-radius: 2px; text-align: center; font-size: 8px;">œÉ¬≤<sub>SL</sub></div>
                        <div style="padding: 3px 5px; background: rgba(78,205,196,0.15); border-radius: 2px; text-align: center; font-size: 8px;">œÅ</div>
                        <div style="padding: 3px 5px; background: rgba(78,205,196,0.15); border-radius: 2px; text-align: center; font-size: 8px;">œÅ</div>
                        <div style="padding: 3px 5px; background: rgba(78,205,196,0.15); border-radius: 2px; text-align: center; font-size: 8px;">œÅ</div>
                      </div>
                      <div style="display: grid; grid-template-columns: repeat(4, 1fr); gap: 3px;">
                        <div style="padding: 3px 5px; background: rgba(78,205,196,0.15); border-radius: 2px; text-align: center; font-size: 8px;">œÅ</div>
                        <div style="padding: 3px 5px; background: rgba(255,107,107,0.3); border-radius: 2px; text-align: center; font-size: 8px;">œÉ¬≤<sub>SW</sub></div>
                        <div style="padding: 3px 5px; background: rgba(78,205,196,0.15); border-radius: 2px; text-align: center; font-size: 8px;">œÅ</div>
                        <div style="padding: 3px 5px; background: rgba(78,205,196,0.15); border-radius: 2px; text-align: center; font-size: 8px;">œÅ</div>
                      </div>
                      <div style="display: grid; grid-template-columns: repeat(4, 1fr); gap: 3px;">
                        <div style="padding: 3px 5px; background: rgba(78,205,196,0.15); border-radius: 2px; text-align: center; font-size: 8px;">œÅ</div>
                        <div style="padding: 3px 5px; background: rgba(78,205,196,0.15); border-radius: 2px; text-align: center; font-size: 8px;">œÅ</div>
                        <div style="padding: 3px 5px; background: rgba(255,107,107,0.3); border-radius: 2px; text-align: center; font-size: 8px;">œÉ¬≤<sub>PL</sub></div>
                        <div style="padding: 3px 5px; background: rgba(78,205,196,0.15); border-radius: 2px; text-align: center; font-size: 8px;">œÅ</div>
                      </div>
                      <div style="display: grid; grid-template-columns: repeat(4, 1fr); gap: 3px;">
                        <div style="padding: 3px 5px; background: rgba(78,205,196,0.15); border-radius: 2px; text-align: center; font-size: 8px;">œÅ</div>
                        <div style="padding: 3px 5px; background: rgba(78,205,196,0.15); border-radius: 2px; text-align: center; font-size: 8px;">œÅ</div>
                        <div style="padding: 3px 5px; background: rgba(78,205,196,0.15); border-radius: 2px; text-align: center; font-size: 8px;">œÅ</div>
                        <div style="padding: 3px 5px; background: rgba(255,107,107,0.3); border-radius: 2px; text-align: center; font-size: 8px;">œÉ¬≤<sub>PW</sub></div>
                      </div>
                    </div>
                    <div style="font-size: 16px; color: var(--muted);">]</div>
                  </div>
                </div>
              </div>

              <div style="font-size: 11px; color: var(--muted); line-height: 1.4; margin-top: 6px;">
                <strong style="color: var(--text);">SL</strong> = Sepal Length,
                <strong style="color: var(--text);">SW</strong> = Sepal Width,<br>
                <strong style="color: var(--text);">PL</strong> = Petal Length,
                <strong style="color: var(--text);">PW</strong> = Petal Width
              </div>
            </div>

            <!-- Step 3: Drawing the Ellipse -->
            <div style="display: grid; gap: 10px; margin-top: 14px;">
              <div style="display: flex; gap: 10px; padding: 10px 12px; background: rgba(255, 255, 255, 0.03); border-radius: 4px;">
                <div style="color: #ffe66d; font-weight: bold; min-width: 28px; font-size: 16px;">3.</div>
                <div style="flex: 1; color: var(--muted); font-size: 14px; line-height: 1.6;">
                  Draw ellipse at <strong style="color: var(--text);">2œÉ (95%)</strong> confidence
                </div>
              </div>
            </div>

            <!-- Ellipse Drawing Explanation -->
            <div style="margin-top: 10px; padding: 10px; background: rgba(255, 230, 109, 0.08); border-radius: 4px;">
              <div style="font-size: 14px; color: var(--muted); line-height: 1.6;">
                The ellipse boundary is parameterized as:<br>
                <div class="katex-formula" style="font-size: 18px; color: #f5f5f0; padding: 8px; background: rgba(0,0,0,0.3); border-radius: 3px; text-align: center; margin: 8px 0;">
                  \color{#e8e8e8}{\mathbf{x}(\theta)} \color{#e8e8e8}{=} \color{#ffe66d}{\boldsymbol{\mu}} \color{#e8e8e8}{+} \color{#e8e8e8}{2} \color{#e8e8e8}{Q} \color{#e8e8e8}{\begin{bmatrix} \sqrt{\lambda_1} & 0 \\ 0 & \sqrt{\lambda_2} \end{bmatrix}} \color{#e8e8e8}{\begin{bmatrix} \cos\theta \\ \sin\theta \end{bmatrix}}
                </div>
                <strong style="color: var(--text); font-size: 15px;">Center</strong>: Mean <span style="font-family: 'Courier New', monospace; color: #ffe66d; font-size: 18px;">Œº = [Œº‚ÇÅ Œº‚ÇÇ]·µÄ</span><br>
                <strong style="color: var(--text); font-size: 15px;">Rotation</strong>: Eigenvector matrix <span style="font-family: 'Courier New', monospace; color: #f5f5f0; font-size: 15px;">Q</span> aligns axes<br>
                <strong style="color: var(--text); font-size: 15px;">Size</strong>: <span style="font-family: 'Courier New', monospace; color: #f5f5f0; font-size: 15px;">2‚àöŒª‚ÇÅ</span> and <span style="font-family: 'Courier New', monospace; color: #f5f5f0; font-size: 15px;">2‚àöŒª‚ÇÇ</span> are semi-axis lengths (2œÉ for 95% coverage)
              </div>
            </div>
          </div>
        </div>

        <!-- Right Column: Worked Example -->
        <div>
          <!-- Worked Example: 95% Confidence -->
          <div style="padding: 12px; background: rgba(255, 230, 109, 0.1); border-radius: 4px; border: 1px solid rgba(255, 230, 109, 0.3);">
            <div style="color: #ffe66d; font-weight: 600; font-size: 16px; margin-bottom: 10px;">Worked Example: 95% Confidence Ellipse</div>

            <div style="font-size: 14px; color: var(--muted); line-height: 1.7;">
              <div style="margin-bottom: 12px;">
                <strong style="color: var(--text); font-size: 15px;">Given:</strong> <span style="font-size: 14px;">Covariance matrix from positive correlation example</span>
                <div class="katex-formula" style="font-size: 18px; color: #f5f5f0; padding: 6px; background: rgba(0,0,0,0.3); border-radius: 3px; text-align: center; margin: 6px 0;">
                  \color{#ff6b6b}{\boldsymbol{\Sigma}} \color{#e8e8e8}{=} \color{#e8e8e8}{\begin{bmatrix} 0.5 & 0.35 \\ 0.35 & 0.5 \end{bmatrix}}
                </div>
              </div>

              <div style="margin-bottom: 12px;">
                <strong style="color: var(--text); font-size: 15px;">Step 1:</strong> <span style="font-size: 14px;">Find eigenvalues Œª from det(Œ£ - ŒªI) = 0</span>
                <div style="font-family: 'Courier New', monospace; font-size: 16px; color: #f5f5f0; margin: 6px 0; padding: 10px; background: rgba(0,0,0,0.2); border-radius: 3px;">
                  Œª‚ÇÅ = 0.85, Œª‚ÇÇ = 0.15
                </div>
              </div>

              <div style="margin-bottom: 12px;">
                <strong style="color: var(--text); font-size: 15px;">Step 2:</strong> <span style="font-size: 14px;">Take square roots for standard deviations (œÉ)</span>
                <div style="font-family: 'Courier New', monospace; font-size: 16px; color: #f5f5f0; margin: 6px 0; padding: 10px; background: rgba(0,0,0,0.2); border-radius: 3px;">
                  œÉ‚ÇÅ = ‚àöŒª‚ÇÅ = 0.92<br>
                  œÉ‚ÇÇ = ‚àöŒª‚ÇÇ = 0.39
                </div>
                <div style="padding: 8px; background: rgba(78, 205, 196, 0.1); border-radius: 3px; margin-top: 6px; font-size: 14px;">
                  <strong style="color: #4ecdc4;">Key relationship:</strong> <span style="color: #f5f5f0;">Eigenvalues Œª are <strong style="color: var(--text);">variances</strong> (œÉ¬≤) along principal axes</span><br>
                  <span style="color: #f5f5f0;">‚àöŒª‚ÇÅ = œÉ‚ÇÅ (standard deviation along first principal axis)</span><br>
                  <span style="color: #f5f5f0;">‚àöŒª‚ÇÇ = œÉ‚ÇÇ (standard deviation along second principal axis)</span>
                </div>
              </div>

              <div style="margin-bottom: 12px;">
                <strong style="color: var(--text); font-size: 15px;">Step 3:</strong> <span style="font-size: 14px;">Multiply by 2 for 95% confidence (2œÉ)</span>
                <div style="font-family: 'Courier New', monospace; font-size: 16px; color: #f5f5f0; margin: 6px 0; padding: 10px; background: rgba(0,0,0,0.2); border-radius: 3px;">
                  Semi-major axis: 2œÉ‚ÇÅ = 2‚àöŒª‚ÇÅ = 1.84<br>
                  Semi-minor axis: 2œÉ‚ÇÇ = 2‚àöŒª‚ÇÇ = 0.78
                </div>
              </div>

              <div style="padding: 10px; background: rgba(255, 230, 109, 0.15); border-radius: 3px; border-left: 3px solid #ffe66d; font-size: 14px;">
                <strong style="color: var(--text);">Result:</strong> The ellipse has axes of length 1.84 and 0.78, covering <strong style="color: #ffe66d;">~95%</strong> of the data points generated from this distribution.
              </div>

              <div style="margin-top: 10px; font-size: 13px; color: var(--muted); font-style: italic;">
                For 1œÉ (68% confidence), multiply by 1 instead of 2: semi-axes would be 0.92 and 0.39
              </div>
            </div>
          </div>
        </div>
      </div>


    </div>

    <div class="viz-container">
      <div class="plot-wrapper">
        <div class="plot-title">Sepal Length vs Sepal Width</div>
        <canvas id="canvas1"></canvas>
      </div>
      <div class="plot-wrapper">
        <div class="plot-title">Petal Length vs Petal Width</div>
        <canvas id="canvas2"></canvas>
      </div>
      <div class="plot-wrapper">
        <div class="plot-title">Sepal Length vs Petal Length</div>
        <canvas id="canvas3"></canvas>
      </div>
      <div class="plot-wrapper">
        <div class="plot-title">Sepal Width vs Petal Width</div>
        <canvas id="canvas4"></canvas>
      </div>
    </div>
  </div>

  <div class="matrix-section">
    <div class="matrix-panel">
      <div class="matrix-title" style="display: flex; justify-content: space-between; align-items: center;">
        <span>Cross-Correlation Matrix (Drag ‚Üï to Adjust Values)</span>
        <div style="display: flex; gap: 6px;">
          <button id="btnResetCorr" style="font-size: 9px; padding: 2px 6px;">Reset</button>
          <button id="corrInfoBtn" style="font-size: 9px; padding: 2px 6px; color: var(--muted); background: transparent; border: 1px solid var(--grid); border-radius: 3px; cursor: pointer;">info</button>
        </div>
      </div>

      <!-- Correlation Info Panel -->
      <div id="corrInfoPanel" style="display: none; background: rgba(88, 166, 255, 0.08); border-radius: 4px; padding: 10px; margin-top: 10px; font-size: 12px; line-height: 1.5; color: var(--text); max-height: 80vh; overflow-y: auto;">
        <div style="margin-bottom: 8px;">
          <strong style="color: #4ecdc4; font-size: 15px;">Interactive: 2√ó2 Submatrix ‚Üí 4√ó4 Full Matrix</strong>
        </div>

        <p style="margin: 6px 0; color: var(--muted); font-size: 12px; line-height: 1.5;">
          Adjust a <strong style="color: var(--text);">2√ó2 submatrix</strong> for two features and see how it affects the <strong style="color: var(--text);">full 4√ó4 covariance matrix</strong> and the generated data.
        </p>

        <!-- Controls and Visualization in responsive layout -->
        <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 8px; margin: 10px 0;">

          <!-- Feature Pair Selector -->
          <div style="padding: 6px; background: rgba(0,0,0,0.2); border-radius: 4px;">
            <div style="font-size: 10px; color: var(--accent); font-weight: 600; margin-bottom: 4px;">SELECT PAIR</div>
            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 3px;">
              <button class="feature-pair-btn" data-pair="0,1" style="font-size: 9px; padding: 3px; background: rgba(255,107,107,0.2); border: 1px solid #ff6b6b; border-radius: 2px; cursor: pointer; color: var(--text);">
                SL√óSW
              </button>
              <button class="feature-pair-btn" data-pair="2,3" style="font-size: 9px; padding: 3px; background: rgba(78,205,196,0.2); border: 1px solid #4ecdc4; border-radius: 2px; cursor: pointer; color: var(--text);">
                PL√óPW
              </button>
              <button class="feature-pair-btn" data-pair="0,2" style="font-size: 9px; padding: 3px; background: rgba(255,230,109,0.2); border: 1px solid #ffe66d; border-radius: 2px; cursor: pointer; color: var(--text);">
                SL√óPL
              </button>
              <button class="feature-pair-btn" data-pair="1,3" style="font-size: 9px; padding: 3px; background: rgba(138,180,248,0.2); border: 1px solid #8ab4f8; border-radius: 2px; cursor: pointer; color: var(--text);">
                SW√óPW
              </button>
              <button class="feature-pair-btn" data-pair="0,3" style="font-size: 9px; padding: 3px; background: rgba(186,104,200,0.2); border: 1px solid #ba68c8; border-radius: 2px; cursor: pointer; color: var(--text);">
                SL√óPW
              </button>
              <button class="feature-pair-btn" data-pair="1,2" style="font-size: 9px; padding: 3px; background: rgba(255,152,0,0.2); border: 1px solid #ff9800; border-radius: 2px; cursor: pointer; color: var(--text);">
                SW√óPL
              </button>
            </div>
          </div>

          <!-- 2x2 Submatrix Controls -->
          <div style="padding: 6px; background: rgba(0,0,0,0.2); border-radius: 4px;">
            <div style="font-size: 10px; color: var(--accent); font-weight: 600; margin-bottom: 4px;">ADJUST VALUES</div>

            <!-- Variance sliders -->
            <div style="margin-bottom: 3px;">
              <label style="display: flex; align-items: center; gap: 4px; font-size: 9px;">
                <span style="color: var(--text); min-width: 45px;">Var X:</span>
                <input type="range" id="submatrixVarX" min="0.1" max="1.0" step="0.05" value="0.5" style="flex: 1;">
                <span id="submatrixVarXValue" style="color: var(--text); min-width: 28px; text-align: right;">0.50</span>
              </label>
            </div>

            <div style="margin-bottom: 3px;">
              <label style="display: flex; align-items: center; gap: 4px; font-size: 9px;">
                <span style="color: var(--text); min-width: 45px;">Var Y:</span>
                <input type="range" id="submatrixVarY" min="0.1" max="1.0" step="0.05" value="0.5" style="flex: 1;">
                <span id="submatrixVarYValue" style="color: var(--text); min-width: 28px; text-align: right;">0.50</span>
              </label>
            </div>

            <div style="margin-bottom: 4px;">
              <label style="display: flex; align-items: center; gap: 4px; font-size: 9px;">
                <span style="color: var(--text); min-width: 45px;">Cov:</span>
                <input type="range" id="submatrixCov" min="-0.4" max="0.4" step="0.05" value="0" style="flex: 1;">
                <span id="submatrixCovValue" style="color: var(--text); min-width: 28px; text-align: right;">0.00</span>
              </label>
            </div>

            <div style="display: flex; gap: 3px; align-items: center; justify-content: center;">
              <button id="liveUpdateBtn" style="font-size: 8px; padding: 2px 6px; background: transparent; border: 1px solid var(--grid); border-radius: 2px; cursor: pointer; color: var(--muted); transition: all 0.2s;">
                Live
              </button>
              <button id="applySubmatrix" style="font-size: 8px; padding: 2px 6px; background: transparent; border: 1px solid #4ecdc4; border-radius: 2px; cursor: pointer; color: #4ecdc4;">
                Apply
              </button>
              <button id="resetSubmatrix" style="font-size: 8px; padding: 2px 6px; background: transparent; border: 1px solid var(--grid); border-radius: 2px; cursor: pointer; color: var(--muted);">
                Reset
              </button>
            </div>
          </div>

        </div>

        <!-- Matrix Visualization - Below the controls -->
        <div style="padding: 8px; background: rgba(0,0,0,0.2); border-radius: 4px; margin-top: 8px;">
          <div style="font-size: 10px; color: var(--accent); font-weight: 600; margin-bottom: 6px; text-align: center;">MATRICES</div>
          <div style="display: flex; gap: 10px; justify-content: center; align-items: center; flex-wrap: wrap;">
            <!-- Matrices -->
            <div style="display: flex; gap: 10px; align-items: center;">
              <div>
                <div style="font-size: 8px; color: var(--muted); margin-bottom: 2px; text-align: center;">2√ó2</div>
                <div id="submatrixDisplay" style="font-family: 'Courier New', monospace; font-size: 10px; color: var(--text);"></div>
              </div>
              <div style="color: var(--muted); font-size: 16px;">‚Üí</div>
              <div>
                <div style="font-size: 8px; color: var(--muted); margin-bottom: 2px; text-align: center;">4√ó4</div>
                <div id="fullmatrixDisplay" style="font-family: 'Courier New', monospace; font-size: 8px; color: var(--text);"></div>
              </div>
              <div style="color: var(--muted); font-size: 16px;">‚Üí</div>
            </div>

            <!-- Canvas and Tech Data grouped together -->
            <div style="display: flex; gap: 4px; align-items: center;">
              <canvas id="submatrixPreviewCanvas" width="280" height="280" style="width: 140px; height: 140px; background: rgba(0,0,0,0.3); border-radius: 3px; border: 1px solid rgba(255,255,255,0.1);"></canvas>

              <!-- Technical Data -->
              <div style="font-family: 'Courier New', monospace; font-size: 11px; color: var(--text); line-height: 1.7; background: rgba(0,0,0,0.5); padding: 8px; border-radius: 3px;">
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 8px;">
                  <div>
                    <div style="margin-bottom: 5px;">
                      <span style="color: #4ecdc4;">Œª‚ÇÅ:</span> <span id="techLambda1">--</span>
                    </div>
                    <div style="margin-bottom: 5px;">
                      <span style="color: #4ecdc4;">Œª‚ÇÇ:</span> <span id="techLambda2">--</span>
                    </div>
                    <div style="margin-bottom: 5px;">
                      <span style="color: #ffe66d;">Œ∏:</span> <span id="techAngle">--</span>¬∞
                    </div>
                    <div style="margin-bottom: 5px;">
                      <span style="color: #ffe66d;">rx:</span> <span id="techRx">--</span>
                    </div>
                    <div>
                      <span style="color: #ffe66d;">ry:</span> <span id="techRy">--</span>
                    </div>
                  </div>
                  <div>
                    <div style="margin-bottom: 5px;">
                      <span style="color: #ff6b6b;">det:</span> <span id="techDet">--</span>
                    </div>
                    <div style="margin-bottom: 5px;">
                      <span style="color: #ff6b6b;">tr:</span> <span id="techTrace">--</span>
                    </div>
                    <div style="margin-bottom: 5px;">
                      <span style="color: #8ab4f8;">œÅ:</span> <span id="techCorr">--</span>
                    </div>
                    <div>
                      <span style="color: #8ab4f8;">ok:</span> <span id="techValid">--</span>
                    </div>
                  </div>
                </div>
              </div>
            </div>
          </div>
        </div>

        <div style="margin-top: 6px; padding: 5px 6px; background: rgba(255,230,109,0.1); border-radius: 3px; font-size: 10px; color: var(--muted); text-align: center;">
          üí° Changes to the submatrix update the corresponding cells in the full 4√ó4 matrix
        </div>
      </div>

      <div id="corrMatrix" class="corr-matrix"></div>

      <div style="margin: 12px 0 0 0; padding: 10px; background: rgba(88, 166, 255, 0.05); border-radius: 6px; border-left: 3px solid var(--accent);">
        <div style="font-size: 11px; font-weight: 700; margin-bottom: 6px; color: var(--accent);">Interactive Examples - Click to Set Correlation Matrix:</div>
        <div style="display: flex; gap: 6px; flex-wrap: wrap;">
          <button id="btnWeakCorr" style="padding: 5px 10px; font-size: 10px; font-weight: 600;">Weak</button>
          <button id="btnStrongCorr" style="padding: 5px 10px; font-size: 10px; font-weight: 600;">Strong</button>
          <button id="btnUncorrelated" style="padding: 5px 10px; font-size: 10px; font-weight: 600;">Uncorrelated</button>
          <button id="btnTight" style="padding: 5px 10px; font-size: 10px; font-weight: 600;">Tight</button>
          <button id="btnSingular" style="padding: 5px 10px; font-size: 10px; font-weight: 600;">Singular</button>
        </div>
      </div>
    </div>
    <div class="matrix-panel">
      <div class="matrix-title"><a href="https://en.wikipedia.org/wiki/Mixture_model#Gaussian_mixture_model" style="color: var(--accent2); text-decoration: none;">Gaussian Mixture Model</a> Parameters</div>
      <div id="gmmParams" class="gmm-container"></div>
    </div>
  </div>

  <div class="equation-panel compact" id="equationPanel">
    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 12px;">
      <div class="equation-title" style="margin: 0;"><a href="https://en.wikipedia.org/wiki/Multivariate_normal_distribution" style="color: var(--accent2); text-decoration: none;">Multivariate Gaussian</a> as <a href="https://en.wikipedia.org/wiki/Matrix_exponential" style="color: var(--accent2); text-decoration: none;">Matrix Exponential</a></div>
      <button id="btnToggleEquation" style="padding: 3px 8px; font-size: 10px; color: var(--muted); background: transparent; border: 1px solid var(--grid); border-radius: 3px; cursor: pointer; white-space: nowrap;">info</button>
    </div>
    <div id="gmmEquation" class="equation"></div>
  </div>

<!-- Wikipedia Sidebar -->
<div id="wikiBackdrop" class="wiki-backdrop"></div>
<div id="wikiSidebar" class="wiki-sidebar">
  <div class="wiki-header">
    <button id="wikiBack" class="wiki-back" aria-label="Go back" style="display: none;">‚Üê</button>
    <h3 id="wikiTitle" class="wiki-title">Wikipedia</h3>
    <button id="wikiClose" class="wiki-close" aria-label="Close sidebar">&times;</button>
  </div>
  <div id="wikiContent" class="wiki-content">
    <div id="wikiLoading" class="wiki-loading">
      <div class="wiki-spinner"></div>
      <p>Loading...</p>
    </div>
    <div id="wikiBody" class="wiki-body"></div>
  </div>
  <div id="wikiFooter" class="wiki-footer">
    <a id="wikiLink" href="#" target="_blank" rel="noopener noreferrer">Read more on Wikipedia ‚Üí</a>
  </div>
</div>

<script>
  // Global tuning parameters - set immediately
  window.flowerTuning = {
    petalBaseRadius: 1.5,    // Where petals attach/start (over sepal)
    petalLengthScale: 2.0,   // Scale all petal lengths
    petalWidthScale: 2.4,    // Scale all petal widths
    setosaGain: 2.0,         // Extra scale for Setosa only
    sepalSizeMin: 5,
    sepalSizeRange: 1.5,
    sepalRoundness: 20,      // 0-50% border-radius (50 = circle)
    sepalGreen: '#11df11',
    labelSpacing: 30,        // Gap between flower labels in legend (px)
    interFlowerLabelSpacing: 7  // Gap between flower icon and text label (px)
  };
  console.log('üå∏ Flower tuning available:', window.flowerTuning);

  // Gaussian RNG (<a href="https://en.wikipedia.org/wiki/Box%E2%80%93Muller_transform" style="color: var(--accent); text-decoration: none;">Box-Muller transform</a>)
  let _gaussSpare = null;
  function gaussianRandom() {
    if (_gaussSpare !== null) {
      const v = _gaussSpare;
      _gaussSpare = null;
      return v;
    }
    let u = 0, v = 0;
    while (u === 0) u = Math.random();
    while (v === 0) v = Math.random();
    const mag = Math.sqrt(-2.0 * Math.log(u));
    const z0 = mag * Math.cos(2 * Math.PI * v);
    const z1 = mag * Math.sin(2 * Math.PI * v);
    _gaussSpare = z1;
    return z0;
  }

  // GMM Configuration
  const gmmConfig = {
    centers: [
      [5.0, 3.4, 1.5, 0.2], // setosa
      [6.0, 2.8, 4.5, 1.3], // versicolor
      [6.7, 3.1, 5.5, 2.1]  // virginica
    ],
    baseSpreads: [
      [0.2, 0.2, 0.2, 0.05],
      [0.4, 0.3, 0.4, 0.2],
      [0.5, 0.3, 0.6, 0.25]
    ],
    spreads: [
      [0.2, 0.2, 0.2, 0.05],
      [0.4, 0.3, 0.4, 0.2],
      [0.5, 0.3, 0.6, 0.25]
    ],
    nPerClass: 50,
    spreadMultiplier: 1.0,
    separationMultiplier: 1.0,
    ellipseAxisScale: 1.0,
    correlationStrength: 0.0  // Global correlation strength: -1 to 1
  };

  // Update spreads based on multiplier
  function updateSpreads() {
    for (let c = 0; c < 3; c++) {
      for (let d = 0; d < 4; d++) {
        gmmConfig.spreads[c][d] = gmmConfig.baseSpreads[c][d] * gmmConfig.spreadMultiplier;
      }
    }
  }

  // Cholesky decomposition for generating correlated data
  function choleskyDecomposition(matrix) {
    const n = matrix.length;
    const L = Array(n).fill(0).map(() => Array(n).fill(0));

    for (let i = 0; i < n; i++) {
      for (let j = 0; j <= i; j++) {
        let sum = 0;
        for (let k = 0; k < j; k++) {
          sum += L[i][k] * L[j][k];
        }
        if (i === j) {
          const val = matrix[i][i] - sum;
          L[i][j] = val > 0 ? Math.sqrt(val) : 0.01; // Safeguard
        } else {
          L[i][j] = (matrix[i][j] - sum) / (L[j][j] || 0.01);
        }
      }
    }
    return L;
  }

  // Generate correlated samples using Cholesky decomposition
  function generateCorrelatedSamples(n, corrMatrix) {
    const L = choleskyDecomposition(corrMatrix);
    const samples = [];

    for (let i = 0; i < n; i++) {
      const z = [gaussianRandom(), gaussianRandom(), gaussianRandom(), gaussianRandom()];
      const x = [0, 0, 0, 0];

      // Matrix multiplication: x = L * z
      for (let row = 0; row < 4; row++) {
        for (let col = 0; col < 4; col++) {
          x[row] += L[row][col] * z[col];
        }
      }
      samples.push(x);
    }
    return samples;
  }

  // Create correlation matrix from correlation strength
  function createCorrelationMatrix(strength) {
    // Create 4x4 correlation matrix with uniform off-diagonal correlation
    const matrix = [
      [1.0, strength, strength, strength],
      [strength, 1.0, strength, strength],
      [strength, strength, 1.0, strength],
      [strength, strength, strength, 1.0]
    ];
    return matrix;
  }

  // Generate synthetic Iris data using GMM
  function generateData(customCorrMatrix = null) {
    const data = [];

    // Calculate global mean across all class centers for separation scaling
    const globalMean = [0, 0, 0, 0];
    for (let d = 0; d < 4; d++) {
      globalMean[d] = (gmmConfig.centers[0][d] + gmmConfig.centers[1][d] + gmmConfig.centers[2][d]) / 3;
    }

    for (let c = 0; c < 3; c++) {
      let classSamples;

      // Determine which correlation matrix to use
      let corrMatrix = customCorrMatrix;
      if (!corrMatrix && Math.abs(gmmConfig.correlationStrength) > 0.01) {
        corrMatrix = createCorrelationMatrix(gmmConfig.correlationStrength);
      }

      if (corrMatrix) {
        // Generate correlated samples
        classSamples = generateCorrelatedSamples(gmmConfig.nPerClass, corrMatrix);
      } else {
        // Generate independent samples
        classSamples = [];
        for (let n = 0; n < gmmConfig.nPerClass; n++) {
          classSamples.push([
            gaussianRandom(),
            gaussianRandom(),
            gaussianRandom(),
            gaussianRandom()
          ]);
        }
      }

      // Scale and shift to match GMM parameters
      for (const sample of classSamples) {
        const point = [];
        for (let d = 0; d < 4; d++) {
          // Apply separation scaling: move centers toward/away from global mean
          const scaledCenter = globalMean[d] + (gmmConfig.centers[c][d] - globalMean[d]) * gmmConfig.separationMultiplier;
          const val = scaledCenter + gmmConfig.spreads[c][d] * sample[d];
          point.push(val);
        }
        data.push({ features: point, class: c });
      }
    }
    return data;
  }

  // Compute correlation matrix
  function computeCorrelationMatrix(data) {
    const n = data.length;
    const dims = 4;

    // Compute means
    const means = new Array(dims).fill(0);
    for (const d of data) {
      for (let i = 0; i < dims; i++) {
        means[i] += d.features[i];
      }
    }
    for (let i = 0; i < dims; i++) {
      means[i] /= n;
    }

    // Compute covariance matrix
    const cov = Array(dims).fill(0).map(() => Array(dims).fill(0));
    for (const d of data) {
      for (let i = 0; i < dims; i++) {
        for (let j = 0; j < dims; j++) {
          cov[i][j] += (d.features[i] - means[i]) * (d.features[j] - means[j]);
        }
      }
    }

    // Normalize to correlation
    const corr = Array(dims).fill(0).map(() => Array(dims).fill(0));
    for (let i = 0; i < dims; i++) {
      for (let j = 0; j < dims; j++) {
        const stdI = Math.sqrt(cov[i][i] / n);
        const stdJ = Math.sqrt(cov[j][j] / n);
        corr[i][j] = cov[i][j] / (n * stdI * stdJ);
      }
    }

    return corr;
  }

  // Adjustable correlation matrix state
  const adjustState = {
    element: null,
    row: -1,
    col: -1,
    startY: 0,
    startValue: 0,
    updatePending: false
  };

  // Make correlation value adjustable
  function makeAdjustable(element, row, col, currentValue) {
    element.addEventListener('mousedown', (e) => {
      adjustState.element = element;
      adjustState.row = row;
      adjustState.col = col;
      adjustState.startY = e.clientY;
      adjustState.startValue = currentValue;
      element.classList.add('adjusting');
      e.preventDefault();
    });
  }

  // Store current correlation matrix for editing
  let editableCorr = null;

  // Render simple correlation matrix grid
  function renderCorrelationMatrix(data) {
    // Use editableCorr if it's set, otherwise compute from data
    let corr;
    if (editableCorr) {
      corr = editableCorr;
    } else {
      corr = computeCorrelationMatrix(data);
      editableCorr = corr.map(row => [...row]); // Deep copy
    }

    const labels = ['SepL', 'SepW', 'PetL', 'PetW'];
    const container = document.getElementById('corrMatrix');
    container.innerHTML = '';

    // Header row
    const emptyCell = document.createElement('div');
    emptyCell.className = 'corr-cell corr-header';
    emptyCell.textContent = 'œÅ';
    container.appendChild(emptyCell);

    for (const label of labels) {
      const cell = document.createElement('div');
      cell.className = 'corr-cell corr-header';
      cell.textContent = label;
      container.appendChild(cell);
    }

    // Data rows
    for (let i = 0; i < 4; i++) {
      const rowLabel = document.createElement('div');
      rowLabel.className = 'corr-cell corr-header';
      rowLabel.textContent = labels[i];
      container.appendChild(rowLabel);

      for (let j = 0; j < 4; j++) {
        const cell = document.createElement('div');
        cell.className = 'corr-cell corr-value';
        const val = editableCorr[i][j];
        cell.textContent = val.toFixed(2);
        cell.dataset.row = i;
        cell.dataset.col = j;

        // Color coding based on correlation strength
        const absVal = Math.abs(val);
        const hue = val > 0 ? 210 : 0; // blue for positive, red for negative
        const alpha = absVal * 0.7;
        cell.style.background = `hsla(${hue}, 80%, 55%, ${alpha})`;

        // Make adjustable (except diagonal which is always 1)
        if (i !== j) {
          makeAdjustable(cell, i, j, val);
        } else {
          cell.style.cursor = 'default';
          cell.style.opacity = '0.7';
        }

        container.appendChild(cell);
      }
    }
  }

  // Update all visualizations (throttled with requestAnimationFrame)
  function updateAllVisualizations() {
    if (!adjustState.updatePending) return;
    adjustState.updatePending = false;

    // REAL-TIME UPDATE: Regenerate data with new correlation matrix
    currentData = generateData(editableCorr);

    // Show indicator that we're using custom correlation
    document.getElementById('corrModeIndicator').style.display = 'inline';

    // Update all visualizations
    projections.forEach((proj, i) => {
      drawScatter(canvases[i], currentData, proj[0], proj[1]);
    });
    renderGMMParams(currentData);
    renderGaussianEquation(currentData);

    // Notify parent window if we're in an iframe
    if (window.parent !== window) {
      window.parent.postMessage({
        type: 'dataRegenerated',
        data: currentData
      }, '*');
    }
  }

  // Handle mouse movement for adjusting values
  document.addEventListener('mousemove', (e) => {
    if (!adjustState.element) return;

    const deltaY = adjustState.startY - e.clientY; // Inverted: drag up increases
    const sensitivity = 0.005;
    let newValue = adjustState.startValue + (deltaY * sensitivity);

    // Clamp to [-1, 1]
    newValue = Math.max(-1, Math.min(1, newValue));

    // Update the editable correlation matrix
    editableCorr[adjustState.row][adjustState.col] = newValue;
    editableCorr[adjustState.col][adjustState.row] = newValue; // Keep symmetric

    // Update display
    adjustState.element.textContent = newValue.toFixed(2);

    // Update color
    const absVal = Math.abs(newValue);
    const hue = newValue > 0 ? 210 : 0;
    const alpha = absVal * 0.7;
    adjustState.element.style.background = `hsla(${hue}, 80%, 55%, ${alpha})`;

    // Update symmetric cell
    const symCell = document.querySelector(`[data-row="${adjustState.col}"][data-col="${adjustState.row}"]`);
    if (symCell) {
      symCell.textContent = newValue.toFixed(2);
      symCell.style.background = `hsla(${hue}, 80%, 55%, ${alpha})`;
    }

    // Schedule visualization update (throttled)
    if (!adjustState.updatePending) {
      adjustState.updatePending = true;
      requestAnimationFrame(updateAllVisualizations);
    }
  });

  // Handle mouse up for adjusting
  document.addEventListener('mouseup', () => {
    if (adjustState.element) {
      adjustState.element.classList.remove('adjusting');
      adjustState.element = null;
    }
  });

  // Gaussian PDF function
  function gaussianPDF(x, mu, sigma) {
    const coefficient = 1 / (sigma * Math.sqrt(2 * Math.PI));
    const exponent = -Math.pow(x - mu, 2) / (2 * Math.pow(sigma, 2));
    return coefficient * Math.exp(exponent);
  }

  // Compute actual statistics from data for a feature and class
  function computeFeatureStats(data, classIdx, featureIdx) {
    const classData = data.filter(d => d.class === classIdx);
    const values = classData.map(d => d.features[featureIdx]);

    const n = values.length;
    const mean = values.reduce((a, b) => a + b, 0) / n;
    const variance = values.reduce((a, v) => a + Math.pow(v - mean, 2), 0) / n;
    const std = Math.sqrt(variance);

    return { mean, std };
  }

  // Draw Gaussian curve on canvas using actual data statistics
  function drawGaussianCurve(canvas, data, featureIdx) {
    const ctx = canvas.getContext('2d');
    const rect = canvas.getBoundingClientRect();
    const dpr = window.devicePixelRatio || 1;

    canvas.width = rect.width * dpr;
    canvas.height = rect.height * dpr;
    ctx.scale(dpr, dpr);

    const w = rect.width;
    const h = rect.height;
    const pad = 10;

    // Clear
    ctx.fillStyle = '#0d1117';
    ctx.fillRect(0, 0, w, h);

    const colors = ['#ff6b6b', '#4ecdc4', '#ffe66d'];
    const classNames = ['Setosa', 'Versicolor', 'Virginica'];

    // Compute actual stats from data
    const stats = [];
    for (let c = 0; c < 3; c++) {
      stats.push(computeFeatureStats(data, c, featureIdx));
    }

    // Find global min/max for this feature across all classes
    let minX = Infinity, maxX = -Infinity;
    for (let c = 0; c < 3; c++) {
      const { mean, std } = stats[c];
      minX = Math.min(minX, mean - 3 * std);
      maxX = Math.max(maxX, mean + 3 * std);
    }

    // Draw all three curves
    let maxY = 0;
    const curves = [];
    for (let c = 0; c < 3; c++) {
      const { mean, std } = stats[c];
      const curve = [];

      for (let i = 0; i <= 100; i++) {
        const x = minX + (i / 100) * (maxX - minX);
        const y = gaussianPDF(x, mean, std);
        curve.push({ x, y });
        maxY = Math.max(maxY, y);
      }
      curves.push({ curve, mean, std });
    }

    // Draw curves
    for (let c = 0; c < 3; c++) {
      const { curve, mean, std } = curves[c];

      // Draw curve
      ctx.strokeStyle = colors[c];
      ctx.lineWidth = 1.5;
      ctx.beginPath();

      for (let i = 0; i < curve.length; i++) {
        const px = pad + ((curve[i].x - minX) / (maxX - minX)) * (w - 2 * pad);
        const py = h - pad - (curve[i].y / maxY) * (h - 2 * pad);

        if (i === 0) ctx.moveTo(px, py);
        else ctx.lineTo(px, py);
      }
      ctx.stroke();

      // Draw mean marker
      const muX = pad + ((mean - minX) / (maxX - minX)) * (w - 2 * pad);
      ctx.strokeStyle = colors[c];
      ctx.lineWidth = 1;
      ctx.setLineDash([3, 2]);
      ctx.beginPath();
      ctx.moveTo(muX, h - pad);
      ctx.lineTo(muX, pad);
      ctx.stroke();
      ctx.setLineDash([]);

      // Label mean and std
      ctx.fillStyle = colors[c];
      ctx.font = '8px monospace';
      ctx.textAlign = 'center';
      ctx.fillText(`Œº=${mean.toFixed(2)}`, muX, h - 2);
      ctx.fillText(`œÉ=${std.toFixed(2)}`, muX, 10);
    }

    // Draw axes
    ctx.strokeStyle = '#30363d';
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(pad, h - pad);
    ctx.lineTo(w - pad, h - pad);
    ctx.stroke();
  }

  // Compute matrix power for Taylor series
  function matrixPower(matrix, power) {
    if (power === 0) {
      // Return identity matrix
      const n = matrix.length;
      const I = Array(n).fill(0).map(() => Array(n).fill(0));
      for (let i = 0; i < n; i++) I[i][i] = 1;
      return I;
    }
    if (power === 1) return matrix;

    // For power >= 2, do repeated matrix multiplication
    let result = matrix;
    for (let p = 1; p < power; p++) {
      const temp = Array(matrix.length).fill(0).map(() => Array(matrix.length).fill(0));
      for (let i = 0; i < matrix.length; i++) {
        for (let j = 0; j < matrix.length; j++) {
          for (let k = 0; k < matrix.length; k++) {
            temp[i][j] += result[i][k] * matrix[k][j];
          }
        }
      }
      result = temp;
    }
    return result;
  }

  // Invert a 4x4 matrix using Gauss-Jordan elimination
  function invert4x4(m) {
    // Create augmented matrix [A | I]
    const aug = m.map((row, i) => [
      ...row,
      i === 0 ? 1 : 0,
      i === 1 ? 1 : 0,
      i === 2 ? 1 : 0,
      i === 3 ? 1 : 0
    ]);

    // Gauss-Jordan elimination
    for (let i = 0; i < 4; i++) {
      // Find pivot
      let maxRow = i;
      for (let k = i + 1; k < 4; k++) {
        if (Math.abs(aug[k][i]) > Math.abs(aug[maxRow][i])) {
          maxRow = k;
        }
      }
      [aug[i], aug[maxRow]] = [aug[maxRow], aug[i]];

      // Make diagonal 1
      const pivot = aug[i][i];
      if (Math.abs(pivot) < 1e-10) {
        console.error('Matrix is singular');
        return m; // Return original if singular
      }
      for (let j = 0; j < 8; j++) {
        aug[i][j] /= pivot;
      }

      // Eliminate column
      for (let k = 0; k < 4; k++) {
        if (k !== i) {
          const factor = aug[k][i];
          for (let j = 0; j < 8; j++) {
            aug[k][j] -= factor * aug[i][j];
          }
        }
      }
    }

    // Extract inverse from right half
    return aug.map(row => row.slice(4));
  }

  // Compute Frobenius norm of a matrix (total magnitude)
  function frobeniusNorm(matrix) {
    let sum = 0;
    for (let i = 0; i < matrix.length; i++) {
      for (let j = 0; j < matrix[i].length; j++) {
        sum += matrix[i][j] * matrix[i][j];
      }
    }
    return Math.sqrt(sum);
  }

  // Compute determinant of 4x4 matrix
  function determinant4x4(m) {
    // Using cofactor expansion (simplified for 4x4)
    // This is a simplified calculation
    return (
      m[0][0] * m[1][1] * m[2][2] * m[3][3] +
      m[0][1] * m[1][2] * m[2][3] * m[3][0] +
      m[0][2] * m[1][3] * m[2][0] * m[3][1] +
      m[0][3] * m[1][0] * m[2][1] * m[3][2] -
      m[0][3] * m[1][2] * m[2][1] * m[3][0] -
      m[0][2] * m[1][1] * m[2][0] * m[3][3] -
      m[0][1] * m[1][0] * m[2][3] * m[3][2] -
      m[0][0] * m[1][3] * m[2][2] * m[3][1]
    );
  }

  // Render matrix exponential equation for Gaussian with Taylor expansion
  function renderGaussianEquation(data) {
    const container = document.getElementById('gmmEquation');
    // Use the actual correlation matrix if correlation slider is active
    let corr;
    if (editableCorr) {
      corr = editableCorr;
    } else if (Math.abs(gmmConfig.correlationStrength) > 0.01) {
      corr = createCorrelationMatrix(gmmConfig.correlationStrength);
    } else {
      corr = computeCorrelationMatrix(data);
    }

    // Compute PRECISION matrix (inverse) - this is what appears in Gaussian formula
    const precision = invert4x4(corr);

    // Compute precision matrix powers for Taylor series
    const R0 = matrixPower(precision, 0); // Identity
    const R1 = precision;
    const R2 = matrixPower(precision, 2);
    const R3 = matrixPower(precision, 3);

    // Calculate contributions (Frobenius norms)
    const norm0 = frobeniusNorm(R0);
    const norm1 = frobeniusNorm(R1);
    const norm2 = frobeniusNorm(R2) / 2; // Divided by 2!
    const norm3 = frobeniusNorm(R3) / 6; // Divided by 3!

    const totalNorm = norm0 + norm1 + norm2 + norm3;
    const contrib0 = (norm0 / totalNorm) * 100;
    const contrib1 = (norm1 / totalNorm) * 100;
    const contrib2 = (norm2 / totalNorm) * 100;
    const contrib3 = (norm3 / totalNorm) * 100;

    // Calculate determinant
    const det = determinant4x4(corr);

    const renderMatrix = (mat, small = false) => `
      <div class="eq-matrix ${small ? 'eq-matrix-small' : ''}">
        ${mat.map((row, i) =>
          row.map((val, j) =>
            `<div class="eq-matrix-cell" style="color: ${val > 0 ? '#58a6ff' : '#f78166'}">${val.toFixed(2)}</div>`
          ).join('')
        ).join('')}
      </div>
    `;

    container.innerHTML = `
      <div style="text-align: center; margin: 20px 0;">
        <div id="mainEquationTop"></div>
      </div>

      <div class="equation-explanation" style="margin-bottom: 20px;">
        <table style="width: 100%; border-collapse: collapse; margin-bottom: 20px; font-size: 18px;">
          <thead>
            <tr style="border-bottom: 2px solid var(--grid);">
              <th style="padding: 10px; text-align: left; color: var(--accent); font-weight: 600;">Variable</th>
              <th style="padding: 10px; text-align: left; color: var(--accent); font-weight: 600;">Symbol</th>
              <th style="padding: 10px; text-align: left; color: var(--accent); font-weight: 600;">Meaning</th>
            </tr>
          </thead>
          <tbody>
            <tr style="border-bottom: 1px solid var(--grid);">
              <td style="padding: 10px; color: #58a6ff; font-weight: 600;">Data vector</td>
              <td style="padding: 10px; color: #58a6ff; font-size: 18px; font-weight: 700;">x</td>
              <td style="padding: 10px; color: var(--text);">4D observation (SL, SW, PL, PW)</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--grid);">
              <td style="padding: 10px; color: #ffe66d; font-weight: 600;">Mean vector</td>
              <td style="padding: 10px; color: #ffe66d; font-size: 18px; font-weight: 700;">Œº</td>
              <td style="padding: 10px; color: var(--text);">Center of the distribution</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--grid);">
              <td style="padding: 10px; color: #ff6b6b; font-weight: 600;">Covariance matrix</td>
              <td style="padding: 10px; color: #ff6b6b; font-size: 18px; font-weight: 700;">Œ£</td>
              <td style="padding: 10px; color: var(--text);">4√ó4 matrix encoding variances & correlations</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--grid);">
              <td style="padding: 10px; color: #4ecdc4; font-weight: 600;"><a href="https://en.wikipedia.org/wiki/Precision_(statistics)" style="color: #4ecdc4; text-decoration: none;">Precision matrix</a></td>
              <td style="padding: 10px; color: #4ecdc4; font-size: 18px; font-weight: 700;">Œ£‚Åª¬π</td>
              <td style="padding: 10px; color: var(--text);"><a href="https://en.wikipedia.org/wiki/Invertible_matrix" style="color: var(--accent); text-decoration: none;">Inverse</a> of covariance (high precision = tight distribution)</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--grid);">
              <td style="padding: 10px; color: #ba68c8; font-weight: 600;"><a href="https://en.wikipedia.org/wiki/Normalizing_constant" style="color: #ba68c8; text-decoration: none;">Normalization constant</a></td>
              <td style="padding: 10px; color: #ba68c8; font-size: 18px; font-weight: 700;">(2œÄ)^(d/2)</td>
              <td style="padding: 10px; color: var(--text);"><a href="https://en.wikipedia.org/wiki/Pi" style="color: var(--accent); text-decoration: none;">2œÄ</a> raised to the power d/2, where d is the number of dimensions</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--grid);">
              <td style="padding: 10px; color: #3fb950; font-weight: 600;"><a href="https://en.wikipedia.org/wiki/Exponential_function" style="color: #3fb950; text-decoration: none;">Exponential function</a></td>
              <td style="padding: 10px; color: #3fb950; font-size: 18px; font-weight: 700;">exp</td>
              <td style="padding: 10px; color: var(--text);">Creates the <a href="https://en.wikipedia.org/wiki/Normal_distribution" style="color: var(--accent); text-decoration: none;">bell-shaped curve</a> (e^x function)</td>
            </tr>
            <tr>
              <td style="padding: 10px; color: #ff9800; font-weight: 600;">Exponent factor</td>
              <td style="padding: 10px; color: #ff9800; font-size: 18px; font-weight: 700;">-1/2</td>
              <td style="padding: 10px; color: var(--text);">From <a href="https://en.wikipedia.org/wiki/Completing_the_square" style="color: var(--accent); text-decoration: none;">completing the square</a> in <a href="https://en.wikipedia.org/wiki/Quadratic_form" style="color: var(--accent); text-decoration: none;">quadratic form</a></td>
            </tr>
          </tbody>
        </table>

        <p style="margin: 0 0 16px 0; font-size: 18px; line-height: 2; color: var(--text);">
          The <a href="https://en.wikipedia.org/wiki/Multivariate_normal_distribution" style="color: var(--accent); text-decoration: none; font-weight: 600;">multivariate Gaussian</a> <a href="https://en.wikipedia.org/wiki/Probability_density_function" style="color: var(--accent); text-decoration: none; font-weight: 600;">probability density function</a> describes the likelihood of observing a d-dimensional vector <b style="color: #58a6ff;">x</b> given a <a href="https://en.wikipedia.org/wiki/Mean" style="color: var(--accent); text-decoration: none;">mean vector</a> <b style="color: #ffe66d;">Œº</b> and <a href="https://en.wikipedia.org/wiki/Covariance_matrix" style="color: var(--accent); text-decoration: none;">covariance matrix</a> <b style="color: #ff6b6b;">Œ£</b>. In our <a href="https://en.wikipedia.org/wiki/Iris_flower_data_set" style="color: var(--accent); text-decoration: none;">Iris dataset</a>, this is a 4-dimensional distribution (<a href="https://en.wikipedia.org/wiki/Sepal" style="color: var(--accent); text-decoration: none;">sepal</a> length, sepal width, <a href="https://en.wikipedia.org/wiki/Petal" style="color: var(--accent); text-decoration: none;">petal</a> length, petal width) that captures how these features vary together for each species.
        </p>

        <!-- Mean Vector Visualization -->
        <div style="margin: 40px 0;">
          <div style="display: grid; grid-template-columns: 400px 1fr; gap: 32px; align-items: start;">
            <canvas id="meanVectorCanvas" width="800" height="640" style="width: 400px; height: 320px; background: #0d1117; border: none;"></canvas>
            <div style="font-size: 18px; line-height: 1.9; color: var(--text); padding-top: 0;">
              <p style="margin: 0 0 20px 0;">
                The <b style="color: #ff8800;">mean vector Œº</b> is the center point of the distribution in 4-dimensional space. The diagram shows a 2D <a href="https://en.wikipedia.org/wiki/Projection_(linear_algebra)" style="color: var(--accent); text-decoration: none;">projection</a> (petal length vs. petal width) of the Setosa class. The full 4D mean vector for Setosa is:
              </p>
              <div style="margin: 20px 0; font-family: monospace; font-size: 17px; line-height: 1.7;">
                <div><b style="color: #ff8800;">Œº</b> = [<span id="meanVector_SL" style="color: #58a6ff;">5.01</span>, <span id="meanVector_SW" style="color: #58a6ff;">3.42</span>, <span id="meanVector_PL" style="color: #ff8800;">1.46</span>, <span id="meanVector_PW" style="color: #ff8800;">0.25</span>]</div>
              </div>
              <p style="margin: 20px 0 0 0; font-size: 18px; color: var(--muted);">
                The highlighted values (<span style="color: #ff8800;">1.46, 0.25</span>) are the petal dimensions shown in the 2D plot. We cannot visualize 4D directly, so we examine 2D slices.
              </p>
            </div>
          </div>
        </div>

        <!-- 2x2 Correlation Section -->
        <div style="margin: 40px 0;">
          <p style="margin: 0 0 20px 0; font-size: 18px; line-height: 2; color: var(--text);">
            To understand correlation geometrically, start with the 2D petal subspace we visualized above. The mean vector <b style="color: #ff8800;">Œº</b> = (<span style="color: #ff8800;">1.46, 0.25</span>) is the center. Around this center, the 2√ó2 covariance matrix describes how the data spreads:
          </p>
          <div style="display: flex; align-items: center; gap: 24px; margin: 20px 0;">
            <div style="display: flex; align-items: center; gap: 12px;">
              <div style="font-size: 24px; font-weight: bold; color: #4ecdc4;">Œ£<sub>petals</sub> =</div>
              <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 6px; padding: 16px; background: rgba(0,0,0,0.3); border-radius: 6px;">
                <div style="padding: 12px; background: rgba(255,107,107,0.3); border-radius: 3px; text-align: center; font-size: 16px; color: var(--text); font-weight: 600;">œÉ¬≤<sub>PL</sub></div>
                <div style="padding: 12px; background: rgba(78,205,196,0.4); border-radius: 3px; text-align: center; font-size: 16px; color: var(--text); font-weight: 700; border: 2px solid #4ecdc4;">cov<sub>PL,PW</sub></div>
                <div style="padding: 12px; background: rgba(78,205,196,0.4); border-radius: 3px; text-align: center; font-size: 16px; color: var(--text); font-weight: 700; border: 2px solid #4ecdc4;">cov<sub>PL,PW</sub></div>
                <div style="padding: 12px; background: rgba(255,107,107,0.3); border-radius: 3px; text-align: center; font-size: 16px; color: var(--text); font-weight: 600;">œÉ¬≤<sub>PW</sub></div>
              </div>
            </div>
            <div style="flex: 1; font-size: 18px; line-height: 1.9; color: var(--text);">
              The <a href="https://en.wikipedia.org/wiki/Diagonal_matrix" style="color: var(--accent); text-decoration: none;">diagonal</a> holds variances (spread along each axis). The off-diagonal elements are identical and measure covariance‚Äîwhen petal length increases, petal width tends to increase too, creating positive <a href="https://en.wikipedia.org/wiki/Correlation" style="color: var(--accent); text-decoration: none;">correlation</a>.
            </div>
          </div>
        </div>

        <!-- Building to 4x4 -->
        <div style="margin: 40px 0;">
          <p style="margin: 0 0 20px 0; font-size: 18px; line-height: 2; color: var(--text);">
            The full 4-dimensional iris has 4 features: sepal length, sepal width, petal length, petal width. All four features are interdependent‚Äîsepal dimensions correlate with each other, petal dimensions correlate with each other, and sepals correlate with petals. The 4√ó4 covariance matrix <b style="color: #ff6b6b;">Œ£</b> captures all these relationships simultaneously. It contains 4 variances (diagonal) and 6 unique pairwise covariances (off-diagonal), totaling 10 independent numbers that fully describe the Gaussian shape in 4D space.
          </p>
        </div>

        <div style="display: flex; align-items: center; gap: 20px; margin: 20px 0;">
          <div style="flex: 1;">
            <p style="margin: 0; font-size: 18px; line-height: 2;">
              The covariance matrix <b style="color: #ff6b6b;">Œ£</b> is central to understanding correlations. Its diagonal elements are the variances (how much each feature spreads), while the off-diagonal elements are covariances (how features co-vary). For the Iris dataset, petal length and petal width are strongly correlated, which shows up as large off-diagonal values in <b style="color: #ff6b6b;">Œ£</b>.
            </p>
          </div>

          <div style="display: flex; flex-direction: column; align-items: center; gap: 16px;">
            <div style="display: flex; align-items: center; gap: 12px;">
              <div style="font-size: 32px; font-weight: bold; color: #ff6b6b;">Œ£ =</div>
              <div style="display: grid; grid-template-columns: repeat(4, 1fr); gap: 4px; padding: 12px; background: rgba(0,0,0,0.3); border-radius: 6px;">
                <div style="padding: 8px; background: rgba(255,107,107,0.3); border-radius: 3px; text-align: center; font-size: 14px; color: var(--text); font-weight: 600;">œÉ¬≤<sub>SL</sub></div>
                <div style="padding: 8px; background: rgba(88,166,255,0.2); border-radius: 3px; text-align: center; font-size: 14px; color: var(--muted);">cov</div>
                <div style="padding: 8px; background: rgba(88,166,255,0.2); border-radius: 3px; text-align: center; font-size: 14px; color: var(--muted);">cov</div>
                <div style="padding: 8px; background: rgba(88,166,255,0.2); border-radius: 3px; text-align: center; font-size: 14px; color: var(--muted);">cov</div>

                <div style="padding: 8px; background: rgba(88,166,255,0.2); border-radius: 3px; text-align: center; font-size: 14px; color: var(--muted);">cov</div>
                <div style="padding: 8px; background: rgba(255,107,107,0.3); border-radius: 3px; text-align: center; font-size: 14px; color: var(--text); font-weight: 600;">œÉ¬≤<sub>SW</sub></div>
                <div style="padding: 8px; background: rgba(88,166,255,0.2); border-radius: 3px; text-align: center; font-size: 14px; color: var(--muted);">cov</div>
                <div style="padding: 8px; background: rgba(88,166,255,0.2); border-radius: 3px; text-align: center; font-size: 14px; color: var(--muted);">cov</div>

                <div style="padding: 8px; background: rgba(88,166,255,0.2); border-radius: 3px; text-align: center; font-size: 14px; color: var(--muted);">cov</div>
                <div style="padding: 8px; background: rgba(88,166,255,0.2); border-radius: 3px; text-align: center; font-size: 14px; color: var(--muted);">cov</div>
                <div style="padding: 8px; background: rgba(255,107,107,0.3); border-radius: 3px; text-align: center; font-size: 14px; color: var(--text); font-weight: 600;">œÉ¬≤<sub>PL</sub></div>
                <div style="padding: 8px; background: rgba(78,205,196,0.4); border-radius: 3px; text-align: center; font-size: 14px; color: var(--text); font-weight: 700; border: 2px solid #4ecdc4;">‚òÖ</div>

                <div style="padding: 8px; background: rgba(88,166,255,0.2); border-radius: 3px; text-align: center; font-size: 14px; color: var(--muted);">cov</div>
                <div style="padding: 8px; background: rgba(88,166,255,0.2); border-radius: 3px; text-align: center; font-size: 14px; color: var(--muted);">cov</div>
                <div style="padding: 8px; background: rgba(78,205,196,0.4); border-radius: 3px; text-align: center; font-size: 14px; color: var(--text); font-weight: 700; border: 2px solid #4ecdc4;">‚òÖ</div>
                <div style="padding: 8px; background: rgba(255,107,107,0.3); border-radius: 3px; text-align: center; font-size: 14px; color: var(--text); font-weight: 600;">œÉ¬≤<sub>PW</sub></div>
              </div>
            </div>
            <div style="font-size: 16px; color: rgba(139, 148, 158, 0.7); line-height: 1.8; text-align: center;">
              <div>‚òÖ = Strong correlation (PL√óPW)</div>
              <div><a href="https://en.wikipedia.org/wiki/Diagonal_matrix" style="color: var(--accent); text-decoration: none;">Diagonal</a> = Variances</div>
            </div>
          </div>
        </div>

        <!-- Precision Matrix Section -->
        <div style="margin: 40px 0;">
          <p style="margin: 0 0 20px 0; font-size: 18px; line-height: 2; color: var(--text);">
            The <b style="color: #4ecdc4;">precision matrix Œ£‚Åª¬π</b> is the matrix inverse of the covariance matrix. It appears in the Gaussian equation's exponent and measures certainty rather than spread. The relationship is reciprocal: high variance (wide spread) means low precision (high uncertainty), while low variance (tight spread) means high precision (high certainty).
          </p>

          <div style="display: flex; align-items: start; gap: 32px; margin: 20px 0;">
            <div style="flex: 1;">
              <p style="margin: 0 0 16px 0; font-size: 18px; line-height: 2; color: var(--text);">
                For the 2√ó2 petal example, if the covariance matrix describes the spread:
              </p>
              <div style="display: flex; align-items: center; gap: 12px; margin: 20px 0;">
                <div style="font-size: 20px; font-weight: bold; color: #ff6b6b;">Œ£ =</div>
                <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 4px; padding: 12px; background: rgba(0,0,0,0.3); border-radius: 6px;">
                  <div style="padding: 10px; background: rgba(255,107,107,0.3); border-radius: 3px; text-align: center; font-size: 14px; color: var(--text); font-weight: 600;">0.03</div>
                  <div style="padding: 10px; background: rgba(78,205,196,0.4); border-radius: 3px; text-align: center; font-size: 14px; color: var(--text); font-weight: 600;">0.01</div>
                  <div style="padding: 10px; background: rgba(78,205,196,0.4); border-radius: 3px; text-align: center; font-size: 14px; color: var(--text); font-weight: 600;">0.01</div>
                  <div style="padding: 10px; background: rgba(255,107,107,0.3); border-radius: 3px; text-align: center; font-size: 14px; color: var(--text); font-weight: 600;">0.01</div>
                </div>
              </div>
              <p style="margin: 16px 0 0 0; font-size: 18px; line-height: 2; color: var(--text);">
                Then the precision matrix (its inverse) shows how tightly constrained each dimension is:
              </p>
              <div style="display: flex; align-items: center; gap: 12px; margin: 20px 0;">
                <div style="font-size: 20px; font-weight: bold; color: #4ecdc4;">Œ£‚Åª¬π =</div>
                <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 4px; padding: 12px; background: rgba(0,0,0,0.3); border-radius: 6px;">
                  <div style="padding: 10px; background: rgba(78,205,196,0.3); border-radius: 3px; text-align: center; font-size: 14px; color: var(--text); font-weight: 600;">50.0</div>
                  <div style="padding: 10px; background: rgba(78,205,196,0.2); border-radius: 3px; text-align: center; font-size: 14px; color: var(--text); font-weight: 600;">-33.3</div>
                  <div style="padding: 10px; background: rgba(78,205,196,0.2); border-radius: 3px; text-align: center; font-size: 14px; color: var(--text); font-weight: 600;">-33.3</div>
                  <div style="padding: 10px; background: rgba(78,205,196,0.3); border-radius: 3px; text-align: center; font-size: 14px; color: var(--text); font-weight: 600;">125.0</div>
                </div>
              </div>
            </div>

            <div style="flex: 1;">
              <p style="margin: 0 0 16px 0; font-size: 18px; line-height: 2; color: var(--text);">
                Notice the precision values are much larger‚Äîthis is the reciprocal relationship. The precision matrix weights the Mahalanobis distance:
              </p>
              <div style="margin: 20px 0;">
                <div style="font-size: 18px; line-height: 2; color: var(--text);">
                  <div style="margin-bottom: 12px;">
                    Distance = (<b style="color: #58a6ff;">x</b> - <b style="color: #ff8800;">Œº</b>)<sup>T</sup> <b style="color: #4ecdc4;">Œ£‚Åª¬π</b> (<b style="color: #58a6ff;">x</b> - <b style="color: #ff8800;">Œº</b>)
                  </div>
                  <div style="font-size: 16px; color: rgba(139, 148, 158, 0.8); line-height: 1.8;">
                    This measures how many "standard deviations" a point is from the mean, accounting for correlations. Points far from the mean get exponentially lower probability.
                  </div>
                </div>
              </div>
              <p style="margin: 16px 0 0 0; font-size: 18px; line-height: 2; color: var(--text);">
                In 4D, <b style="color: #4ecdc4;">Œ£‚Åª¬π</b> is a 4√ó4 matrix that encodes how all dimensions jointly constrain probability. The off-diagonal elements show how knowing one feature's value affects our certainty about others.
              </p>
            </div>
          </div>
        </div>

        <!-- Mahalanobis Distance Section -->
        <div style="margin: 40px 0;">
          <p style="margin: 0 0 20px 0; font-size: 18px; line-height: 2; color: var(--text);">
            The <a href="https://en.wikipedia.org/wiki/Normal_distribution" style="color: var(--accent); text-decoration: none; font-weight: 600;">Gaussian</a> <a href="https://en.wikipedia.org/wiki/Probability_density_function" style="color: var(--accent); text-decoration: none;">probability density</a> is built from a single core quantity: the <a href="https://en.wikipedia.org/wiki/Mahalanobis_distance" style="color: var(--accent); text-decoration: none; font-weight: 600;">Mahalanobis distance</a>. For a point <b style="color: #58a6ff;">x</b> relative to the distribution centered at <b style="color: #ff8800;">Œº</b> with precision matrix <b style="color: #4ecdc4;">Œ£‚Åª¬π</b>, the squared Mahalanobis distance is:
          </p>

          <div style="text-align: center; font-size: 20px; font-weight: 600; margin: 24px 0; padding: 20px; background: rgba(0,0,0,0.2); border-radius: 6px;">
            d¬≤ = (<b style="color: #58a6ff;">x</b> - <b style="color: #ff8800;">Œº</b>)<sup>T</sup> <b style="color: #4ecdc4;">Œ£‚Åª¬π</b> (<b style="color: #58a6ff;">x</b> - <b style="color: #ff8800;">Œº</b>)
          </div>

          <p style="margin: 20px 0; font-size: 18px; line-height: 2; color: var(--text);">
            This generalizes <a href="https://en.wikipedia.org/wiki/Euclidean_distance" style="color: var(--accent); text-decoration: none; font-weight: 600;">Euclidean distance</a>. In 2D with uncorrelated, unit-variance features, <b style="color: #4ecdc4;">Œ£‚Åª¬π</b> = I (<a href="https://en.wikipedia.org/wiki/Identity_matrix" style="color: var(--accent); text-decoration: none;">identity matrix</a>), and d¬≤ reduces to the familiar (x‚ÇÅ - Œº‚ÇÅ)¬≤ + (x‚ÇÇ - Œº‚ÇÇ)¬≤. The precision matrix <b style="color: #4ecdc4;">Œ£‚Åª¬π</b> weights and rotates the coordinate system to account for different variances and correlations between dimensions.
          </p>

          <div style="display: flex; gap: 32px; margin: 30px 0;">
            <div style="flex: 1;">
              <p style="margin: 0 0 16px 0; font-size: 18px; line-height: 2; color: var(--text);">
                For the 2D petal example with mean <b style="color: #ff8800;">Œº</b> = (1.46, 0.25):
              </p>
              <div style="font-size: 18px; line-height: 2; color: var(--text); margin-left: 20px;">
                <div>deviation = <b style="color: #58a6ff;">x</b> - <b style="color: #ff8800;">Œº</b></div>
                <div style="margin-top: 8px; margin-left: 20px; color: rgba(139, 148, 158, 0.9);">= [x‚ÇÅ - 1.46, x‚ÇÇ - 0.25]</div>
                <div style="margin-top: 16px;">d¬≤ = deviation<sup>T</sup> <b style="color: #4ecdc4;">Œ£‚Åª¬π</b> deviation</div>
              </div>
            </div>

            <div style="flex: 1;">
              <p style="margin: 0 0 16px 0; font-size: 18px; line-height: 2; color: var(--text);">
                The quadratic form computes a weighted sum. If <b style="color: #4ecdc4;">Œ£‚Åª¬π</b> has large diagonal values, deviations in those dimensions are heavily penalized. Off-diagonal elements couple dimensions‚Äîcorrelation between petal length and width means knowing one constrains the other.
              </p>
            </div>
          </div>

          <!-- Interactive: Euclidean vs Mahalanobis -->
          <div style="margin: 30px 0;">
            <p style="margin: 0 0 16px 0; font-size: 20px; font-weight: 600; color: var(--accent2);">
              Interactive: Euclidean vs Mahalanobis distance
            </p>
            <div style="display: flex; gap: 24px; align-items: start;">
              <div style="flex: 0 0 350px;">
                <canvas id="euclideanVsMahalanobis" width="350" height="350" style="width: 350px; height: 350px; border: 1px solid var(--grid); border-radius: 4px; cursor: crosshair;"></canvas>
                <p style="margin: 10px 0 8px 0; font-size: 13px; color: rgba(139, 148, 158, 0.9); text-align: center;">
                  Click or drag the point to explore
                </p>
                <!-- Covariance Matrix Display -->
                <div style="margin: 0 auto; max-width: 180px; padding: 12px; background: rgba(78, 205, 196, 0.08); border: 1px solid rgba(78, 205, 196, 0.3); border-radius: 4px;">
                  <div style="font-size: 12px; font-weight: 600; color: #4ecdc4; text-align: center; margin-bottom: 8px;">Covariance Matrix Œ£</div>
                  <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 6px; font-family: monospace; font-size: 13px;">
                    <div style="padding: 6px; background: rgba(255, 107, 107, 0.2); border-radius: 3px; text-align: center; color: var(--text);">
                      <span id="covMat00">0.00</span>
                    </div>
                    <div style="padding: 6px; background: rgba(78, 205, 196, 0.2); border-radius: 3px; text-align: center; color: var(--text);">
                      <span id="covMat01">0.00</span>
                    </div>
                    <div style="padding: 6px; background: rgba(78, 205, 196, 0.2); border-radius: 3px; text-align: center; color: var(--text);">
                      <span id="covMat10">0.00</span>
                    </div>
                    <div style="padding: 6px; background: rgba(255, 107, 107, 0.2); border-radius: 3px; text-align: center; color: var(--text);">
                      <span id="covMat11">0.00</span>
                    </div>
                  </div>
                  <div style="margin-top: 6px; font-size: 10px; color: rgba(139, 148, 158, 0.8); text-align: center;">
                    <span style="color: #ff6b6b;">‚ñ†</span> Variance &nbsp;
                    <span style="color: #4ecdc4;">‚ñ†</span> Covariance
                  </div>
                </div>
              </div>
              <div style="flex: 1;">
                <p style="margin: 0 0 16px 0; font-size: 16px; line-height: 1.8; color: var(--text);">
                  The <a href="https://en.wikipedia.org/wiki/Ellipse" style="color: var(--accent); text-decoration: none;">ellipse</a> contours represent points at equal Mahalanobis distance from the mean. These ellipses reveal the <b style="color: #4ecdc4;"><a href="https://en.wikipedia.org/wiki/Eigenvalues_and_eigenvectors" style="color: #4ecdc4; text-decoration: none;">eigenvector</a> structure</b> of the covariance matrix:
                </p>
                <div style="margin: 20px 0; padding: 16px; background: rgba(78, 205, 196, 0.05); border-left: 3px solid #4ecdc4; border-radius: 4px;">
                  <div style="margin-bottom: 12px;">
                    <span style="font-size: 14px; color: #58a6ff;">Euclidean distance: </span>
                    <span id="euclideanDist" style="font-size: 24px; font-weight: 600; font-family: monospace; color: #58a6ff;">0.00</span>
                  </div>
                  <div>
                    <span style="font-size: 14px; color: #4ecdc4;">Mahalanobis distance: </span>
                    <span id="mahalanobisDist" style="font-size: 24px; font-weight: 600; font-family: monospace; color: #4ecdc4;">0.00</span>
                  </div>
                </div>
                <p style="margin: 0 0 12px 0; font-size: 15px; line-height: 1.8; color: rgba(139, 148, 158, 0.9);">
                  <b style="color: #ff8800;">The ellipse axes align with <a href="https://en.wikipedia.org/wiki/Eigenvalues_and_eigenvectors" style="color: #ff8800; text-decoration: none;">eigenvectors</a></b> of the covariance matrix <b style="color: #ff6b6b;">Œ£</b>. The <b style="color: #ffe66d;"><a href="https://en.wikipedia.org/wiki/Eigenvalues_and_eigenvectors" style="color: #ffe66d; text-decoration: none;">eigenvalues</a> Œª‚ÇÅ and Œª‚ÇÇ</b> determine how far you can travel along each eigenvector direction before the Mahalanobis distance increases by 1 standard deviation.
                </p>
                <p style="margin: 0 0 12px 0; font-size: 15px; line-height: 1.8; color: rgba(139, 148, 158, 0.9);">
                  Moving along the <b style="color: #4ecdc4;">wide axis</b> (large eigenvalue = high variance): you can go far before Mahalanobis distance increases. Moving along the <b style="color: #58a6ff;">narrow axis</b> (small eigenvalue = low variance): small movements create large Mahalanobis distances.
                </p>
                <p style="margin: 0; font-size: 15px; line-height: 1.8; color: rgba(139, 148, 158, 0.9);">
                  Drag the point along an ellipse contour: Mahalanobis distance stays constant while Euclidean distance changes. This shows how Mahalanobis "warps" space according to the data's correlation structure, making statistically equivalent points appear at different physical distances.
                </p>
              </div>
            </div>
          </div>

          <!-- Comparative Examples: Precision -->
          <div style="margin: 30px 0;">
            <p style="margin: 0 0 16px 0; font-size: 18px; line-height: 2; color: var(--text);">
              How precision affects distance: Comparative examples
            </p>

            <p style="margin: 0 0 20px 0; font-size: 16px; line-height: 1.8; color: var(--text);">
              Precision is the inverse of variance. When precision is high, data is tightly clustered. The same physical displacement means different things statistically:
            </p>

            <div style="display: flex; gap: 16px; margin-bottom: 20px;">
              <div style="flex: 1; text-align: center;">
                <canvas id="precisionLow" width="180" height="180" style="border: 1px solid var(--grid); border-radius: 4px;"></canvas>
                <div style="margin: 8px 0 0 0; font-size: 14px; color: var(--text); font-weight: 600;">Low Precision (œÉ¬≤ = 1.0)</div>
                <div style="font-size: 13px; color: rgba(139, 148, 158, 0.9); margin-top: 4px;">Coordinate: 50px</div>
                <div style="font-size: 13px; color: #4ecdc4; font-weight: 600;">Mahalanobis: 1.58</div>
              </div>
              <div style="flex: 1; text-align: center;">
                <canvas id="precisionMed" width="180" height="180" style="border: 1px solid var(--grid); border-radius: 4px;"></canvas>
                <div style="margin: 8px 0 0 0; font-size: 14px; color: var(--text); font-weight: 600;">Medium Precision (œÉ¬≤ = 0.25)</div>
                <div style="font-size: 13px; color: rgba(139, 148, 158, 0.9); margin-top: 4px;">Coordinate: 50px</div>
                <div style="font-size: 13px; color: #4ecdc4; font-weight: 600;">Mahalanobis: 3.16</div>
              </div>
              <div style="flex: 1; text-align: center;">
                <canvas id="precisionHigh" width="180" height="180" style="border: 1px solid var(--grid); border-radius: 4px;"></canvas>
                <div style="margin: 8px 0 0 0; font-size: 14px; color: var(--text); font-weight: 600;">High Precision (œÉ¬≤ = 0.04)</div>
                <div style="font-size: 13px; color: rgba(139, 148, 158, 0.9); margin-top: 4px;">Coordinate: 50px</div>
                <div style="font-size: 13px; color: #4ecdc4; font-weight: 600;">Mahalanobis: 7.91</div>
              </div>
            </div>

            <p style="margin: 20px 0 0 0; font-size: 16px; line-height: 1.8; color: rgba(139, 148, 158, 0.9);">
              All three scenarios show the same blue point at the same coordinate distance (50 pixels) from the orange mean. But as precision increases (variance decreases), the ellipse shrinks. The point goes from being "typical" (inside the contour) to "unusual" (far outside). When data is tightly clustered, even small displacements are statistically significant.
            </p>
          </div>

          <p style="margin: 30px 0 20px 0; font-size: 18px; line-height: 2; color: var(--text);">
            The Gaussian is constructed by applying the exponential function to <b>-¬Ω d¬≤</b>. Points at Mahalanobis distance d from the mean get probability proportional to exp(-¬Ω d¬≤). At the mean (<b style="color: #58a6ff;">x</b> = <b style="color: #ff8800;">Œº</b>), d¬≤ = 0 and probability is maximal. Moving away, d¬≤ grows quadratically and probability decays exponentially.
          </p>
        </div>
      </div>

      <div class="equation-explanation" style="margin: 20px 0; font-size: 18px; line-height: 2; color: var(--text);">
        <p style="margin: 0 0 24px 0; font-size: 20px; font-weight: 600; color: var(--accent2);">
          Building the Gaussian
        </p>

        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 32px; align-items: start;">
          <div>
            <p style="margin: 0 0 20px 0; font-size: 16px; color: rgba(139, 148, 158, 0.9);">
              The Gaussian is constructed by applying the <a href="https://en.wikipedia.org/wiki/Exponential_function" style="color: var(--accent); text-decoration: none;">exponential function</a> to <b style="color: #ff9800;">-¬Ω</b> d¬≤. Points at Mahalanobis distance d from the mean get probability proportional to <b style="color: #3fb950;">exp</b>(<b style="color: #ff9800;">-¬Ω</b> d¬≤). At the mean (<b style="color: #58a6ff;">x</b> = <b style="color: #ff8800;">Œº</b>), d¬≤ = 0 and probability is maximal. Moving away, d¬≤ grows quadratically and probability decays exponentially.
            </p>
            <p style="margin: 0; font-size: 16px; color: rgba(139, 148, 158, 0.9);">
              The result is the multivariate Gaussian probability density function.
            </p>
          </div>

          <div>
            <p style="margin: 0 0 8px 0; font-weight: 600; color: var(--text);">
              Step 1: Define distance d¬≤ = (<b style="color: #58a6ff;">x</b> - <b style="color: #ff8800;">Œº</b>)<sup>T</sup> <b style="color: #4ecdc4;">Œ£‚Åª¬π</b> (<b style="color: #58a6ff;">x</b> - <b style="color: #ff8800;">Œº</b>)
            </p>
            <p style="margin: 0 0 16px 0; font-size: 16px; color: rgba(139, 148, 158, 0.9);">
              The Mahalanobis distance accounts for variances and correlations. The precision matrix <b style="color: #4ecdc4;">Œ£‚Åª¬π</b> shapes the ellipse.
            </p>

            <p style="margin: 0 0 8px 0; font-weight: 600; color: var(--text);">
              Step 2: Apply exponential decay: <b style="color: #3fb950;">exp</b>(<b style="color: #ff9800;">-¬Ω</b> d¬≤)
            </p>
            <p style="margin: 0 0 16px 0; font-size: 16px; color: rgba(139, 148, 158, 0.9);">
              Creates the bell-shaped curve.
            </p>

            <p style="margin: 0 0 8px 0; font-weight: 600; color: var(--text);">
              Step 3: Normalize: multiply by (<b style="color: #ba68c8;">2œÄ</b>)<sup>-d/2</sup> |<b style="color: #ff6b6b;">Œ£</b>|<sup>-1/2</sup>
            </p>
            <p style="margin: 0; font-size: 16px; color: rgba(139, 148, 158, 0.9);">
              Ensures total probability = 1. The term <b style="color: #ba68c8;">2œÄ raised to the power d/2</b> accounts for dimension; |<b style="color: #ff6b6b;">Œ£</b>| measures <a href="https://en.wikipedia.org/wiki/Ellipsoid" style="color: var(--accent); text-decoration: none;">ellipsoid</a> volume‚Äîsmaller <a href="https://en.wikipedia.org/wiki/Determinant" style="color: var(--accent); text-decoration: none;">determinant</a> = more concentrated.
            </p>
          </div>
        </div>
      </div>

      <div class="equation-explanation" style="margin: 30px 0; font-size: 18px; line-height: 2; color: var(--text);">
        <p style="margin: 0 0 24px 0; font-size: 20px; font-weight: 600; color: var(--accent2);">
          Where Does 2œÄ Come From?
        </p>

        <p style="margin: 0 0 20px 0; font-size: 16px; color: rgba(139, 148, 158, 0.9);">
          The normalization constant (<b style="color: #ba68c8;">2œÄ</b>)<sup>-d/2</sup> |<b style="color: #ff6b6b;">Œ£</b>|<sup>-1/2</sup> ensures the probability <a href="https://en.wikipedia.org/wiki/Integral" style="color: var(--accent); text-decoration: none;">integrates</a> to 1. But why <b style="color: #ba68c8;">2œÄ</b>? It comes from the <a href="https://en.wikipedia.org/wiki/Circumference" style="color: var(--accent); text-decoration: none;">circumference</a> of a <a href="https://en.wikipedia.org/wiki/Circle" style="color: var(--accent); text-decoration: none;">circle</a>‚Äîand to see it, we need to work in <b>2D</b>.
        </p>

        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 32px; align-items: start; margin: 24px 0;">
          <div style="padding: 16px; background: rgba(88, 166, 255, 0.08); border-radius: 6px;">
            <p style="margin: 0 0 12px 0; font-weight: 600; color: var(--accent);">
              The Problem (1D)
            </p>
            <p style="margin: 0 0 12px 0; font-size: 16px; color: rgba(139, 148, 158, 0.9);">
              We want to evaluate:
            </p>
            <p style="margin: 0 0 12px 0; font-family: monospace; font-size: 15px; color: var(--text); text-align: center;">
              I = ‚à´<sub>-‚àû</sub><sup>‚àû</sup> e<sup>-x¬≤/2</sup> dx
            </p>
            <p style="margin: 0; font-size: 16px; color: rgba(139, 148, 158, 0.9);">
              This <a href="https://en.wikipedia.org/wiki/Integral" style="color: var(--accent); text-decoration: none;">integral</a> has no closed-form <a href="https://en.wikipedia.org/wiki/Antiderivative" style="color: var(--accent); text-decoration: none;">antiderivative</a>. You <b>cannot</b> use <a href="https://en.wikipedia.org/wiki/Polar_coordinate_system" style="color: var(--accent); text-decoration: none;">polar coordinates</a> in 1D‚Äîthere's no angle to integrate over.
            </p>
          </div>

          <div style="padding: 16px; background: rgba(247, 129, 102, 0.08); border-radius: 6px;">
            <p style="margin: 0 0 12px 0; font-weight: 600; color: var(--accent2);">
              The Trick (2D)
            </p>
            <p style="margin: 0 0 12px 0; font-size: 16px; color: rgba(139, 148, 158, 0.9);">
              Square the integral to create a 2D <b>joint distribution</b>:
            </p>
            <p style="margin: 0 0 12px 0; font-family: monospace; font-size: 14px; color: var(--text); text-align: center;">
              I¬≤ = ‚à´‚à´<sub>‚Ñù¬≤</sub> e<sup>-(x¬≤+y¬≤)/2</sup> dx dy
            </p>
            <p style="margin: 0 0 12px 0; font-size: 16px; color: rgba(139, 148, 158, 0.9);">
              Now we have two <b>independent</b> random variables (x, y). The 2D integral factors into separate x and y integrals because they're uncorrelated.
            </p>
            <p style="margin: 0; font-size: 16px; color: rgba(139, 148, 158, 0.9);">
              The integrand depends only on <b>r¬≤ = x¬≤ + y¬≤</b> (<a href="https://en.wikipedia.org/wiki/Circular_symmetry" style="color: var(--accent); text-decoration: none;">radially symmetric</a>), making <a href="https://en.wikipedia.org/wiki/Polar_coordinate_system" style="color: var(--accent); text-decoration: none;">polar coordinates</a> natural.
            </p>
          </div>
        </div>

        <p style="margin: 24px 0 12px 0; font-size: 20px; font-weight: 600; color: var(--accent2);">
          Why 2D reveals 2œÄ
        </p>
        <p style="margin: 0 0 24px 0; font-size: 18px; line-height: 1.8; color: var(--text);">
          Squaring transforms a 1D problem (no polar coordinates) into a 2D problem where polar coordinates work. In polar coordinates (r, Œ∏), the 2D integral separates cleanly: I¬≤ = ‚à´<sub>0</sub><sup>2œÄ</sup> dŒ∏ ¬∑ ‚à´<sub>0</sub><sup>‚àû</sup> e<sup>-r¬≤/2</sup> r dr = 2œÄ ¬∑ 1 = 2œÄ. The 2œÄ is literally the angular range when you sweep around a full circle; the radial integral gives 1, therefore I = ‚àö2œÄ. In d dimensions, this generalizes to 2œÄ raised to the power d/2. The |Œ£|<sup>1/2</sup> term accounts for volume scaling‚Äîlarger covariance = wider spread = smaller peak density.
        </p>
      </div>

      <div class="equation-explanation" style="margin: 30px 0;">
        <p style="margin: 0 0 16px 0; font-size: 20px; font-weight: 600; color: var(--accent2);">
          The Exponential Function: Infinitesimal Composition
        </p>
        <p style="margin: 0 0 24px 0; font-size: 18px; line-height: 1.8; color: var(--text);">
          Repeated application at the infinitesimal level. The exponential emerges from composing tiny steps infinite times.
        </p>

        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 32px; margin: 20px 0;">
          <div>
            <p style="margin: 0 0 12px 0; font-size: 18px; font-weight: 600; color: var(--text);">
              Scalar
            </p>
            <div style="font-size: 24px; line-height: 1.8; color: var(--text); margin-bottom: 16px;">
              e<sup>x</sup> = lim<sub>n‚Üí‚àû</sub> (1 + x/n)<sup>n</sup>
            </div>
            <p style="margin: 0; font-size: 18px; line-height: 1.8; color: var(--text);">
              (1 + x/n) is a tiny growth step. Composing it with itself n times gives e<sup>x</sup>. As n‚Üí‚àû, infinitesimal steps compose to continuous growth.
            </p>
          </div>

          <div>
            <p style="margin: 0 0 12px 0; font-size: 18px; font-weight: 600; color: var(--text);">
              Matrix
            </p>
            <div style="font-size: 24px; line-height: 1.8; color: var(--text); margin-bottom: 16px;">
              <div>exp(A) = lim<sub>n‚Üí‚àû</sub> (I + A/n)<sup>n</sup></div>
              <div style="padding-left: 88px;">= Œ£<sub>k=0</sub><sup>‚àû</sup> A<sup>k</sup>/k!</div>
            </div>
            <p style="margin: 0 0 12px 0; font-size: 18px; line-height: 1.8; color: var(--text);">
              (I + A/n) is a tiny linear update: v ‚Ü¶ v + (1/n)Av. Keep most of v, nudge slightly in direction Av.
            </p>
            <p style="margin: 0; font-size: 18px; line-height: 1.8; color: var(--text);">
              Applying n times gives (I + A/n)<sup>n</sup>v ‚Üí exp(A)v. The vector traces a smooth trajectory, rotating and scaling in tiny increments until reaching the continuous flow exp(A)v.
            </p>
          </div>
        </div>

        <div style="margin: 40px 0;">
          <p style="margin: 0 0 16px 0; font-size: 20px; font-weight: 600; color: var(--accent2);">
            Why This Matters for Gaussians
          </p>

          <p style="margin: 0 0 16px 0; font-size: 18px; line-height: 1.8; color: var(--text);">
            In our probability density, we compute exp(-¬Ωd¬≤) where d¬≤ is the Mahalanobis distance. The exponential function creates smooth, bell-shaped decay as you move away from the mean‚Äîbut how does it decay?
          </p>

          <p style="margin: 0 0 16px 0; font-size: 18px; line-height: 1.8; color: var(--text);">
            The <a href="https://en.wikipedia.org/wiki/Taylor_series" style="color: var(--accent); text-decoration: none; font-weight: 600;">Taylor series</a> expansion reveals the answer:
          </p>

          <p style="margin: 0 0 24px 0; font-size: 20px; line-height: 1.8; color: var(--text); text-align: center;">
            exp(Œ£‚Åª¬π) = I + Œ£‚Åª¬π + (Œ£‚Åª¬π)¬≤/2! + (Œ£‚Åª¬π)¬≥/3! + ...
          </p>

          <p style="margin: 0 0 24px 0; font-size: 18px; line-height: 1.8; color: var(--text);">
            Each term shows how correlations propagate through the distribution. Here's where it gets interesting:
          </p>

          <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 24px; margin: 24px 0;">
            <div>
              <p style="margin: 0 0 8px 0; font-size: 18px; font-weight: 600; color: var(--text);">
                Weak Correlations
              </p>
              <p style="margin: 0; font-size: 18px; line-height: 1.8; color: var(--text);">
                The first two terms (I + Œ£‚Åª¬π) capture most of the total. Higher-order terms contribute less. The precision matrix is nearly diagonal‚Äîfeatures are nearly independent.
              </p>
            </div>

            <div>
              <p style="margin: 0 0 8px 0; font-size: 18px; font-weight: 600; color: var(--text);">
                Strong Correlations
              </p>
              <p style="margin: 0; font-size: 18px; line-height: 1.8; color: var(--text);">
                Higher-order terms ((Œ£‚Åª¬π)¬≤/2!, (Œ£‚Åª¬π)¬≥/3!, ...) become significant. The precision matrix has large off-diagonal elements, requiring more terms to capture complex dependencies.
              </p>
            </div>
          </div>

          <p style="margin: 24px 0 0 0; font-size: 18px; line-height: 1.8; color: var(--text);">
            Click on the Correlation slider to see how Taylor Series Expansion term contributions change! When correlations are weak, the first two terms dominate. When correlations are strong, you need many more terms to capture the distribution accurately.
          </p>
        </div>
      </div>

      <div style="width: 100%; margin: 16px 0; padding: 14px; background: rgba(247, 129, 102, 0.15); border-radius: 4px; text-align: center;">
        <div style="font-size: 15px; font-weight: 700; color: var(--accent2); margin-bottom: 10px; text-align: center;">
          <a href="https://en.wikipedia.org/wiki/Taylor_series" style="color: var(--accent2); text-decoration: none;">Taylor Series</a>: exp(Precision Matrix)
        </div>
        <div style="display: flex; align-items: center; justify-content: center; gap: 8px; flex-wrap: wrap; font-size: 15px; font-weight: 600; text-align: center;">
          <span style="align-self: center; margin-bottom: 28px;"><b>exp(<span class="var-r">Œ£‚Åª¬π</span>)</b> ‚âà</span>
          <span style="display: inline-flex; flex-direction: column; align-items: center; gap: 4px;">
            <span style="display: inline-flex; flex-direction: column; align-items: center;">
              <span>${renderMatrix(R0, true)}</span>
              <span style="height: 16px;"></span>
            </span>
            <span style="font-size: 12px; color: var(--accent); font-weight: 700;">${contrib0.toFixed(1)}%</span>
          </span>
          <span style="align-self: center; margin-bottom: 28px;"><b>+</b></span>
          <span style="display: inline-flex; flex-direction: column; align-items: center; gap: 4px;">
            <span style="display: inline-flex; flex-direction: column; align-items: center;">
              <span>${renderMatrix(R1, true)}</span>
              <span style="height: 16px;"></span>
            </span>
            <span style="font-size: 12px; color: var(--accent); font-weight: 700;">${contrib1.toFixed(1)}%</span>
          </span>
          <span style="align-self: center; margin-bottom: 28px;"><b>+</b></span>
          <span style="display: inline-flex; flex-direction: column; align-items: center; font-size: 11px; gap: 4px;">
            <span style="display: inline-flex; flex-direction: column; align-items: center;">
              <span>${renderMatrix(R2, true)}</span>
              <span style="border-top: 1px solid var(--text); padding-top: 2px; margin-top: 2px; font-weight: 700;">2</span>
            </span>
            <span style="font-size: 12px; color: var(--accent); font-weight: 700;">${contrib2.toFixed(1)}%</span>
          </span>
          <span style="align-self: center; margin-bottom: 28px;"><b>+</b></span>
          <span style="display: inline-flex; flex-direction: column; align-items: center; font-size: 11px; gap: 4px;">
            <span style="display: inline-flex; flex-direction: column; align-items: center;">
              <span>${renderMatrix(R3, true)}</span>
              <span style="border-top: 1px solid var(--text); padding-top: 2px; margin-top: 2px; font-weight: 700;">6</span>
            </span>
            <span style="font-size: 12px; color: var(--accent); font-weight: 700;">${contrib3.toFixed(1)}%</span>
          </span>
          <span style="align-self: center; margin-bottom: 28px; color: var(--muted); font-weight: 500;">+ ...</span>
        </div>
      </div>

      <div class="contribution-analysis">
        <div style="font-size: 14px; font-weight: 600; margin-bottom: 8px; color: var(--accent);">
          How Each Term Contributes
        </div>

        <div class="equation-explanation" style="margin: 20px 0; font-size: 18px; line-height: 2; color: var(--text);">
          <p style="margin: 0;">
            We can measure how much each term in the Taylor series contributes using the <a href="https://en.wikipedia.org/wiki/Matrix_norm#Frobenius_norm" style="color: var(--accent); text-decoration: none; font-weight: 600;">Frobenius norm</a>‚Äîa way to measure the "size" or "magnitude" of a matrix, similar to how eigenvalues measure variance explained in <a href="https://en.wikipedia.org/wiki/Principal_component_analysis" style="color: var(--accent); text-decoration: none;">PCA</a>. The bars below show both individual contributions and cumulative totals.
          </p>
        </div>

        <div class="contribution-row">
          <div class="contribution-label">Term 0 (I)</div>
          <div class="contribution-bar">
            <div class="contribution-fill" style="width: ${contrib0.toFixed(1)}%"></div>
          </div>
          <div class="contribution-value">${norm0.toFixed(2)} ‚Üí ${contrib0.toFixed(1)}% (${contrib0.toFixed(1)}%)</div>
        </div>

        <div class="contribution-row">
          <div class="contribution-label">Term 1 (Œ£‚Åª¬π)</div>
          <div class="contribution-bar">
            <div class="contribution-fill" style="width: ${contrib1.toFixed(1)}%"></div>
          </div>
          <div class="contribution-value">${norm1.toFixed(2)} ‚Üí ${contrib1.toFixed(1)}% (${(contrib0 + contrib1).toFixed(1)}%)</div>
        </div>

        <div class="contribution-row">
          <div class="contribution-label">Term 2 ((Œ£‚Åª¬π)¬≤/2)</div>
          <div class="contribution-bar">
            <div class="contribution-fill" style="width: ${contrib2.toFixed(1)}%"></div>
          </div>
          <div class="contribution-value">${norm2.toFixed(2)} ‚Üí ${contrib2.toFixed(1)}% (${(contrib0 + contrib1 + contrib2).toFixed(1)}%)</div>
        </div>

        <div class="contribution-row">
          <div class="contribution-label">Term 3 ((Œ£‚Åª¬π)¬≥/6)</div>
          <div class="contribution-bar">
            <div class="contribution-fill" style="width: ${contrib3.toFixed(1)}%"></div>
          </div>
          <div class="contribution-value">${norm3.toFixed(2)} ‚Üí ${contrib3.toFixed(1)}% (100.0%)</div>
        </div>

        <div class="equation-explanation" style="margin: 20px 0; font-size: 18px; line-height: 2; color: var(--text);">
          <p style="margin: 0;">
            ${norm1 < 0.5 * norm0
              ? `When correlations are weak, the linear approximation exp(Œ£‚Åª¬π) ‚âà I + Œ£‚Åª¬π works remarkably well. In this case, just the first two terms capture ${(contrib0 + contrib1).toFixed(1)}% of the total contribution, meaning we can safely ignore higher-order terms. This is analogous to how in PCA, the first few principal components often explain most of the variance.`
              : `With stronger correlations, we need more terms. The first two terms only account for ${(contrib0 + contrib1).toFixed(1)}% of the total, and we need the quadratic term ((Œ£‚Åª¬π)¬≤/2) to reach ${(contrib0 + contrib1 + contrib2).toFixed(1)}%. This shows that correlations introduce non-linear effects that require higher-order terms to capture accurately.`
            }
            ${det < 0.1 ? ' The determinant |<b style="color: #ff6b6b;">Œ£</b>| = ' + det.toFixed(3) + ' is very small, indicating the features are nearly collinear‚Äîthe uncertainty ellipsoid is extremely flat in one or more directions.' : ''}
          </p>
        </div>
      </div>
    `;

    // Render the main equation with KaTeX
    const renderEquation = () => {
      const equationEl = document.getElementById('mainEquation');
      const equationTopEl = document.getElementById('mainEquationTop');
      const equation = String.raw`p{\color{white}{(}}\color{#58a6ff}{\mathbf{x}} \mid \color{#ffe66d}{\boldsymbol{\mu}}, \color{#ff6b6b}{\boldsymbol{\Sigma}}{\color{white}{)}} = \frac{1}{\color{#ba68c8}{(2\pi)^{d/2}} \color{#ff6b6b}{|\boldsymbol{\Sigma}|^{1/2}}} \color{#3fb950}{\exp}{\color{#3fb950}{\Big[}}\color{#ff9800}{-\frac{1}{2}}{\color{#ffe66d}{(}}\color{#58a6ff}{\mathbf{x}} - \color{#ffe66d}{\boldsymbol{\mu}}{\color{#ffe66d}{)}}^T \color{#4ecdc4}{\boldsymbol{\Sigma}^{-1}} {\color{#ffe66d}{(}}\color{#58a6ff}{\mathbf{x}} - \color{#ffe66d}{\boldsymbol{\mu}}{\color{#ffe66d}{)}}{\color{#3fb950}{\Big]}}`;

      if (typeof katex !== 'undefined') {
        try {
          if (equationEl) {
            katex.render(equation, equationEl, { throwOnError: false, displayMode: true });
          }
          if (equationTopEl) {
            katex.render(equation, equationTopEl, { throwOnError: false, displayMode: true });
          }
        } catch (e) {
          console.error('KaTeX render error:', e);
        }
      } else if (equationEl || equationTopEl) {
        // KaTeX not loaded yet, try again
        setTimeout(renderEquation, 100);
      }
    };

    setTimeout(renderEquation, 50);

    // Draw mean vector after DOM updates
    setTimeout(() => {
      const meanVectorCanvas = document.getElementById('meanVectorCanvas');
      if (meanVectorCanvas) {
        drawMeanVector(meanVectorCanvas, data);
      }
    }, 100);

    // Re-attach Wikipedia link handlers after innerHTML update
    if (typeof window.initWikiLinks === 'function') {
      setTimeout(window.initWikiLinks, 150);
    }
  }

  // Render GMM parameters as Gaussian curves from actual data
  function renderGMMParams(data) {
    const container = document.getElementById('gmmParams');
    const classNames = ['Setosa', 'Versicolor', 'Virginica'];
    const colors = ['#ff6b6b', '#4ecdc4', '#ffe66d'];
    const featureNames = ['Sepal Length', 'Sepal Width', 'Petal Length', 'Petal Width'];

    container.innerHTML = '';

    for (let d = 0; d < 4; d++) {
      const featurePanel = document.createElement('div');
      featurePanel.className = 'gmm-feature-panel';

      const header = document.createElement('div');
      header.className = 'gmm-feature-header';
      header.textContent = featureNames[d];
      featurePanel.appendChild(header);

      const canvas = document.createElement('canvas');
      canvas.className = 'gmm-curve-canvas';
      featurePanel.appendChild(canvas);

      const legend = document.createElement('div');
      legend.className = 'gmm-legend';

      for (let c = 0; c < 3; c++) {
        const item = document.createElement('div');
        item.className = 'gmm-legend-item';

        const dot = document.createElement('div');
        dot.className = 'gmm-legend-dot';
        dot.style.background = colors[c];
        item.appendChild(dot);

        const label = document.createElement('span');
        label.textContent = classNames[c].substring(0, 3);
        item.appendChild(label);

        legend.appendChild(item);
      }

      featurePanel.appendChild(legend);
      container.appendChild(featurePanel);

      // Draw after DOM insertion with actual data
      requestAnimationFrame(() => drawGaussianCurve(canvas, data, d));
    }
  }

  // Compute 2D covariance matrix for a specific class and dimensions
  function compute2DCovMatrix(data, classIdx, dimX, dimY) {
    const classData = data.filter(d => d.class === classIdx);
    const n = classData.length;
    if (n === 0) return { covXX: 1, covYY: 1, covXY: 0 };

    // Compute means
    let meanX = 0, meanY = 0;
    for (const d of classData) {
      meanX += d.features[dimX];
      meanY += d.features[dimY];
    }
    meanX /= n;
    meanY /= n;

    // Compute covariance
    let covXX = 0, covYY = 0, covXY = 0;
    for (const d of classData) {
      const dx = d.features[dimX] - meanX;
      const dy = d.features[dimY] - meanY;
      covXX += dx * dx;
      covYY += dy * dy;
      covXY += dx * dy;
    }
    covXX /= n;
    covYY /= n;
    covXY /= n;

    return { covXX, covYY, covXY, meanX, meanY };
  }

  // Draw rotated Gaussian ellipse using eigenvalue decomposition
  // Correctly handles non-uniform scaling between X and Y axes
  function drawEllipse(ctx, centerX, centerY, covXX, covYY, covXY, w, h, pad, minX, maxX, minY, maxY, color, alpha = 0.2, nstd = 2) {
    // Transform center to canvas coordinates
    const cx = pad + ((centerX - minX) / (maxX - minX)) * (w - 2 * pad);
    const cy = h - pad - ((centerY - minY) / (maxY - minY)) * (h - 2 * pad);

    // Calculate scale factors for X and Y axes
    const scaleX = (w - 2 * pad) / (maxX - minX);
    const scaleY = (h - 2 * pad) / (maxY - minY);

    // Transform covariance matrix to canvas space
    // This accounts for different scaling and Y-axis inversion
    const covXX_canvas = covXX * scaleX * scaleX;
    const covYY_canvas = covYY * scaleY * scaleY;
    const covXY_canvas = covXY * scaleX * scaleY * (-1); // Negate for Y-axis flip

    // Eigenvalue decomposition in canvas space
    const a = covXX_canvas, b = covXY_canvas, c = covXY_canvas, d = covYY_canvas;
    const trace = a + d;
    const det = a * d - b * c;
    const discriminant = Math.sqrt(Math.max(0, trace * trace / 4 - det));

    const lambda1 = trace / 2 + discriminant;
    const lambda2 = trace / 2 - discriminant;

    // Eigenvector for larger eigenvalue (lambda1) - now in canvas space
    // Eigenvector is [covXY, Œª‚ÇÅ - covXX] = [b, lambda1 - a]
    let angle;
    if (Math.abs(b) < 1e-10) {
      // No covariance, ellipse aligned with axes
      angle = a >= d ? 0 : Math.PI / 2;
    } else {
      // General case: eigenvector direction
      angle = Math.atan2(lambda1 - a, b);  // atan2(y-component, x-component)
    }

    // Radii - already in canvas space from transformed eigenvalues
    const rx = nstd * Math.sqrt(lambda1);
    const ry = nstd * Math.sqrt(lambda2);

    ctx.save();
    ctx.translate(cx, cy);
    ctx.rotate(angle);

    ctx.beginPath();
    ctx.ellipse(0, 0, rx, ry, 0, 0, Math.PI * 2);

    ctx.fillStyle = color + Math.floor(alpha * 255).toString(16).padStart(2, '0');
    ctx.fill();

    // Make red ellipse strokes more visible
    const strokeAlpha = color.toLowerCase() === '#ff6b6b' ? 0.75 : Math.min(1.0, alpha * 3.5);
    ctx.strokeStyle = color + Math.floor(strokeAlpha * 255).toString(16).padStart(2, '0');
    ctx.lineWidth = 2.5;
    ctx.stroke();

    ctx.restore();
  }

  // Draw scatter plot
  function drawScatter(canvas, data, dimX, dimY) {
    const ctx = canvas.getContext('2d');
    const rect = canvas.getBoundingClientRect();
    const dpr = window.devicePixelRatio || 1;

    canvas.width = rect.width * dpr;
    canvas.height = rect.height * dpr;

    ctx.scale(dpr, dpr);

    const w = rect.width;
    const h = rect.height;

    // Clear
    ctx.fillStyle = '#1b1f27';
    ctx.fillRect(0, 0, w, h);

    const colors = ['#ff6b6b', '#4ecdc4', '#ffe66d'];
    const pad = 35;

    // Get data ranges
    let minX = Infinity, maxX = -Infinity;
    let minY = Infinity, maxY = -Infinity;
    for (const d of data) {
      if (d.features[dimX] < minX) minX = d.features[dimX];
      if (d.features[dimX] > maxX) maxX = d.features[dimX];
      if (d.features[dimY] < minY) minY = d.features[dimY];
      if (d.features[dimY] > maxY) maxY = d.features[dimY];
    }

    // Add padding to ranges
    const rangeX = maxX - minX;
    const rangeY = maxY - minY;
    minX -= rangeX * 0.1;
    maxX += rangeX * 0.1;
    minY -= rangeY * 0.1;
    maxY += rangeY * 0.1;

    // Draw grid
    ctx.strokeStyle = '#30363d';
    ctx.lineWidth = 0.5;
    for (let i = 0; i <= 4; i++) {
      const x = pad + (i / 4) * (w - 2 * pad);
      const y = h - pad - (i / 4) * (h - 2 * pad);
      ctx.beginPath();
      ctx.moveTo(x, pad);
      ctx.lineTo(x, h - pad);
      ctx.stroke();
      ctx.beginPath();
      ctx.moveTo(pad, y);
      ctx.lineTo(w - pad, y);
      ctx.stroke();
    }

    // Draw axes
    ctx.strokeStyle = '#4b5563';
    ctx.lineWidth = 1.5;
    ctx.beginPath();
    ctx.moveTo(pad, h - pad);
    ctx.lineTo(w - pad, h - pad);
    ctx.moveTo(pad, pad);
    ctx.lineTo(pad, h - pad);
    ctx.stroke();

    // Draw Gaussian ellipses if enabled
    if (ellipseMode > 0) {
      for (let c = 0; c < 3; c++) {
        const cov = compute2DCovMatrix(data, c, dimX, dimY);
        const nstd = ellipseMode; // 1 for 1œÉ, 2 for 2œÉ
        const alpha = ellipseMode === 1 ? 0.2 : 0.15; // Slightly more opaque for 1œÉ
        drawEllipse(ctx, cov.meanX, cov.meanY, cov.covXX, cov.covYY, cov.covXY,
                    w, h, pad, minX, maxX, minY, maxY, colors[c], alpha, nstd);
      }
    }

    // Draw points
    for (const d of data) {
      const x = pad + ((d.features[dimX] - minX) / (maxX - minX)) * (w - 2 * pad);
      const y = h - pad - ((d.features[dimY] - minY) / (maxY - minY)) * (h - 2 * pad);

      ctx.fillStyle = colors[d.class];
      ctx.beginPath();
      ctx.arc(x, y, 4, 0, Math.PI * 2);
      ctx.fill();

      // Add subtle stroke
      ctx.strokeStyle = 'rgba(0,0,0,0.3)';
      ctx.lineWidth = 0.5;
      ctx.stroke();
    }

    // Axis labels
    ctx.fillStyle = '#8b949e';
    ctx.font = '10px system-ui';
    ctx.textAlign = 'left';
    ctx.fillText(minX.toFixed(1), pad - 5, h - pad + 15);
    ctx.textAlign = 'right';
    ctx.fillText(maxX.toFixed(1), w - pad + 5, h - pad + 15);

    ctx.textAlign = 'right';
    ctx.fillText(minY.toFixed(1), pad - 5, h - pad + 5);
    ctx.fillText(maxY.toFixed(1), pad - 5, pad + 5);
  }

  // Draw mean vector visualization
  function drawMeanVector(canvas, data) {
    if (!canvas) return;

    const ctx = canvas.getContext('2d');
    const dpr = window.devicePixelRatio || 1;

    // Use fixed dimensions from CSS
    const w = 400;
    const h = 320;

    canvas.width = w * dpr;
    canvas.height = h * dpr;
    ctx.scale(dpr, dpr);

    const pad = 40;

    // Clear
    ctx.fillStyle = '#0d1117';
    ctx.fillRect(0, 0, w, h);

    // Filter only Setosa class (class 0) for clarity
    const setosaData = data.filter(d => d.class === 0);

    // Use Petal Length (index 2) and Petal Width (index 3)
    const dimX = 2; // Petal Length
    const dimY = 3; // Petal Width

    // Calculate mean for all 4 dimensions
    let sum = [0, 0, 0, 0];
    for (const d of setosaData) {
      for (let i = 0; i < 4; i++) {
        sum[i] += d.features[i];
      }
    }
    const mean4D = sum.map(s => s / setosaData.length);
    const meanX = mean4D[dimX];
    const meanY = mean4D[dimY];

    // Update all mean values in the UI
    const els = ['meanVector_SL', 'meanVector_SW', 'meanVector_PL', 'meanVector_PW'];
    els.forEach((id, i) => {
      const el = document.getElementById(id);
      if (el) el.textContent = mean4D[i].toFixed(2);
    });

    // Get data ranges (include origin)
    let minX = 0, maxX = -Infinity;
    let minY = 0, maxY = -Infinity;
    for (const d of setosaData) {
      if (d.features[dimX] > maxX) maxX = d.features[dimX];
      if (d.features[dimY] > maxY) maxY = d.features[dimY];
    }

    // Add padding
    const rangeX = maxX - minX;
    const rangeY = maxY - minY;
    maxX += rangeX * 0.2;
    maxY += rangeY * 0.2;

    // Helper to convert data coords to canvas coords
    function toCanvasX(x) {
      return pad + ((x - minX) / (maxX - minX)) * (w - 2 * pad);
    }
    function toCanvasY(y) {
      return h - pad - ((y - minY) / (maxY - minY)) * (h - 2 * pad);
    }

    // Draw grid
    ctx.strokeStyle = '#21262d';
    ctx.lineWidth = 1;
    for (let i = 0; i <= 5; i++) {
      const x = pad + (i / 5) * (w - 2 * pad);
      const y = h - pad - (i / 5) * (h - 2 * pad);
      ctx.beginPath();
      ctx.moveTo(x, pad);
      ctx.lineTo(x, h - pad);
      ctx.stroke();
      ctx.beginPath();
      ctx.moveTo(pad, y);
      ctx.lineTo(w - pad, y);
      ctx.stroke();
    }

    // Draw axes
    ctx.strokeStyle = '#58a6ff';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(toCanvasX(0), toCanvasY(0));
    ctx.lineTo(toCanvasX(maxX), toCanvasY(0));
    ctx.stroke();
    ctx.beginPath();
    ctx.moveTo(toCanvasX(0), toCanvasY(0));
    ctx.lineTo(toCanvasX(0), toCanvasY(maxY));
    ctx.stroke();

    // Axis labels
    ctx.fillStyle = '#8b949e';
    ctx.font = '11px system-ui';
    ctx.textAlign = 'center';
    ctx.fillText('Petal Length (cm)', w / 2, h - 10);
    ctx.save();
    ctx.translate(12, h / 2);
    ctx.rotate(-Math.PI / 2);
    ctx.fillText('Petal Width (cm)', 0, 0);
    ctx.restore();

    // Draw points in light yellow
    for (const d of setosaData) {
      const x = toCanvasX(d.features[dimX]);
      const y = toCanvasY(d.features[dimY]);

      ctx.fillStyle = '#ffd97d'; // Light yellow
      ctx.beginPath();
      ctx.arc(x, y, 5, 0, Math.PI * 2);
      ctx.fill();

      ctx.strokeStyle = 'rgba(255, 217, 125, 0.4)';
      ctx.lineWidth = 1;
      ctx.stroke();
    }

    // Draw mean vector arrow
    const meanCanvasX = toCanvasX(meanX);
    const meanCanvasY = toCanvasY(meanY);
    const originX = toCanvasX(0);
    const originY = toCanvasY(0);

    // Arrow shaft - bright magenta for contrast
    ctx.strokeStyle = '#ff8800';
    ctx.lineWidth = 4;
    ctx.beginPath();
    ctx.moveTo(originX, originY);
    ctx.lineTo(meanCanvasX, meanCanvasY);
    ctx.stroke();

    // Arrow head
    const angle = Math.atan2(originY - meanCanvasY, meanCanvasX - originX);
    const headLen = 14;
    ctx.fillStyle = '#ff8800';
    ctx.beginPath();
    ctx.moveTo(meanCanvasX, meanCanvasY);
    ctx.lineTo(
      meanCanvasX - headLen * Math.cos(angle - Math.PI / 6),
      meanCanvasY + headLen * Math.sin(angle - Math.PI / 6)
    );
    ctx.lineTo(
      meanCanvasX - headLen * Math.cos(angle + Math.PI / 6),
      meanCanvasY + headLen * Math.sin(angle + Math.PI / 6)
    );
    ctx.closePath();
    ctx.fill();

    // Draw dotted lines to axes (showing x and y components)
    ctx.setLineDash([4, 4]);
    ctx.strokeStyle = '#ff8800';
    ctx.lineWidth = 2;

    // Vertical line down to x-axis (showing y-component)
    ctx.beginPath();
    ctx.moveTo(meanCanvasX, meanCanvasY);
    ctx.lineTo(meanCanvasX, originY);
    ctx.stroke();

    // Horizontal line left to y-axis (showing x-component)
    ctx.beginPath();
    ctx.moveTo(meanCanvasX, meanCanvasY);
    ctx.lineTo(originX, meanCanvasY);
    ctx.stroke();

    // Reset line dash
    ctx.setLineDash([]);

    // Label the mean point with frosted background
    const meanLabel = `Œº = (${meanX.toFixed(2)}, ${meanY.toFixed(2)})`;
    ctx.font = 'bold 13px system-ui';
    ctx.textAlign = 'left';
    const meanLabelWidth = ctx.measureText(meanLabel).width;

    // Frosted background
    ctx.fillStyle = 'rgba(13, 17, 23, 0.85)';
    ctx.strokeStyle = 'rgba(255, 136, 0, 0.3)';
    ctx.lineWidth = 1;
    const meanLabelX = meanCanvasX + 8;
    const meanLabelY = meanCanvasY - 22;
    ctx.beginPath();
    ctx.roundRect(meanLabelX - 4, meanLabelY, meanLabelWidth + 8, 20, 4);
    ctx.fill();
    ctx.stroke();

    // Text
    ctx.fillStyle = '#ff8800';
    ctx.fillText(meanLabel, meanLabelX, meanLabelY + 14);

    // Origin label with frosted background
    const originLabel = '(0, 0)';
    ctx.font = '11px system-ui';
    ctx.textAlign = 'right';
    const originLabelWidth = ctx.measureText(originLabel).width;

    // Frosted background
    ctx.fillStyle = 'rgba(13, 17, 23, 0.85)';
    ctx.strokeStyle = 'rgba(88, 166, 255, 0.3)';
    ctx.lineWidth = 1;
    const originLabelX = originX - 8 - originLabelWidth;
    const originLabelY = originY + 5;
    ctx.beginPath();
    ctx.roundRect(originLabelX - 4, originLabelY, originLabelWidth + 8, 18, 4);
    ctx.fill();
    ctx.stroke();

    // Text
    ctx.fillStyle = '#58a6ff';
    ctx.textAlign = 'right';
    ctx.fillText(originLabel, originX - 8, originY + 15);

    // Draw ticks on axes
    ctx.fillStyle = '#8b949e';
    ctx.font = '9px system-ui';
    ctx.textAlign = 'center';
    for (let i = 0; i <= 5; i++) {
      const val = (maxX / 5) * i;
      const x = toCanvasX(val);
      ctx.fillText(val.toFixed(1), x, h - pad + 15);
    }
    ctx.textAlign = 'right';
    for (let i = 0; i <= 5; i++) {
      const val = (maxY / 5) * i;
      const y = toCanvasY(val);
      if (i > 0) { // Skip origin to avoid overlap
        ctx.fillText(val.toFixed(1), pad - 8, y + 3);
      }
    }

    // Legend with frosted background
    const legendText = `‚ñ† Data points (n=${setosaData.length})`;
    ctx.font = '11px system-ui';
    ctx.textAlign = 'left';
    const legendWidth = ctx.measureText(legendText).width;

    // Frosted background
    ctx.fillStyle = 'rgba(13, 17, 23, 0.85)';
    ctx.strokeStyle = 'rgba(255, 217, 125, 0.3)';
    ctx.lineWidth = 1;
    const legendX = pad + 3;
    const legendY = pad - 22;
    ctx.beginPath();
    ctx.roundRect(legendX, legendY, legendWidth + 8, 18, 4);
    ctx.fill();
    ctx.stroke();

    // Text
    ctx.fillStyle = '#ffd97d';
    ctx.fillText(legendText, pad + 5, pad - 10);
  }

  // Initialize
  window.currentData = generateData();
  let currentData = window.currentData;
  const labels = ['Sepal L', 'Sepal W', 'Petal L', 'Petal W'];

  const canvases = [
    document.getElementById('canvas1'),
    document.getElementById('canvas2'),
    document.getElementById('canvas3'),
    document.getElementById('canvas4')
  ];

  const projections = [
    [0, 1], // Sepal L vs W
    [2, 3], // Petal L vs W
    [0, 2], // Sepal L vs Petal L
    [1, 3]  // Sepal W vs Petal W
  ];

  let ellipseMode = 0; // 0 = off, 1 = 1œÉ, 2 = 2œÉ

  // Draw all visualizations
  // Update flower icons based on actual data
  function updateFlowerIcons(data) {
    const tuning = window.flowerTuning || {
      petalBaseRadius: 1.5,
      petalLengthScale: 2.0,
      petalWidthScale: 2.4,
      setosaGain: 2.0,
      sepalSizeMin: 5,
      sepalSizeRange: 1.5,
      sepalRoundness: 20,
      sepalGreen: '#11df11',
      labelSpacing: 30,
      interFlowerLabelSpacing: 7
    };

    for (let c = 0; c < 3; c++) {
      const classData = data.filter(d => d.class === c);

      // Calculate mean values for all four features
      const meanSepalLength = classData.reduce((sum, d) => sum + d.features[0], 0) / classData.length;
      const meanSepalWidth = classData.reduce((sum, d) => sum + d.features[1], 0) / classData.length;
      const meanPetalLength = classData.reduce((sum, d) => sum + d.features[2], 0) / classData.length;
      const meanPetalWidth = classData.reduce((sum, d) => sum + d.features[3], 0) / classData.length;

      // Sepal: length 4-8cm ‚Üí size, roundness controlled by slider
      const sepalSize = tuning.sepalSizeMin + (meanSepalLength - 4) * tuning.sepalSizeRange;
      const sepalRoundness = tuning.sepalRoundness; // User-controlled roundness

      // Petal dimensions based on actual measurements
      // Petal length: 1-7cm, Petal width: 0.1-2.5cm
      const rawPetalLength = 1 + (meanPetalLength - 1) * 1.5;  // Data-driven length
      const rawPetalWidth = 1 + (meanPetalWidth - 0.1) * 1.5;  // Data-driven width

      // Apply global scales and Setosa-specific gain
      const setosaMultiplier = (c === 0) ? tuning.setosaGain : 1.0;
      const petalLength = rawPetalLength * tuning.petalLengthScale * setosaMultiplier;
      const petalWidth = rawPetalWidth * tuning.petalWidthScale * setosaMultiplier;

      const flower = document.getElementById(`flower-${c}`);
      const sepal = flower.querySelector('.sepal');
      const petals = flower.querySelectorAll('.petal');

      // Style the single central sepal (behind petals)
      sepal.style.width = `${sepalSize}px`;
      sepal.style.height = `${sepalSize}px`;
      sepal.style.borderRadius = `${sepalRoundness}%`;
      sepal.style.background = tuning.sepalGreen;

      // Position and style petals - they "grow" from petalBaseRadius
      petals.forEach((petal, i) => {
        // Petals start at petalBaseRadius from center and extend outward by petalLength
        // The base (attachment point) is invisible, covered by sepal
        const attachmentRadius = tuning.petalBaseRadius;

        if (i === 0) { // top - grows upward (vertical)
          petal.style.width = `${petalWidth}px`;
          petal.style.height = `${petalLength}px`;
          petal.style.bottom = '50%';
          petal.style.left = '50%';
          petal.style.transform = `translateX(-50%) translateY(-${attachmentRadius}px)`;
          petal.style.transformOrigin = `center bottom`;
        } else if (i === 1) { // bottom - grows downward (vertical)
          petal.style.width = `${petalWidth}px`;
          petal.style.height = `${petalLength}px`;
          petal.style.top = '50%';
          petal.style.left = '50%';
          petal.style.transform = `translateX(-50%) translateY(${attachmentRadius}px)`;
          petal.style.transformOrigin = `center top`;
        } else if (i === 2) { // left - grows leftward (horizontal - swap dimensions)
          petal.style.width = `${petalLength}px`;
          petal.style.height = `${petalWidth}px`;
          petal.style.top = '50%';
          petal.style.right = '50%';
          petal.style.transform = `translateY(-50%) translateX(-${attachmentRadius}px)`;
          petal.style.transformOrigin = `right center`;
        } else { // right - grows rightward (horizontal - swap dimensions)
          petal.style.width = `${petalLength}px`;
          petal.style.height = `${petalWidth}px`;
          petal.style.top = '50%';
          petal.style.left = '50%';
          petal.style.transform = `translateY(-50%) translateX(${attachmentRadius}px)`;
          petal.style.transformOrigin = `left center`;
        }
      });
    }
  }

  // Track selected species and feature for histogram
  let selectedHistogramSpecies = null;
  let selectedHistogramFeature = 2; // Default to Petal Length

  // Draw GMM histogram showing feature distribution
  function drawGMMHistogram(filterSpecies = null) {
    const canvas = document.getElementById('gmmHistogram');
    if (!canvas || !window.currentData) {
      return;
    }

    // Check if panel is visible
    const panel = document.getElementById('dataInfoPanel');
    const isVisible = panel && panel.style.display !== 'none';
    if (!isVisible) {
      return; // Panel is hidden, don't waste time drawing
    }

    const ctx = canvas.getContext('2d');
    const width = canvas.width;
    const height = canvas.height;
    const padding = 40;
    const plotWidth = width - 2 * padding;
    const plotHeight = height - 2 * padding;

    // Clear canvas
    ctx.clearRect(0, 0, width, height);

    // Use selected feature
    const featureIndex = selectedHistogramFeature;
    const speciesData = [[], [], []];
    const colors = ['#d14545', '#4ecdc4', '#ffe66d'];
    const speciesNames = ['Setosa', 'Versicolor', 'Virginica'];
    const featureNames = ['Sepal Length', 'Sepal Width', 'Petal Length', 'Petal Width'];

    window.currentData.forEach(d => {
      speciesData[d.class].push(d.features[featureIndex]);
    });

    // Update title based on filter
    const titleEl = document.getElementById('gmmHistogramTitle');
    if (titleEl) {
      if (filterSpecies !== null) {
        titleEl.textContent = `${featureNames[featureIndex]} - ${speciesNames[filterSpecies]}`;
        titleEl.style.color = colors[filterSpecies];
      } else {
        titleEl.textContent = `${featureNames[featureIndex]} - All Species`;
        titleEl.style.color = 'var(--muted)';
      }
    }

    // Find global min/max for binning
    const allValues = speciesData.flat();
    const minVal = Math.min(...allValues);
    const maxVal = Math.max(...allValues);
    const range = maxVal - minVal;

    // Create bins
    const numBins = 25;
    const binWidth = range / numBins;
    const bins = Array(numBins).fill(0).map(() => [0, 0, 0]); // [count_species0, count_species1, count_species2]

    // Fill bins
    for (let s = 0; s < 3; s++) {
      speciesData[s].forEach(val => {
        const binIndex = Math.min(Math.floor((val - minVal) / binWidth), numBins - 1);
        bins[binIndex][s]++;
      });
    }

    // Find max count for scaling
    const maxCount = Math.max(...bins.map(b => Math.max(...b)));

    // Draw axes
    ctx.strokeStyle = '#666';
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(padding, padding);
    ctx.lineTo(padding, height - padding);
    ctx.lineTo(width - padding, height - padding);
    ctx.stroke();

    // Draw bars (overlapping semi-transparent or single species)
    if (filterSpecies !== null) {
      // Show only selected species
      ctx.fillStyle = colors[filterSpecies];
      for (let i = 0; i < numBins; i++) {
        const x = padding + (i / numBins) * plotWidth;
        const barWidth = plotWidth / numBins;
        const barHeight = (bins[i][filterSpecies] / maxCount) * plotHeight;
        const y = height - padding - barHeight;
        ctx.fillRect(x, y, barWidth, barHeight);
      }
    } else {
      // Show all species with transparency
      for (let s = 0; s < 3; s++) {
        ctx.fillStyle = colors[s] + '80'; // Add transparency
        for (let i = 0; i < numBins; i++) {
          const x = padding + (i / numBins) * plotWidth;
          const barWidth = plotWidth / numBins;
          const barHeight = (bins[i][s] / maxCount) * plotHeight;
          const y = height - padding - barHeight;
          ctx.fillRect(x, y, barWidth, barHeight);
        }
      }
    }

    // Draw labels
    ctx.fillStyle = '#8b949e';
    ctx.font = '11px -apple-system, BlinkMacSystemFont, sans-serif';
    ctx.textAlign = 'center';

    // X-axis label
    ctx.fillText('Value (cm)', width / 2, height - 5);

    // Y-axis label
    ctx.save();
    ctx.translate(10, height / 2);
    ctx.rotate(-Math.PI / 2);
    ctx.fillText('Count', 0, 0);
    ctx.restore();

    // X-axis ticks
    ctx.textAlign = 'center';
    ctx.fillText(minVal.toFixed(1), padding, height - padding + 15);
    ctx.fillText(maxVal.toFixed(1), width - padding, height - padding + 15);
    ctx.fillText(((minVal + maxVal) / 2).toFixed(1), width / 2, height - padding + 15);
  }

  function drawAll(data) {
    // Update window.currentData for functions that rely on it
    window.currentData = data;

    projections.forEach((proj, i) => {
      drawScatter(canvases[i], data, proj[0], proj[1]);
    });
    renderCorrelationMatrix(data);
    renderGMMParams(data);
    renderGaussianEquation(data);
    updateFlowerIcons(data);
    drawEllipseCalculation(data);
    if (typeof updateMahalanobisViz === 'function') {
      updateMahalanobisViz(data);
    }
    if (typeof drawComparativePrecisionExamples === 'function') {
      drawComparativePrecisionExamples();
    }
    if (typeof drawGMMHistogram === 'function') {
      drawGMMHistogram(selectedHistogramSpecies);
    }
    if (typeof drawCholeskyExample === 'function') {
      drawCholeskyExample();
    }
  }

  // Add click handlers for species and feature selection in decision tree
  document.addEventListener('DOMContentLoaded', () => {
    const speciesBranches = document.querySelectorAll('.species-branch');
    const featureSelectors = document.querySelectorAll('.feature-select');

    // Species selection
    speciesBranches.forEach(branch => {
      branch.addEventListener('click', function() {
        const species = parseInt(this.getAttribute('data-species'));
        selectedHistogramSpecies = species;

        // Highlight selected branch
        speciesBranches.forEach(b => {
          const rect = b.querySelector('rect');
          if (rect) {
            rect.setAttribute('stroke-width', '1.5');
          }
        });
        const selectedRect = this.querySelector('rect');
        if (selectedRect) {
          selectedRect.setAttribute('stroke-width', '3');
        }

        if (typeof drawGMMHistogram === 'function') {
          drawGMMHistogram(species);
        }
      });
    });

    // Feature selection
    featureSelectors.forEach(selector => {
      selector.addEventListener('click', function() {
        const feature = parseInt(this.getAttribute('data-feature'));
        selectedHistogramFeature = feature;

        // Highlight selected feature
        featureSelectors.forEach(f => {
          const rect = f.querySelector('rect');
          if (rect) {
            rect.setAttribute('stroke-width', '1');
            rect.setAttribute('fill', 'rgba(138, 180, 248, 0.1)');
          }
        });
        const selectedRect = this.querySelector('rect');
        if (selectedRect) {
          selectedRect.setAttribute('stroke-width', '2');
          selectedRect.setAttribute('fill', 'rgba(138, 180, 248, 0.25)');
        }

        if (typeof drawGMMHistogram === 'function') {
          drawGMMHistogram(selectedHistogramSpecies);
        }
      });
    });

    // Set initial highlight for Petal Length (feature 2)
    const initialFeature = Array.from(featureSelectors).find(f => f.getAttribute('data-feature') === '2');
    if (initialFeature) {
      const rect = initialFeature.querySelector('rect');
      if (rect) {
        rect.setAttribute('stroke-width', '2');
        rect.setAttribute('fill', 'rgba(138, 180, 248, 0.25)');
      }
    }

    // Click histogram to reset species filter (keep feature selection)
    const histCanvas = document.getElementById('gmmHistogram');
    if (histCanvas) {
      histCanvas.addEventListener('click', () => {
        selectedHistogramSpecies = null;

        // Reset branch highlighting
        speciesBranches.forEach(b => {
          const rect = b.querySelector('rect');
          if (rect) {
            rect.setAttribute('stroke-width', '1.5');
          }
        });

        if (typeof drawGMMHistogram === 'function') {
          drawGMMHistogram(null);
        }
      });
    }
  });

  // Draw ellipse calculation visualization for Versicolor
  function drawEllipseCalculation(data) {
    const canvas = document.getElementById('ellipseCalcCanvas');
    if (!canvas) return;

    const ctx = canvas.getContext('2d');

    // Set canvas resolution to match display size for crisp rendering
    const rect = canvas.getBoundingClientRect();
    const dpr = window.devicePixelRatio || 1;
    canvas.width = rect.width * dpr;
    canvas.height = rect.height * dpr;
    ctx.scale(dpr, dpr);

    const w = rect.width;
    const h = rect.height;

    ctx.clearRect(0, 0, w, h);

    // Use the SAME function that draws the scatter plot ellipse!
    const dimX = 0; // Sepal Length
    const dimY = 1; // Sepal Width
    const classIdx = 1; // Versicolor

    // Get the exact same covariance data used in the first scatter plot
    const cov = compute2DCovMatrix(data, classIdx, dimX, dimY);
    const meanX = cov.meanX;
    const meanY = cov.meanY;
    const covXX = cov.covXX;
    const covYY = cov.covYY;
    const covXY = cov.covXY;

    const versicolorData = data.filter(d => d.class === classIdx);
    const n = versicolorData.length;

    // Get data range from ALL data (same as scatter plot) so we can see spread changes!
    let minX = Infinity, maxX = -Infinity;
    let minY = Infinity, maxY = -Infinity;
    for (const d of data) {
      if (d.features[dimX] < minX) minX = d.features[dimX];
      if (d.features[dimX] > maxX) maxX = d.features[dimX];
      if (d.features[dimY] < minY) minY = d.features[dimY];
      if (d.features[dimY] > maxY) maxY = d.features[dimY];
    }

    // Add padding to ranges (same as scatter plot)
    const rangeX = maxX - minX || 1;
    const rangeY = maxY - minY || 1;
    minX -= rangeX * 0.05;
    maxX += rangeX * 0.05;
    minY -= rangeY * 0.05;
    maxY += rangeY * 0.05;

    // Eigenvalue decomposition
    const trace = covXX + covYY;
    const det = covXX * covYY - covXY * covXY;
    const lambda1 = trace / 2 + Math.sqrt((trace * trace) / 4 - det);
    const lambda2 = trace / 2 - Math.sqrt((trace * trace) / 4 - det);
    const angle = Math.atan2(lambda1 - covXX, covXY);

    // Left side: Show the calculation steps
    const leftMargin = 20;
    const leftWidth = w * 0.38;
    let y = 30;
    const lineHeight = 18;

    ctx.fillStyle = '#4ecdc4';
    ctx.font = 'bold 11px system-ui';
    ctx.fillText('Step 1: Calculate Mean Œº', leftMargin, y);
    y += lineHeight;

    ctx.fillStyle = '#8b949e';
    ctx.font = '10px monospace';
    ctx.fillText(`Œº = [${meanX.toFixed(2)}, ${meanY.toFixed(2)}]`, leftMargin + 5, y);
    y += lineHeight + 6;

    ctx.fillStyle = '#4ecdc4';
    ctx.font = 'bold 11px system-ui';
    ctx.fillText('Step 2: Covariance Matrix Œ£', leftMargin, y);
    y += lineHeight;

    ctx.fillStyle = '#8b949e';
    ctx.font = '9px monospace';
    ctx.fillText(`‚îå ${covXX.toFixed(3)}  ${covXY.toFixed(3)} ‚îê`, leftMargin + 5, y);
    y += 14;
    ctx.fillText(`‚îî ${covXY.toFixed(3)}  ${covYY.toFixed(3)} ‚îò`, leftMargin + 5, y);
    y += 14;

    // Get axis scale for showing modified covariance
    const s = gmmConfig.ellipseAxisScale;
    const origDet = covXX * covYY - covXY * covXY;
    if (s < 0.99) {
      ctx.fillStyle = '#f78166';
      ctx.font = '8px monospace';
      ctx.fillText(`det(Œ£) ‚Üí det(Œ£') = ${origDet.toFixed(3)} √ó ${(s*s).toFixed(2)}`, leftMargin + 5, y);
      y += 12;
      const newDet = origDet * s * s;
      if (newDet < 0.001) {
        ctx.fillText(`         = ${newDet.toFixed(4)} ‚âà 0 (singular!)`, leftMargin + 5, y);
      }
    }
    y += lineHeight + 6;

    ctx.fillStyle = '#4ecdc4';
    ctx.font = 'bold 11px system-ui';
    ctx.fillText('Step 3: Eigendecomposition', leftMargin, y);
    y += lineHeight;

    ctx.fillStyle = '#8b949e';
    ctx.font = '9px monospace';
    ctx.fillText(`Œª‚ÇÅ = ${lambda1.toFixed(3)} (major axis)`, leftMargin + 5, y);
    y += 14;
    const lambda2Scaled = lambda2 * s * s;
    if (s < 0.99) {
      ctx.fillText(`Œª‚ÇÇ = ${lambda2.toFixed(3)} √ó ${(s*s).toFixed(2)} = ${lambda2Scaled.toFixed(3)}`, leftMargin + 5, y);
    } else {
      ctx.fillText(`Œª‚ÇÇ = ${lambda2.toFixed(3)} (minor axis)`, leftMargin + 5, y);
    }
    y += 14;
    ctx.fillText(`Œ∏ = ${(angle * 180 / Math.PI).toFixed(1)}¬∞ (rotation)`, leftMargin + 5, y);
    y += lineHeight + 6;

    ctx.fillStyle = '#4ecdc4';
    ctx.font = 'bold 11px system-ui';
    ctx.fillText('Step 4: Draw Ellipse', leftMargin, y);
    y += lineHeight;

    ctx.fillStyle = '#8b949e';
    ctx.font = '9px monospace';
    const axis1 = (2 * Math.sqrt(lambda1)).toFixed(2);
    const axis2 = (2 * Math.sqrt(lambda2) * gmmConfig.ellipseAxisScale).toFixed(2);
    ctx.fillText(`Semi-axes: 2‚àöŒª‚ÇÅ, 2‚àöŒª‚ÇÇ√óscale`, leftMargin + 5, y);
    y += 14;
    ctx.fillText(`= ${axis1}, ${axis2}`, leftMargin + 5, y);

    // Add live data indicator
    y += lineHeight + 8;
    ctx.fillStyle = '#f78166';
    ctx.font = 'bold 9px system-ui';
    ctx.fillText('Current Settings:', leftMargin, y);
    y += 14;
    ctx.fillStyle = '#8b949e';
    ctx.font = '9px monospace';
    ctx.fillText(`Spread: ${gmmConfig.spreadMultiplier.toFixed(1)}x`, leftMargin + 5, y);
    y += 12;
    ctx.fillText(`Separation: ${gmmConfig.separationMultiplier.toFixed(1)}x`, leftMargin + 5, y);
    y += 12;
    ctx.fillText(`Samples: ${n}`, leftMargin + 5, y);

    // Right side: Draw the actual ellipse visualization
    const vizLeft = leftWidth + 40;
    const vizTop = 20;
    const vizWidth = w - vizLeft - 20;
    const vizHeight = h - 40;
    const vizPad = 35;

    // Helper to convert data coordinates to canvas coordinates
    const toCanvasX = (val) => vizLeft + vizPad + ((val - minX) / (maxX - minX)) * (vizWidth - 2 * vizPad);
    const toCanvasY = (val) => vizTop + vizHeight - vizPad - ((val - minY) / (maxY - minY)) * (vizHeight - 2 * vizPad);

    // Draw axes
    ctx.strokeStyle = '#30363d';
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(vizLeft + vizPad, vizTop + vizPad);
    ctx.lineTo(vizLeft + vizPad, vizTop + vizHeight - vizPad);
    ctx.lineTo(vizLeft + vizWidth - vizPad, vizTop + vizHeight - vizPad);
    ctx.stroke();

    // Draw only Versicolor data points
    for (const d of versicolorData) {
      const px = toCanvasX(d.features[dimX]);
      const py = toCanvasY(d.features[dimY]);
      ctx.fillStyle = 'rgba(78, 205, 196, 0.5)';
      ctx.beginPath();
      ctx.arc(px, py, 3, 0, Math.PI * 2);
      ctx.fill();
    }

    // Draw mean point
    const meanPx = toCanvasX(meanX);
    const meanPy = toCanvasY(meanY);
    ctx.fillStyle = '#4ecdc4';
    ctx.beginPath();
    ctx.arc(meanPx, meanPy, 4, 0, Math.PI * 2);
    ctx.fill();

    // Draw eigenvectors in data space
    const scale = (maxX - minX) / (vizWidth - 2 * vizPad);
    const ev1X = Math.cos(angle) * Math.sqrt(lambda1);
    const ev1Y = Math.sin(angle) * Math.sqrt(lambda1);
    const ev2X = -Math.sin(angle) * Math.sqrt(lambda2) * gmmConfig.ellipseAxisScale;
    const ev2Y = Math.cos(angle) * Math.sqrt(lambda2) * gmmConfig.ellipseAxisScale;

    const ev1EndX = toCanvasX(meanX + ev1X);
    const ev1EndY = toCanvasY(meanY + ev1Y);
    const ev2EndX = toCanvasX(meanX + ev2X);
    const ev2EndY = toCanvasY(meanY + ev2Y);

    ctx.strokeStyle = '#f78166';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(meanPx, meanPy);
    ctx.lineTo(ev1EndX, ev1EndY);
    ctx.stroke();

    ctx.strokeStyle = '#58a6ff';
    ctx.beginPath();
    ctx.moveTo(meanPx, meanPy);
    ctx.lineTo(ev2EndX, ev2EndY);
    ctx.stroke();

    // Draw ellipse (2-sigma) with axis scaling
    ctx.strokeStyle = '#4ecdc4';
    ctx.lineWidth = 2;
    ctx.beginPath();
    for (let t = 0; t <= Math.PI * 2; t += 0.1) {
      const r1 = 2 * Math.sqrt(lambda1);
      const r2 = 2 * Math.sqrt(lambda2) * gmmConfig.ellipseAxisScale;
      const dataX = meanX + r1 * Math.cos(t) * Math.cos(angle) - r2 * Math.sin(t) * Math.sin(angle);
      const dataY = meanY + r1 * Math.cos(t) * Math.sin(angle) + r2 * Math.sin(t) * Math.cos(angle);
      const x = toCanvasX(dataX);
      const y = toCanvasY(dataY);
      if (t === 0) ctx.moveTo(x, y);
      else ctx.lineTo(x, y);
    }
    ctx.closePath();
    ctx.stroke();

    // Labels with bounds checking
    ctx.fillStyle = '#8b949e';
    ctx.font = '9px system-ui';
    ctx.textAlign = 'left';

    // Mean label
    const meanLabelX = Math.min(Math.max(meanPx + 6, vizLeft + vizPad + 2), vizLeft + vizWidth - vizPad - 10);
    const meanLabelY = Math.min(Math.max(meanPy - 6, vizTop + vizPad + 10), vizTop + vizHeight - vizPad - 2);
    ctx.fillText('Œº', meanLabelX, meanLabelY);

    // Eigenvector labels
    ctx.fillStyle = '#f78166';
    const v1LabelX = Math.min(Math.max(ev1EndX + 3, vizLeft + vizPad + 2), vizLeft + vizWidth - vizPad - 15);
    const v1LabelY = Math.min(Math.max(ev1EndY, vizTop + vizPad + 10), vizTop + vizHeight - vizPad - 2);
    ctx.fillText('v‚ÇÅ', v1LabelX, v1LabelY);

    ctx.fillStyle = '#58a6ff';
    const v2LabelX = Math.min(Math.max(ev2EndX + 3, vizLeft + vizPad + 2), vizLeft + vizWidth - vizPad - 15);
    const v2LabelY = Math.min(Math.max(ev2EndY, vizTop + vizPad + 10), vizTop + vizHeight - vizPad - 2);
    ctx.fillText('v‚ÇÇ', v2LabelX, v2LabelY);

    // Axis labels
    ctx.fillStyle = '#8b949e';
    ctx.font = '9px system-ui';

    // X-axis labels (bottom)
    ctx.textAlign = 'center';
    ctx.fillText(minX.toFixed(1), vizLeft + vizPad, vizTop + vizHeight - vizPad + 15);
    ctx.fillText(maxX.toFixed(1), vizLeft + vizWidth - vizPad, vizTop + vizHeight - vizPad + 15);

    // Y-axis labels (left side)
    ctx.textAlign = 'right';
    ctx.fillText(minY.toFixed(1), vizLeft + vizPad - 8, vizTop + vizHeight - vizPad + 4);
    ctx.fillText(maxY.toFixed(1), vizLeft + vizPad - 8, vizTop + vizPad + 4);
  }

  // Full regenerate
  function regenerateAll() {
    editableCorr = null;
    document.getElementById('corrModeIndicator').style.display = 'none';
    currentData = generateData();
    drawAll(currentData);

    // Notify parent window if we're in an iframe
    if (window.parent !== window) {
      window.parent.postMessage({
        type: 'dataRegenerated',
        data: currentData
      }, '*');
    }
  }

  // Check if we're in an iframe and adjust layout
  const isInIframe = window.self !== window.top;
  if (isInIframe) {
    // Force margin notes to be inline when in iframe
    const style = document.createElement('style');
    style.textContent = `
      .margin-note {
        position: static !important;
        width: 100% !important;
        margin: 8px 0 !important;
      }
      .equation-panel {
        position: relative !important;
        overflow: visible !important;
      }
      body {
        padding: 8px !important;
      }
    `;
    document.head.appendChild(style);

    // Add indicator that this is embedded view
    const info = document.querySelector('.info');
    if (info) {
      info.innerHTML += ' <span style="font-size: 9px; color: var(--muted);">(Embedded View)</span>';
    }
  }

  // Initial draw
  drawAll(currentData);

  // Draw histogram on initial load (after a brief delay to ensure canvas is ready)
  setTimeout(() => {
    if (typeof drawGMMHistogram === 'function') {
      drawGMMHistogram(selectedHistogramSpecies);
    }
  }, 100);

  // IIFE: Flower tuning controls (for development/tweaking)
  (function() {
    const controlsDiv = document.createElement('div');
    controlsDiv.id = 'flowerTuning';
    controlsDiv.style.cssText = `
      position: fixed;
      top: 10px;
      right: 10px;
      background: var(--panel);
      border: 1px solid var(--grid);
      border-radius: 6px;
      padding: 12px;
      z-index: 9999;
      font-size: 11px;
      min-width: 220px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.3);
      display: none;
    `;

    const title = document.createElement('div');
    title.textContent = 'üå∏ Flower Tuning';
    title.style.cssText = 'font-weight: 600; margin-bottom: 8px; color: var(--text); text-align: center; font-size: 12px; user-select: none; cursor: move;';
    controlsDiv.appendChild(title);

    const closeBtn = document.createElement('button');
    closeBtn.textContent = '√ó';
    closeBtn.classList.add('close-btn-tuning');
    closeBtn.style.cssText = `
      position: absolute;
      top: 8px;
      right: 8px;
      background: transparent;
      border: none;
      color: var(--muted);
      font-size: 18px;
      cursor: pointer;
      padding: 0;
      width: 20px;
      height: 20px;
      line-height: 1;
    `;
    closeBtn.onmouseover = () => closeBtn.style.color = 'var(--text)';
    closeBtn.onmouseout = () => closeBtn.style.color = 'var(--muted)';
    closeBtn.onclick = () => controlsDiv.remove();
    controlsDiv.appendChild(closeBtn);

    function createSlider(label, key, min, max, step, onChange) {
      const container = document.createElement('div');
      container.style.marginBottom = '8px';

      const labelEl = document.createElement('div');
      labelEl.textContent = label;
      labelEl.style.cssText = 'margin-bottom: 3px; color: var(--muted); font-size: 10px;';
      container.appendChild(labelEl);

      const sliderContainer = document.createElement('div');
      sliderContainer.style.display = 'flex';
      sliderContainer.style.alignItems = 'center';
      sliderContainer.style.gap = '6px';

      const slider = document.createElement('input');
      slider.type = 'range';
      slider.min = min;
      slider.max = max;
      slider.step = step;
      slider.value = window.flowerTuning[key];
      slider.style.cssText = 'flex: 1; cursor: pointer;';

      const valueDisplay = document.createElement('span');
      valueDisplay.textContent = window.flowerTuning[key];
      valueDisplay.style.cssText = 'min-width: 35px; text-align: right; font-family: monospace; color: var(--text); font-size: 11px;';

      slider.oninput = function() {
        const val = parseFloat(this.value);
        window.flowerTuning[key] = val;
        valueDisplay.textContent = val;
        if (onChange) onChange(val);
        updateFlowerIcons(currentData);
      };

      sliderContainer.appendChild(slider);
      sliderContainer.appendChild(valueDisplay);
      container.appendChild(sliderContainer);

      return container;
    }

    function createColorPicker(label, key, onChange) {
      const container = document.createElement('div');
      container.style.marginBottom = '8px';

      const labelEl = document.createElement('div');
      labelEl.textContent = label;
      labelEl.style.cssText = 'margin-bottom: 3px; color: var(--muted); font-size: 10px;';
      container.appendChild(labelEl);

      const pickerContainer = document.createElement('div');
      pickerContainer.style.display = 'flex';
      pickerContainer.style.alignItems = 'center';
      pickerContainer.style.gap = '6px';

      const picker = document.createElement('input');
      picker.type = 'color';
      picker.value = window.flowerTuning[key];
      picker.style.cssText = 'width: 32px; height: 20px; border: 1px solid var(--grid); cursor: pointer; border-radius: 3px;';

      const valueDisplay = document.createElement('span');
      valueDisplay.textContent = window.flowerTuning[key];
      valueDisplay.style.cssText = 'font-family: monospace; color: var(--text); font-size: 10px;';

      picker.oninput = function() {
        window.flowerTuning[key] = this.value;
        valueDisplay.textContent = this.value;
        if (onChange) onChange(this.value);
        updateFlowerIcons(currentData);
      };

      pickerContainer.appendChild(picker);
      pickerContainer.appendChild(valueDisplay);
      container.appendChild(pickerContainer);

      return container;
    }

    // Add controls
    controlsDiv.appendChild(createSlider('Petal Base Radius', 'petalBaseRadius', 0, 8, 0.5));
    controlsDiv.appendChild(createSlider('Petal Length Scale', 'petalLengthScale', 0.5, 3, 0.1));
    controlsDiv.appendChild(createSlider('Petal Width Scale', 'petalWidthScale', 0.5, 3, 0.1));
    controlsDiv.appendChild(createSlider('Setosa Gain', 'setosaGain', 0.5, 3, 0.1));

    const sepalTitle = document.createElement('div');
    sepalTitle.textContent = 'Sepal Controls';
    sepalTitle.style.cssText = 'font-weight: 600; margin-top: 10px; margin-bottom: 6px; color: var(--muted); text-align: left; border-top: 1px solid var(--grid); padding-top: 8px; font-size: 10px;';
    controlsDiv.appendChild(sepalTitle);

    controlsDiv.appendChild(createSlider('Sepal Min Size', 'sepalSizeMin', 2, 12, 0.5));
    controlsDiv.appendChild(createSlider('Sepal Size Range', 'sepalSizeRange', 0, 5, 0.1));
    controlsDiv.appendChild(createSlider('Sepal Roundness', 'sepalRoundness', 0, 50, 1));
    controlsDiv.appendChild(createColorPicker('Sepal Color', 'sepalGreen'));

    const labelTitle = document.createElement('div');
    labelTitle.textContent = 'Label Controls';
    labelTitle.style.cssText = 'font-weight: 600; margin-top: 10px; margin-bottom: 6px; color: var(--muted); text-align: left; border-top: 1px solid var(--grid); padding-top: 8px; font-size: 10px;';
    controlsDiv.appendChild(labelTitle);

    controlsDiv.appendChild(createSlider('Label Spacing', 'labelSpacing', 0, 40, 1, (val) => {
      const legend = document.getElementById('flowerLegend');
      if (legend) {
        legend.style.gap = `${val}px`;
      }
    }));

    controlsDiv.appendChild(createSlider('Icon-Text Gap', 'interFlowerLabelSpacing', 0, 20, 1, (val) => {
      const legendItems = document.querySelectorAll('.legend-item');
      legendItems.forEach(item => {
        item.style.gap = `${val}px`;
      });
    }));

    // Data controls section
    const dataTitle = document.createElement('div');
    dataTitle.textContent = 'Data Controls';
    dataTitle.style.cssText = 'font-weight: 600; margin-top: 10px; margin-bottom: 6px; color: var(--muted); text-align: left; border-top: 1px solid var(--grid); padding-top: 8px; font-size: 10px;';
    controlsDiv.appendChild(dataTitle);

    // Samples/Class selector
    const samplesContainer = document.createElement('div');
    samplesContainer.style.cssText = 'margin-bottom: 8px;';

    const samplesLabel = document.createElement('div');
    samplesLabel.textContent = 'Samples/Class';
    samplesLabel.style.cssText = 'margin-bottom: 3px; color: var(--muted); font-size: 10px;';
    samplesContainer.appendChild(samplesLabel);

    const samplesSelect = document.createElement('select');
    samplesSelect.id = 'samplesPerClass';
    samplesSelect.style.cssText = `
      width: 100%;
      background: #161b22;
      color: var(--text);
      border: 1px solid var(--grid);
      border-radius: 4px;
      padding: 4px 6px;
      font-size: 11px;
      cursor: pointer;
    `;

    const options = [25, 50, 100];
    options.forEach(val => {
      const opt = document.createElement('option');
      opt.value = val;
      opt.textContent = val;
      if (val === 50) opt.selected = true;
      samplesSelect.appendChild(opt);
    });

    samplesContainer.appendChild(samplesSelect);
    controlsDiv.appendChild(samplesContainer);

    // Button container
    const btnContainer = document.createElement('div');
    btnContainer.style.cssText = 'display: flex; gap: 4px; margin-top: 10px; border-top: 1px solid var(--grid); padding-top: 8px;';

    // Save button (copy values to clipboard)
    const saveBtn = document.createElement('button');
    saveBtn.textContent = 'Copy';
    saveBtn.style.cssText = `
      flex: 1;
      padding: 4px 8px;
      font-size: 11px;
      border-radius: 4px;
      border: 1px solid var(--grid);
      background: #161b22;
      color: var(--text);
      cursor: pointer;
    `;
    saveBtn.onmouseover = () => saveBtn.style.background = '#1f2933';
    saveBtn.onmouseout = () => saveBtn.style.background = '#161b22';
    saveBtn.onclick = () => {
      const settings = JSON.stringify(window.flowerTuning, null, 2);
      navigator.clipboard.writeText(settings).then(() => {
        const originalText = saveBtn.textContent;
        saveBtn.textContent = '‚úì Copied';
        setTimeout(() => {
          saveBtn.textContent = originalText;
        }, 1500);
      }).catch(err => {
        console.log('Settings:', settings);
        alert('Settings logged to console:\n\n' + settings);
      });
    };
    btnContainer.appendChild(saveBtn);

    // Reset button
    const resetBtn = document.createElement('button');
    resetBtn.textContent = 'Reset';
    resetBtn.style.cssText = `
      flex: 1;
      padding: 4px 8px;
      font-size: 11px;
      border-radius: 4px;
      border: 1px solid var(--grid);
      background: #161b22;
      color: var(--text);
      cursor: pointer;
    `;
    resetBtn.onmouseover = () => resetBtn.style.background = '#1f2933';
    resetBtn.onmouseout = () => resetBtn.style.background = '#161b22';
    resetBtn.onclick = () => {
      window.flowerTuning = {
        petalBaseRadius: 1.5,
        petalLengthScale: 2.0,
        petalWidthScale: 2.4,
        setosaGain: 2.0,
        sepalSizeMin: 5,
        sepalSizeRange: 1.5,
        sepalRoundness: 20,
        sepalGreen: '#11df11',
        labelSpacing: 30,
        interFlowerLabelSpacing: 7
      };
      location.reload();
    };
    btnContainer.appendChild(resetBtn);

    controlsDiv.appendChild(btnContainer);

    document.body.appendChild(controlsDiv);

    // Make draggable via title
    let isDragging = false;
    let startX, startY, initialX, initialY;

    title.onmousedown = (e) => {
      isDragging = true;
      startX = e.clientX;
      startY = e.clientY;
      const rect = controlsDiv.getBoundingClientRect();
      initialX = rect.left;
      initialY = rect.top;
      e.preventDefault();
    };

    document.addEventListener('mousemove', (e) => {
      if (!isDragging) return;
      const dx = e.clientX - startX;
      const dy = e.clientY - startY;
      controlsDiv.style.left = (initialX + dx) + 'px';
      controlsDiv.style.top = (initialY + dy) + 'px';
      controlsDiv.style.right = 'auto';
    });

    document.addEventListener('mouseup', () => {
      isDragging = false;
    });
  })();

  // IIFE: Slider styles customization
  (function() {
    console.log('Creating slider styles popup...');
    const stylesDiv = document.createElement('div');
    stylesDiv.id = 'sliderStyles';
    stylesDiv.style.cssText = `
      position: fixed;
      top: 10px;
      right: 10px;
      background: var(--panel);
      border: 1px solid var(--grid);
      border-radius: 6px;
      padding: 12px;
      z-index: 9999;
      font-size: 11px;
      min-width: 280px;
      max-height: 90vh;
      overflow-y: auto;
      box-shadow: 0 2px 8px rgba(0,0,0,0.3);
      display: none;
    `;

    const title = document.createElement('div');
    title.textContent = 'Slider Styles';
    title.style.cssText = 'font-weight: 600; margin-bottom: 8px; color: var(--text); text-align: center; font-size: 12px; user-select: none; cursor: move;';
    stylesDiv.appendChild(title);

    // Add info text
    const infoText = document.createElement('div');
    infoText.textContent = 'Customize the appearance of all range sliders';
    infoText.style.cssText = 'font-size: 9px; color: var(--muted); text-align: center; margin-bottom: 12px; font-style: italic;';
    stylesDiv.appendChild(infoText);

    const closeBtn = document.createElement('button');
    closeBtn.textContent = '√ó';
    closeBtn.style.cssText = `
      position: absolute;
      top: 8px;
      right: 8px;
      background: transparent;
      border: none;
      color: var(--muted);
      font-size: 18px;
      cursor: pointer;
      padding: 0;
      width: 20px;
      height: 20px;
      line-height: 1;
    `;
    closeBtn.onmouseover = () => closeBtn.style.color = 'var(--text)';
    closeBtn.onmouseout = () => closeBtn.style.color = 'var(--muted)';
    closeBtn.onclick = () => stylesDiv.style.display = 'none';
    stylesDiv.appendChild(closeBtn);

    // Default slider styles
    window.sliderStyles = {
      overallWidth: 149,
      leftMargin: 0,
      labelWidth: 66,
      thumbBorderColor: '#58a6ff',
      thumbFillColor: '#58a6ff',
      thumbOpacity: 0.85,
      thumbWidth: 8,
      thumbHeight: 16,
      thumbBorderRadius: 2,
      thumbVerticalOffset: 7,
      trackColor: '#30363d',
      trackHeight: 4,
      trackBorderRadius: 2
    };

    function updateSliderStyles() {
      console.log('updateSliderStyles called with:', window.sliderStyles);
      console.log('Track height value:', window.sliderStyles.trackHeight);
      console.log('Track color value:', window.sliderStyles.trackColor);

      // Remove old style if exists
      const oldStyle = document.getElementById('dynamic-slider-styles');
      if (oldStyle) {
        oldStyle.remove();
      }

      // Create new style element and append to end of head (higher priority)
      const styleSheet = document.createElement('style');
      styleSheet.id = 'dynamic-slider-styles';
      document.head.appendChild(styleSheet);
      console.log('Created/recreated dynamic style sheet');

      const s = window.sliderStyles;
      // Calculate margin to position thumb lower on track
      const thumbMargin = -((s.thumbHeight - s.trackHeight) / 2) + s.thumbVerticalOffset;

      const cssText = `
        .controls input[type="range"],
        .visual-slider-track,
        #spreadSlider,
        #separationSlider,
        #skewSlider {
          width: ${s.overallWidth}px !important;
          max-width: ${s.overallWidth}px !important;
          flex: 0 0 ${s.overallWidth}px !important;
        }
        .slider-track-bar {
          left: ${s.leftMargin}px !important;
          right: ${-s.leftMargin}px !important;
        }
        #spreadSlider + span,
        #separationSlider + span,
        #skewSlider + span {
          min-width: auto !important;
        }
        label:has(#spreadSlider) > span:first-child,
        label:has(#separationSlider) > span:first-child,
        label:has(#skewSlider) > span:first-child {
          min-width: ${s.labelWidth}px !important;
          max-width: ${s.labelWidth}px !important;
        }
        input[type="range"]::-webkit-slider-thumb {
          -webkit-appearance: none !important;
          background: ${s.thumbFillColor} !important;
          opacity: ${s.thumbOpacity} !important;
          border: 1.5px solid ${s.thumbBorderColor} !important;
          width: ${s.thumbWidth}px !important;
          height: ${s.thumbHeight}px !important;
          border-radius: ${s.thumbBorderRadius}px !important;
          margin-top: ${thumbMargin}px !important;
        }
        input[type="range"]::-moz-range-thumb {
          background: ${s.thumbFillColor} !important;
          opacity: ${s.thumbOpacity} !important;
          border: 1.5px solid ${s.thumbBorderColor} !important;
          width: ${s.thumbWidth}px !important;
          height: ${s.thumbHeight}px !important;
          border-radius: ${s.thumbBorderRadius}px !important;
        }
        input[type="range"]::-webkit-slider-track {
          background: ${s.trackColor} !important;
          height: ${s.trackHeight}px !important;
          border-radius: ${s.trackBorderRadius}px !important;
        }
        input[type="range"]::-moz-range-track {
          background: ${s.trackColor} !important;
          height: ${s.trackHeight}px !important;
          border-radius: ${s.trackBorderRadius}px !important;
        }
        #sliderStyles input[type="range"] {
          width: 100% !important;
        }
        #sliderStyles input[type="range"]::-webkit-slider-thumb {
          background: rgba(88, 166, 255, 0.5) !important;
          border: 1.5px solid #58a6ff !important;
          width: 8px !important;
          height: 16px !important;
          border-radius: 2px !important;
          opacity: 1 !important;
        }
        #sliderStyles input[type="range"]::-moz-range-thumb {
          background: rgba(88, 166, 255, 0.5) !important;
          border: 1.5px solid #58a6ff !important;
          width: 8px !important;
          height: 16px !important;
          border-radius: 2px !important;
          opacity: 1 !important;
        }
        #sliderStyles input[type="range"]::-webkit-slider-track {
          background: #30363d !important;
          height: 4px !important;
          border-radius: 2px !important;
        }
        #sliderStyles input[type="range"]::-moz-range-track {
          background: #30363d !important;
          height: 4px !important;
          border-radius: 2px !important;
        }
      `;
      styleSheet.textContent = cssText;
      console.log('Applied CSS:', cssText);

      // Create visual track overlays since native track styling doesn't work on all browsers
      createVisualTracks();
    }

    function createVisualTracks() {
      const s = window.sliderStyles;

      // Update existing tracks or create new ones
      const sliders = document.querySelectorAll('input[type="range"]:not(#sliderStyles input[type="range"])');

      sliders.forEach(slider => {
        // Check if slider already has a visual track wrapper
        const existingWrapper = slider.closest('.visual-slider-track');

        if (existingWrapper) {
          // Update existing track
          const track = existingWrapper.querySelector('.slider-track-bar');
          if (track) {
            track.style.height = `${s.trackHeight}px`;
            track.style.background = s.trackColor;
            track.style.borderRadius = `${s.trackBorderRadius}px`;
          }
        } else {
          // Create new wrapper and track
          const parent = slider.parentElement;
          const wrapper = document.createElement('div');
          wrapper.className = 'visual-slider-track';
          wrapper.style.cssText = `
            position: relative;
            display: inline-block;
            width: 100%;
          `;

          const track = document.createElement('div');
          track.className = 'slider-track-bar';
          track.style.cssText = `
            position: absolute;
            left: 0;
            right: 0;
            top: 50%;
            transform: translateY(-50%);
            height: ${s.trackHeight}px;
            background: ${s.trackColor};
            border-radius: ${s.trackBorderRadius}px;
            pointer-events: none;
            z-index: 0;
          `;

          // Make slider transparent background and position it above track
          slider.style.position = 'relative';
          slider.style.zIndex = '1';
          slider.style.background = 'transparent';

          parent.insertBefore(wrapper, slider);
          wrapper.appendChild(track);
          wrapper.appendChild(slider);
        }
      });

      console.log(`Updated/created ${sliders.length} visual tracks`);
    }

    function createColorPicker(label, key) {
      const container = document.createElement('div');
      container.style.marginBottom = '8px';

      const labelEl = document.createElement('div');
      labelEl.textContent = label;
      labelEl.style.cssText = 'margin-bottom: 3px; color: var(--muted); font-size: 10px;';
      container.appendChild(labelEl);

      const pickerContainer = document.createElement('div');
      pickerContainer.style.display = 'flex';
      pickerContainer.style.alignItems = 'center';
      pickerContainer.style.gap = '6px';

      const colorInput = document.createElement('input');
      colorInput.type = 'color';
      colorInput.value = window.sliderStyles[key];
      colorInput.style.cssText = 'width: 40px; height: 24px; border: 1px solid var(--grid); border-radius: 3px; cursor: pointer;';

      const textInput = document.createElement('input');
      textInput.type = 'text';
      textInput.value = window.sliderStyles[key];
      textInput.style.cssText = 'flex: 1; padding: 2px 6px; font-size: 10px; font-family: monospace; background: var(--bg); border: 1px solid var(--grid); border-radius: 3px; color: var(--text);';

      colorInput.oninput = function() {
        window.sliderStyles[key] = this.value;
        textInput.value = this.value;
        updateSliderStyles();
      };

      textInput.oninput = function() {
        if (/^#[0-9A-Fa-f]{6}$/.test(this.value)) {
          window.sliderStyles[key] = this.value;
          colorInput.value = this.value;
          updateSliderStyles();
        }
      };

      pickerContainer.appendChild(colorInput);
      pickerContainer.appendChild(textInput);
      container.appendChild(pickerContainer);

      return container;
    }

    function createSlider(label, key, min, max, step) {
      const container = document.createElement('div');
      container.style.marginBottom = '8px';

      const labelEl = document.createElement('div');
      labelEl.textContent = label;
      labelEl.style.cssText = 'margin-bottom: 3px; color: var(--muted); font-size: 10px;';
      container.appendChild(labelEl);

      const sliderContainer = document.createElement('div');
      sliderContainer.style.display = 'flex';
      sliderContainer.style.alignItems = 'center';
      sliderContainer.style.gap = '6px';

      const slider = document.createElement('input');
      slider.type = 'range';
      slider.min = min;
      slider.max = max;
      slider.step = step;
      slider.value = window.sliderStyles[key];
      slider.style.cssText = 'flex: 1; cursor: pointer;';

      const valueDisplay = document.createElement('span');
      valueDisplay.textContent = window.sliderStyles[key];
      valueDisplay.style.cssText = 'min-width: 35px; text-align: right; font-family: monospace; color: var(--text); font-size: 11px;';

      slider.oninput = function() {
        const val = parseFloat(this.value);
        window.sliderStyles[key] = val;
        valueDisplay.textContent = val;
        updateSliderStyles();
      };

      sliderContainer.appendChild(slider);
      sliderContainer.appendChild(valueDisplay);
      container.appendChild(sliderContainer);

      return container;
    }

    // Add controls
    stylesDiv.appendChild(createSlider('Overall Width (px)', 'overallWidth', 40, 200, 1));
    stylesDiv.appendChild(createSlider('Left Margin (px)', 'leftMargin', 0, 100, 1));
    stylesDiv.appendChild(createSlider('Label Width (px)', 'labelWidth', 30, 120, 1));

    // Separator
    const separator1 = document.createElement('div');
    separator1.style.cssText = 'border-top: 1px solid var(--grid); margin: 12px 0 8px 0;';
    stylesDiv.appendChild(separator1);

    stylesDiv.appendChild(createColorPicker('Thumb Border Color', 'thumbBorderColor'));
    stylesDiv.appendChild(createColorPicker('Thumb Fill Color', 'thumbFillColor'));
    stylesDiv.appendChild(createSlider('Thumb Opacity', 'thumbOpacity', 0, 1, 0.05));
    stylesDiv.appendChild(createSlider('Thumb Width (px)', 'thumbWidth', 4, 20, 1));
    stylesDiv.appendChild(createSlider('Thumb Height (px)', 'thumbHeight', 8, 32, 1));
    stylesDiv.appendChild(createSlider('Thumb Border Radius (px)', 'thumbBorderRadius', 0, 16, 1));
    stylesDiv.appendChild(createSlider('Thumb Vertical Offset (px)', 'thumbVerticalOffset', -16, 16, 1));

    // Separator
    const separator = document.createElement('div');
    separator.style.cssText = 'border-top: 1px solid var(--grid); margin: 12px 0 8px 0;';
    stylesDiv.appendChild(separator);

    stylesDiv.appendChild(createColorPicker('Track Color', 'trackColor'));
    stylesDiv.appendChild(createSlider('Track Height (px)', 'trackHeight', 1, 12, 1));
    stylesDiv.appendChild(createSlider('Track Border Radius (px)', 'trackBorderRadius', 0, 6, 1));

    // Button container
    const btnContainer = document.createElement('div');
    btnContainer.style.cssText = 'display: flex; gap: 4px; margin-top: 10px; border-top: 1px solid var(--grid); padding-top: 8px;';

    // Copy button
    const copyBtn = document.createElement('button');
    copyBtn.textContent = 'Copy';
    copyBtn.style.cssText = `
      flex: 1;
      padding: 4px 8px;
      font-size: 11px;
      border-radius: 4px;
      border: 1px solid var(--grid);
      background: #161b22;
      color: var(--text);
      cursor: pointer;
    `;
    copyBtn.onmouseover = () => copyBtn.style.background = '#1f2933';
    copyBtn.onmouseout = () => copyBtn.style.background = '#161b22';
    copyBtn.onclick = () => {
      const settings = JSON.stringify(window.sliderStyles, null, 2);
      navigator.clipboard.writeText(settings).then(() => {
        const originalText = copyBtn.textContent;
        copyBtn.textContent = '‚úì Copied';
        setTimeout(() => {
          copyBtn.textContent = originalText;
        }, 1500);
      }).catch(err => {
        console.log('Settings:', settings);
        alert('Settings logged to console:\n\n' + settings);
      });
    };
    btnContainer.appendChild(copyBtn);

    // Reset button
    const resetBtn = document.createElement('button');
    resetBtn.textContent = 'Reset';
    resetBtn.style.cssText = `
      flex: 1;
      padding: 4px 8px;
      font-size: 11px;
      border-radius: 4px;
      border: 1px solid var(--grid);
      background: #161b22;
      color: var(--text);
      cursor: pointer;
    `;
    resetBtn.onmouseover = () => resetBtn.style.background = '#1f2933';
    resetBtn.onmouseout = () => resetBtn.style.background = '#161b22';
    resetBtn.onclick = () => {
      window.sliderStyles = {
        overallWidth: 149,
        leftMargin: 0,
        labelWidth: 66,
        thumbBorderColor: '#58a6ff',
        thumbFillColor: '#58a6ff',
        thumbOpacity: 0.85,
        thumbWidth: 8,
        thumbHeight: 16,
        thumbBorderRadius: 2,
        thumbVerticalOffset: 7,
        trackColor: '#30363d',
        trackHeight: 4,
        trackBorderRadius: 2
      };
      location.reload();
    };
    btnContainer.appendChild(resetBtn);

    stylesDiv.appendChild(btnContainer);

    document.body.appendChild(stylesDiv);
    console.log('Slider styles popup created and added to body');

    // Apply initial styles
    updateSliderStyles();

    // Make draggable
    let isDragging = false;
    let startX, startY, initialX, initialY;

    title.addEventListener('mousedown', (e) => {
      isDragging = true;
      startX = e.clientX;
      startY = e.clientY;
      const rect = stylesDiv.getBoundingClientRect();
      initialX = rect.left;
      initialY = rect.top;
      stylesDiv.style.right = 'auto';
    });

    document.addEventListener('mousemove', (e) => {
      if (!isDragging) return;
      const dx = e.clientX - startX;
      const dy = e.clientY - startY;
      stylesDiv.style.left = (initialX + dx) + 'px';
      stylesDiv.style.top = (initialY + dy) + 'px';
    });

    document.addEventListener('mouseup', () => {
      isDragging = false;
    });
  })();

  // Show slider styles when link is clicked
  const sliderStylesBtn = document.getElementById('showSliderStyles');
  console.log('Slider styles button:', sliderStylesBtn);
  if (sliderStylesBtn) {
    sliderStylesBtn.addEventListener('click', function(e) {
      e.preventDefault();
      console.log('Slider styles button clicked');
      const stylesDiv = document.getElementById('sliderStyles');
      console.log('Slider styles div:', stylesDiv);
      if (stylesDiv) {
        const currentDisplay = stylesDiv.style.display;
        const newDisplay = currentDisplay === 'none' ? 'block' : 'none';
        stylesDiv.style.display = newDisplay;
        console.log('Changed display from', currentDisplay, 'to', newDisplay);
      }
    });
  } else {
    console.error('Slider styles button not found');
  }

  // Data info panel toggle (below plots)
  document.getElementById('dataInfoBtn').addEventListener('click', function() {
    const infoDiv = document.getElementById('dataInfoPanel');
    const isVisible = infoDiv.style.display !== 'none';
    infoDiv.style.display = isVisible ? 'none' : 'block';
    this.textContent = isVisible ? 'info' : 'hide';
    this.style.color = isVisible ? 'var(--muted)' : 'var(--accent)';

    // Draw histogram when panel is shown
    if (!isVisible && typeof drawGMMHistogram === 'function') {
      setTimeout(() => drawGMMHistogram(selectedHistogramSpecies), 50);
      // Re-initialize Wikipedia links in the panel
      if (typeof initWikiLinks === 'function') {
        initWikiLinks();
      }
    }
  });

  // Scatter plots info panel toggle
  document.getElementById('scatterInfoBtn').addEventListener('click', function() {
    const infoDiv = document.getElementById('scatterInfoPanel');
    const isVisible = infoDiv.style.display !== 'none';
    infoDiv.style.display = isVisible ? 'none' : 'block';
    this.textContent = isVisible ? 'info' : 'hide';
    this.style.color = isVisible ? 'var(--muted)' : 'var(--accent)';
    if (!isVisible) {
      setTimeout(drawExampleVisualizations, 50);
      // Re-initialize Wikipedia links in the panel
      if (typeof initWikiLinks === 'function') {
        initWikiLinks();
      }
    }
  });

  // Correlation matrix info panel toggle
  document.getElementById('corrInfoBtn').addEventListener('click', function() {
    const infoDiv = document.getElementById('corrInfoPanel');
    const isVisible = infoDiv.style.display !== 'none';
    infoDiv.style.display = isVisible ? 'none' : 'block';
    this.textContent = isVisible ? 'info' : 'hide';
    this.style.color = isVisible ? 'var(--muted)' : 'var(--accent)';
    if (!isVisible) {
      setTimeout(drawSubmatrixVisualizations, 50);
      // Re-initialize Wikipedia links in the panel
      if (typeof initWikiLinks === 'function') {
        initWikiLinks();
      }
    }
  });

  // Submatrix interactive controls
  let selectedFeaturePair = [0, 1]; // Default: Sepal Length √ó Width
  let submatrixState = {
    varX: 0.5,
    varY: 0.5,
    cov: 0.0
  };

  function drawSubmatrixVisualizations() {
    // Draw 2x2 submatrix using HTML/CSS (like the examples)
    const submatrixDiv = document.getElementById('submatrixDisplay');
    if (submatrixDiv) {
      const matrix2x2 = [
        [submatrixState.varX, submatrixState.cov],
        [submatrixState.cov, submatrixState.varY]
      ];

      let html = '<div style="display: grid; grid-template-columns: auto 1fr auto; gap: 3px; align-items: center;">';
      html += '<div style="font-size: 16px; color: var(--muted);">[</div>';
      html += '<div style="display: grid; grid-template-rows: 1fr 1fr; gap: 2px;">';

      for (let i = 0; i < 2; i++) {
        html += '<div style="display: grid; grid-template-columns: 1fr 1fr; gap: 4px; text-align: center;">';
        for (let j = 0; j < 2; j++) {
          const val = matrix2x2[i][j];
          let bgColor;
          if (i === j) {
            bgColor = 'rgba(255,107,107,0.25)';
          } else if (val > 0) {
            bgColor = 'rgba(78,205,196,0.25)';
          } else if (val < 0) {
            bgColor = 'rgba(255,107,107,0.25)';
          } else {
            bgColor = 'rgba(139,148,158,0.2)';
          }
          html += `<div style="padding: 4px 6px; background: ${bgColor}; border-radius: 2px; font-size: 9px;">${val.toFixed(2)}</div>`;
        }
        html += '</div>';
      }

      html += '</div>';
      html += '<div style="font-size: 16px; color: var(--muted);">]</div>';
      html += '</div>';

      submatrixDiv.innerHTML = html;
    }

    // Draw 4x4 full matrix using HTML/CSS
    const fullmatrixDiv = document.getElementById('fullmatrixDisplay');
    if (fullmatrixDiv) {
      // Create full 4x4 matrix (identity as base)
      const matrix4x4 = [
        [0.5, 0, 0, 0],
        [0, 0.5, 0, 0],
        [0, 0, 0.5, 0],
        [0, 0, 0, 0.5]
      ];

      // Insert submatrix values
      const [f1, f2] = selectedFeaturePair;
      matrix4x4[f1][f1] = submatrixState.varX;
      matrix4x4[f2][f2] = submatrixState.varY;
      matrix4x4[f1][f2] = submatrixState.cov;
      matrix4x4[f2][f1] = submatrixState.cov;

      let html = '<div style="display: grid; grid-template-columns: auto 1fr auto; gap: 1px; align-items: center;">';
      html += '<div style="font-size: 12px; color: var(--muted);">[</div>';
      html += '<div style="display: grid; grid-template-rows: repeat(4, 1fr); gap: 1px;">';

      for (let i = 0; i < 4; i++) {
        html += '<div style="display: grid; grid-template-columns: repeat(4, 1fr); gap: 2px;">';
        for (let j = 0; j < 4; j++) {
          const val = matrix4x4[i][j];
          const isSelected = (i === f1 || i === f2) && (j === f1 || j === f2);

          let bgColor;
          if (i === j) {
            bgColor = isSelected ? 'rgba(255,107,107,0.3)' : 'rgba(255,107,107,0.15)';
          } else if (val > 0) {
            bgColor = isSelected ? 'rgba(78,205,196,0.35)' : 'rgba(78,205,196,0.15)';
          } else if (val < 0) {
            bgColor = isSelected ? 'rgba(255,107,107,0.35)' : 'rgba(255,107,107,0.15)';
          } else {
            bgColor = 'rgba(139,148,158,0.1)';
          }

          const border = isSelected ? '1px solid rgba(78,205,196,0.8)' : 'none';
          const fontWeight = isSelected ? 'bold' : 'normal';
          const fontSize = isSelected ? '7px' : '6px';

          html += `<div style="padding: 2px 3px; background: ${bgColor}; border-radius: 2px; text-align: center; font-size: ${fontSize}; border: ${border}; font-weight: ${fontWeight};">${Math.abs(val) >= 0.01 ? val.toFixed(2) : ''}</div>`;
        }
        html += '</div>';
      }

      html += '</div>';
      html += '<div style="font-size: 12px; color: var(--muted);">]</div>';
      html += '</div>';

      fullmatrixDiv.innerHTML = html;
    }

    // Draw live preview with ellipse
    const previewCanvas = document.getElementById('submatrixPreviewCanvas');
    if (previewCanvas) {
      const ctx = previewCanvas.getContext('2d');
      const w = previewCanvas.width;
      const h = previewCanvas.height;

      // Clear with transparent background
      ctx.clearRect(0, 0, w, h);

      // Generate example points using Cholesky decomposition
      const covXX = submatrixState.varX;
      const covYY = submatrixState.varY;
      const covXY = submatrixState.cov;

      let L, points = [];
      try {
        L = choleskyDecomposition([[covXX, covXY], [covXY, covYY]]);
        for (let i = 0; i < 25; i++) {
          const z1 = gaussianRandom();
          const z2 = gaussianRandom();
          const x = L[0][0] * z1 + L[0][1] * z2;
          const y = L[1][0] * z1 + L[1][1] * z2;
          points.push([x, y]);
        }
      } catch (e) {
        // Invalid covariance matrix, skip point generation
      }

      // Find range
      let minX = -2.5, maxX = 2.5, minY = -2.5, maxY = 2.5;
      const pad = 10;

      // Eigenvalue decomposition for ellipse
      const a = covXX, b = covXY, d = covYY;
      const trace = a + d;
      const det = a * d - b * b;
      const discriminant = Math.sqrt(Math.max(0, trace * trace / 4 - det));
      const lambda1 = trace / 2 + discriminant;
      const lambda2 = trace / 2 - discriminant;

      let angle;
      if (Math.abs(b) < 1e-10) {
        angle = a >= d ? 0 : Math.PI / 2;
      } else {
        angle = Math.atan2(lambda1 - a, b);
      }

      const cx = w / 2;
      const cy = h / 2;
      const scaleX = (w - 2 * pad) / (maxX - minX);
      const scaleY = (h - 2 * pad) / (maxY - minY);
      const rx = 2 * Math.sqrt(lambda1) * scaleX;
      const ry = 2 * Math.sqrt(lambda2) * scaleY;

      // Draw ellipse
      ctx.save();
      ctx.translate(cx, cy);
      ctx.rotate(-angle);

      ctx.beginPath();
      ctx.ellipse(0, 0, rx, ry, 0, 0, Math.PI * 2);
      ctx.strokeStyle = '#4ecdc4aa';
      ctx.lineWidth = 2;
      ctx.stroke();
      ctx.fillStyle = '#4ecdc420';
      ctx.fill();

      ctx.restore();

      // Draw points
      for (const [x, y] of points) {
        const px = cx + x * scaleX;
        const py = cy - y * scaleY;

        ctx.fillStyle = '#4ecdc4';
        ctx.beginPath();
        ctx.arc(px, py, 2.5, 0, Math.PI * 2);
        ctx.fill();
      }

      // Draw axes
      ctx.strokeStyle = 'rgba(255,255,255,0.1)';
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.moveTo(cx, pad);
      ctx.lineTo(cx, h - pad);
      ctx.moveTo(pad, cy);
      ctx.lineTo(w - pad, cy);
      ctx.stroke();

      // Draw eigenvectors
      const eigenvector1X = Math.cos(-angle);
      const eigenvector1Y = Math.sin(-angle);
      const eigenvector2X = Math.cos(-angle + Math.PI / 2);
      const eigenvector2Y = Math.sin(-angle + Math.PI / 2);

      // Scale eigenvectors by sqrt of eigenvalues
      const scale1 = 2 * Math.sqrt(lambda1) * scaleX;
      const scale2 = 2 * Math.sqrt(lambda2) * scaleY;

      // Draw eigenvector 1 (major axis) - cyan
      ctx.strokeStyle = '#4ecdc4';
      ctx.lineWidth = 3;
      ctx.beginPath();
      ctx.moveTo(cx, cy);
      ctx.lineTo(cx + eigenvector1X * scale1, cy + eigenvector1Y * scale1);
      ctx.stroke();

      // Arrowhead for eigenvector 1
      const arrow1X = cx + eigenvector1X * scale1;
      const arrow1Y = cy + eigenvector1Y * scale1;
      const arrowSize = 8;
      ctx.fillStyle = '#4ecdc4';
      ctx.beginPath();
      ctx.moveTo(arrow1X, arrow1Y);
      ctx.lineTo(
        arrow1X - arrowSize * Math.cos(-angle - Math.PI / 6),
        arrow1Y - arrowSize * Math.sin(-angle - Math.PI / 6)
      );
      ctx.lineTo(
        arrow1X - arrowSize * Math.cos(-angle + Math.PI / 6),
        arrow1Y - arrowSize * Math.sin(-angle + Math.PI / 6)
      );
      ctx.closePath();
      ctx.fill();

      // Draw eigenvector 2 (minor axis) - yellow
      ctx.strokeStyle = '#ffe66d';
      ctx.lineWidth = 3;
      ctx.beginPath();
      ctx.moveTo(cx, cy);
      ctx.lineTo(cx + eigenvector2X * scale2, cy + eigenvector2Y * scale2);
      ctx.stroke();

      // Arrowhead for eigenvector 2
      const arrow2X = cx + eigenvector2X * scale2;
      const arrow2Y = cy + eigenvector2Y * scale2;
      ctx.fillStyle = '#ffe66d';
      ctx.beginPath();
      ctx.moveTo(arrow2X, arrow2Y);
      ctx.lineTo(
        arrow2X - arrowSize * Math.cos(-angle + Math.PI / 2 - Math.PI / 6),
        arrow2Y - arrowSize * Math.sin(-angle + Math.PI / 2 - Math.PI / 6)
      );
      ctx.lineTo(
        arrow2X - arrowSize * Math.cos(-angle + Math.PI / 2 + Math.PI / 6),
        arrow2Y - arrowSize * Math.sin(-angle + Math.PI / 2 + Math.PI / 6)
      );
      ctx.closePath();
      ctx.fill();

      // Update technical data
      const correlation = covXY / (Math.sqrt(covXX) * Math.sqrt(covYY));
      const isValid = det >= 0 && !isNaN(correlation) && Math.abs(correlation) <= 1;

      document.getElementById('techLambda1').textContent = lambda1.toFixed(3);
      document.getElementById('techLambda2').textContent = lambda2.toFixed(3);
      document.getElementById('techAngle').textContent = (angle * 180 / Math.PI).toFixed(1);
      document.getElementById('techRx').textContent = Math.sqrt(lambda1).toFixed(2);
      document.getElementById('techRy').textContent = Math.sqrt(lambda2).toFixed(2);
      document.getElementById('techDet').textContent = det.toFixed(3);
      document.getElementById('techTrace').textContent = trace.toFixed(3);
      document.getElementById('techCorr').textContent = correlation.toFixed(3);
      document.getElementById('techValid').textContent = isValid ? '‚úì' : '‚úó';

      // Color the valid indicator
      const validEl = document.getElementById('techValid');
      validEl.style.color = isValid ? '#4ecdc4' : '#ff6b6b';
    }
  }

  // Live update state
  let liveUpdateEnabled = false;

  // Live button toggle
  const liveBtn = document.getElementById('liveUpdateBtn');
  liveBtn.addEventListener('click', function() {
    liveUpdateEnabled = !liveUpdateEnabled;
    if (liveUpdateEnabled) {
      this.style.borderColor = '#4ecdc4';
      this.style.color = '#4ecdc4';
      this.style.boxShadow = '0 0 8px rgba(78, 205, 196, 0.6)';
    } else {
      this.style.borderColor = 'var(--grid)';
      this.style.color = 'var(--muted)';
      this.style.boxShadow = 'none';
    }
  });

  // Submatrix slider listeners with live update support
  function applyToDataIfLive() {
    if (liveUpdateEnabled) {
      // Build custom correlation matrix
      const [f1, f2] = selectedFeaturePair;
      const customCorr = [
        [1, 0, 0, 0],
        [0, 1, 0, 0],
        [0, 0, 1, 0],
        [0, 0, 0, 1]
      ];

      // Convert variances and covariance to correlation
      const stdX = Math.sqrt(submatrixState.varX);
      const stdY = Math.sqrt(submatrixState.varY);
      const correlation = submatrixState.cov / (stdX * stdY);

      customCorr[f1][f2] = correlation;
      customCorr[f2][f1] = correlation;

      editableCorr = customCorr;
      document.getElementById('corrModeIndicator').style.display = 'block';
      currentData = generateData(editableCorr);
      drawAll(currentData);
    }
  }

  document.getElementById('submatrixVarX').addEventListener('input', function(e) {
    submatrixState.varX = parseFloat(e.target.value);
    document.getElementById('submatrixVarXValue').textContent = submatrixState.varX.toFixed(2);
    drawSubmatrixVisualizations();
    applyToDataIfLive();
  });

  document.getElementById('submatrixVarY').addEventListener('input', function(e) {
    submatrixState.varY = parseFloat(e.target.value);
    document.getElementById('submatrixVarYValue').textContent = submatrixState.varY.toFixed(2);
    drawSubmatrixVisualizations();
    applyToDataIfLive();
  });

  document.getElementById('submatrixCov').addEventListener('input', function(e) {
    submatrixState.cov = parseFloat(e.target.value);
    document.getElementById('submatrixCovValue').textContent = submatrixState.cov.toFixed(2);
    drawSubmatrixVisualizations();
    applyToDataIfLive();
  });

  // Feature pair selection
  document.querySelectorAll('.feature-pair-btn').forEach(btn => {
    btn.addEventListener('click', function() {
      document.querySelectorAll('.feature-pair-btn').forEach(b => {
        b.style.fontWeight = 'normal';
        b.style.opacity = '0.6';
      });
      this.style.fontWeight = 'bold';
      this.style.opacity = '1';

      selectedFeaturePair = this.dataset.pair.split(',').map(Number);
      drawSubmatrixVisualizations();
      applyToDataIfLive();
    });
  });

  // Apply submatrix to data
  document.getElementById('applySubmatrix').addEventListener('click', function() {
    // Build custom correlation matrix
    const [f1, f2] = selectedFeaturePair;
    const customCorr = [
      [1, 0, 0, 0],
      [0, 1, 0, 0],
      [0, 0, 1, 0],
      [0, 0, 0, 1]
    ];

    // Convert variances and covariance to correlation
    const stdX = Math.sqrt(submatrixState.varX);
    const stdY = Math.sqrt(submatrixState.varY);
    const correlation = submatrixState.cov / (stdX * stdY);

    customCorr[f1][f2] = correlation;
    customCorr[f2][f1] = correlation;

    editableCorr = customCorr;
    document.getElementById('corrModeIndicator').style.display = 'block';
    currentData = generateData(editableCorr);
    drawAll(currentData);

    // Visual feedback
    this.textContent = '‚úì Applied!';
    setTimeout(() => {
      this.textContent = 'Apply to Data';
    }, 1500);
  });

  // Reset submatrix
  document.getElementById('resetSubmatrix').addEventListener('click', function() {
    submatrixState = { varX: 0.5, varY: 0.5, cov: 0.0 };
    document.getElementById('submatrixVarX').value = '0.5';
    document.getElementById('submatrixVarY').value = '0.5';
    document.getElementById('submatrixCov').value = '0';
    document.getElementById('submatrixVarXValue').textContent = '0.50';
    document.getElementById('submatrixVarYValue').textContent = '0.50';
    document.getElementById('submatrixCovValue').textContent = '0.00';
    drawSubmatrixVisualizations();
  });

  // Initialize default feature pair button
  document.querySelector('.feature-pair-btn').style.fontWeight = 'bold';
  document.querySelector('.feature-pair-btn').style.opacity = '1';

  // Flower info toggle
  document.getElementById('flowerInfoBtn').addEventListener('click', function() {
    const infoDiv = document.getElementById('flowerInfo');
    const isVisible = infoDiv.style.display !== 'none';
    infoDiv.style.display = isVisible ? 'none' : 'block';
    this.textContent = isVisible ? 'info' : 'hide';
    this.style.color = isVisible ? 'var(--muted)' : 'var(--accent)';
    // Re-initialize Wikipedia links in the panel
    if (!isVisible && typeof initWikiLinks === 'function') {
      initWikiLinks();
    }
  });

  // Show flower tuner when link is clicked
  document.getElementById('showFlowerTuner').addEventListener('click', function(e) {
    e.preventDefault();
    const tunerDiv = document.getElementById('flowerTuning');
    if (tunerDiv) {
      tunerDiv.style.display = tunerDiv.style.display === 'none' ? 'block' : 'none';
    }
  });

  // Event listeners

  document.getElementById('btnResetCorr').addEventListener('click', () => {
    editableCorr = null;
    document.getElementById('corrModeIndicator').style.display = 'none';
    currentData = generateData(); // Regenerate with default (no correlation)
    drawAll(currentData);
  });

  // Interactive example buttons
  document.getElementById('btnWeakCorr').addEventListener('click', () => {
    // Weak correlations: small off-diagonal values
    // This will show that Term 0 (I) + Term 1 (R) capture most of the action
    editableCorr = [
      [1.00,  0.15, -0.10,  0.05],
      [0.15,  1.00,  0.08, -0.12],
      [-0.10, 0.08,  1.00,  0.20],
      [0.05, -0.12,  0.20,  1.00]
    ];
    document.getElementById('corrModeIndicator').style.display = 'block';
    currentData = generateData(editableCorr);
    drawAll(currentData);

    // Notify parent window
    if (window.parent !== window) {
      window.parent.postMessage({ type: 'dataRegenerated', data: currentData }, '*');
    }
  });

  document.getElementById('btnStrongCorr').addEventListener('click', () => {
    // Strong correlations: large off-diagonal values
    // This requires higher-order terms for accuracy
    editableCorr = [
      [1.00,  0.75,  0.60, -0.50],
      [0.75,  1.00,  0.65, -0.45],
      [0.60,  0.65,  1.00, -0.70],
      [-0.50, -0.45, -0.70, 1.00]
    ];
    document.getElementById('corrModeIndicator').style.display = 'block';
    currentData = generateData(editableCorr);
    drawAll(currentData);

    // Notify parent window
    if (window.parent !== window) {
      window.parent.postMessage({ type: 'dataRegenerated', data: currentData }, '*');
    }
  });

  document.getElementById('btnUncorrelated').addEventListener('click', () => {
    // Identity matrix: no correlations
    // Only Term 0 matters! (all others are zero)
    editableCorr = [
      [1.00, 0.00, 0.00, 0.00],
      [0.00, 1.00, 0.00, 0.00],
      [0.00, 0.00, 1.00, 0.00],
      [0.00, 0.00, 0.00, 1.00]
    ];
    document.getElementById('corrModeIndicator').style.display = 'block';
    currentData = generateData(editableCorr);
    drawAll(currentData);

    // Notify parent window
    if (window.parent !== window) {
      window.parent.postMessage({ type: 'dataRegenerated', data: currentData }, '*');
    }
  });

  document.getElementById('btnTight').addEventListener('click', () => {
    // Low variance (tight distribution) with weak correlations
    // Shows precision matrix effect
    editableCorr = [
      [0.30,  0.05, -0.03,  0.02],
      [0.05,  0.25,  0.04, -0.03],
      [-0.03, 0.04,  0.35,  0.06],
      [0.02, -0.03,  0.06,  0.20]
    ];
    document.getElementById('corrModeIndicator').style.display = 'block';
    currentData = generateData(editableCorr);
    drawAll(currentData);

    // Notify parent window
    if (window.parent !== window) {
      window.parent.postMessage({ type: 'dataRegenerated', data: currentData }, '*');
    }
  });

  document.getElementById('btnSingular').addEventListener('click', () => {
    // Nearly singular matrix: features are almost perfectly correlated
    // Determinant approaches 0
    editableCorr = [
      [1.00,  0.95,  0.90,  0.85],
      [0.95,  1.00,  0.95,  0.90],
      [0.90,  0.95,  1.00,  0.95],
      [0.85,  0.90,  0.95,  1.00]
    ];
    document.getElementById('corrModeIndicator').style.display = 'block';
    currentData = generateData(editableCorr);
    drawAll(currentData);

    // Notify parent window
    if (window.parent !== window) {
      window.parent.postMessage({ type: 'dataRegenerated', data: currentData }, '*');
    }
  });

  document.getElementById('samplesPerClass').addEventListener('change', e => {
    gmmConfig.nPerClass = parseInt(e.target.value);
    regenerateAll();
  });

  // Ellipse toggle button - cycles through: off -> 1œÉ -> 2œÉ -> off
  document.getElementById('toggleEllipses').addEventListener('click', function() {
    ellipseMode = (ellipseMode + 1) % 3;

    if (ellipseMode === 0) {
      this.textContent = 'Ellipse';
      this.style.background = 'transparent';
      this.style.color = 'var(--muted)';
    } else if (ellipseMode === 1) {
      this.textContent = '1œÉ (68%)';
      this.style.background = '#161b22';
      this.style.color = 'var(--text)';
    } else {
      this.textContent = '2œÉ (95%)';
      this.style.background = '#161b22';
      this.style.color = 'var(--text)';
    }

    drawAll(currentData);
  });

  document.getElementById('spreadSlider').addEventListener('input', e => {
    gmmConfig.spreadMultiplier = parseFloat(e.target.value);
    document.getElementById('spreadValue').textContent = gmmConfig.spreadMultiplier.toFixed(1);
    updateSpreads();
    regenerateAll();
  });

  document.getElementById('separationSlider').addEventListener('input', e => {
    gmmConfig.separationMultiplier = parseFloat(e.target.value);
    document.getElementById('separationValue').textContent = gmmConfig.separationMultiplier.toFixed(1);
    regenerateAll();
  });

  document.getElementById('skewSlider').addEventListener('input', e => {
    gmmConfig.correlationStrength = parseFloat(e.target.value);
    document.getElementById('skewValue').textContent = gmmConfig.correlationStrength.toFixed(1);
    regenerateAll();
  });

  // Axis scale slider for ellipse calculation (controls removed from UI)
  /*
  document.getElementById('axisScaleSlider').addEventListener('input', e => {
    gmmConfig.ellipseAxisScale = parseFloat(e.target.value);
    document.getElementById('axisScaleValue').textContent = gmmConfig.ellipseAxisScale.toFixed(2);
    drawEllipseCalculation(currentData);
  });

  document.getElementById('resetAxisScale').addEventListener('click', () => {
    gmmConfig.ellipseAxisScale = 1.0;
    document.getElementById('axisScaleSlider').value = '1';
    document.getElementById('axisScaleValue').textContent = '1.00';
    drawEllipseCalculation(currentData);
  });
  */

  // Regenerate on canvas click
  canvases.forEach(c => {
    c.addEventListener('click', regenerateAll);
  });

  // Redraw on resize
  window.addEventListener('resize', () => {
    drawAll(currentData);
  });

  // Toggle equation view (compact vs full)
  document.getElementById('btnToggleEquation').addEventListener('click', () => {
    const panel = document.getElementById('equationPanel');
    const btn = document.getElementById('btnToggleEquation');

    if (panel.classList.contains('compact')) {
      panel.classList.remove('compact');
      btn.textContent = 'hide';
      btn.style.color = 'var(--accent)';
    } else {
      panel.classList.add('compact');
      btn.textContent = 'info';
      btn.style.color = 'var(--muted)';
    }
  });

  // Render KaTeX equations for GMM data generation panel
  const renderGMMEquations = () => {
    if (typeof katex === 'undefined') {
      setTimeout(renderGMMEquations, 100);
      return;
    }

    try {
      // Check if elements exist before rendering
      const elements = {
        'gmm_pik': '\\pi_k',
        'gmm_normal': '\\mathcal{N}(\\boldsymbol{\\mu}_k, \\boldsymbol{\\Sigma}_k)',
        'gmm_z': '\\mathbf{z} \\sim \\mathcal{N}(\\mathbf{0}, \\mathbf{I})',
        'gmm_transform': '\\mathbf{x} = \\boldsymbol{\\mu}_k + \\mathbf{L}\\mathbf{z}',
        'gmm_expect': '\\mathbb{E}[\\mathbf{x}] = \\boldsymbol{\\mu}_k',
        'gmm_cov': '\\text{Cov}(\\mathbf{x}) = \\boldsymbol{\\Sigma}_k'
      };

      for (const [id, latex] of Object.entries(elements)) {
        const element = document.getElementById(id);
        if (element) {
          katex.render(latex, element, { throwOnError: false });
        }
      }
    } catch (e) {
      console.error('KaTeX render error (GMM):', e);
    }
  };

  setTimeout(renderGMMEquations, 100);

  // Render KaTeX equations for ellipse calculation formulas
  const renderEllipseEquations = () => {
    if (typeof katex === 'undefined') {
      setTimeout(renderEllipseEquations, 100);
      return;
    }

    try {
      // Find all elements with class 'katex-formula'
      const formulaElements = document.querySelectorAll('.katex-formula');
      formulaElements.forEach(element => {
        const latex = element.textContent.trim();
        if (latex) {
          katex.render(latex, element, { throwOnError: false });
        }
      });
    } catch (e) {
      console.error('KaTeX render error (Ellipse):', e);
    }
  };

  setTimeout(renderEllipseEquations, 100);

  // Draw Cholesky transformation example
  function drawCholeskyExample() {
    if (!window.currentData) return;

    // Get L from Versicolor (class 1)
    const classData = window.currentData.filter(d => d.class === 1);
    if (classData.length === 0) return;

    // Compute mean and covariance
    const n = classData.length;
    const mean = [0, 0, 0, 0];
    for (let i = 0; i < 4; i++) {
      for (const d of classData) {
        mean[i] += d.features[i];
      }
      mean[i] /= n;
    }

    const cov = Array(4).fill(0).map(() => Array(4).fill(0));
    for (let i = 0; i < 4; i++) {
      for (let j = 0; j < 4; j++) {
        for (const d of classData) {
          cov[i][j] += (d.features[i] - mean[i]) * (d.features[j] - mean[j]);
        }
        cov[i][j] /= n;
      }
    }

    // Cholesky decomposition
    const L = Array(4).fill(0).map(() => Array(4).fill(0));
    for (let i = 0; i < 4; i++) {
      for (let j = 0; j <= i; j++) {
        let sum = 0;
        for (let k = 0; k < j; k++) {
          sum += L[i][k] * L[j][k];
        }
        if (i === j) {
          L[i][j] = Math.sqrt(Math.max(0, cov[i][i] - sum));
        } else {
          L[i][j] = L[j][j] === 0 ? 0 : (cov[i][j] - sum) / L[j][j];
        }
      }
    }

    // Draw before/after scatter plots
    drawBeforeAfter(L);
  }

  function drawBeforeAfter(L) {
    const beforeCanvas = document.getElementById('beforeTransform');
    const afterCanvas = document.getElementById('afterTransform');
    if (!beforeCanvas || !afterCanvas) return;

    const beforeCtx = beforeCanvas.getContext('2d');
    const afterCtx = afterCanvas.getContext('2d');
    const size = 150;
    const scale = 40;

    // Clear
    beforeCtx.clearRect(0, 0, size, size);
    afterCtx.clearRect(0, 0, size, size);

    // Generate 100 points
    function gaussianRandom() {
      let u = 0, v = 0;
      while(u === 0) u = Math.random();
      while(v === 0) v = Math.random();
      return Math.sqrt(-2.0 * Math.log(u)) * Math.cos(2.0 * Math.PI * v);
    }

    for (let i = 0; i < 100; i++) {
      const z0 = gaussianRandom();
      const z2 = gaussianRandom();

      // Before: independent N(0,1) - circular cloud
      const bx = size / 2 + z0 * scale;
      const by = size / 2 + z2 * scale;
      beforeCtx.fillStyle = 'rgba(88, 166, 255, 0.4)';
      beforeCtx.beginPath();
      beforeCtx.arc(bx, by, 2, 0, 2 * Math.PI);
      beforeCtx.fill();

      // After: transform with L (use dims 0 and 2)
      const x0 = L[0][0] * z0;
      const x2 = L[2][0] * z0 + L[2][2] * z2;
      const ax = size / 2 + x0 * scale;
      const ay = size / 2 + x2 * scale;
      afterCtx.fillStyle = 'rgba(88, 166, 255, 0.4)';
      afterCtx.beginPath();
      afterCtx.arc(ax, ay, 2, 0, 2 * Math.PI);
      afterCtx.fill();
    }

    // Draw center points
    beforeCtx.fillStyle = '#58a6ff';
    beforeCtx.beginPath();
    beforeCtx.arc(size / 2, size / 2, 4, 0, 2 * Math.PI);
    beforeCtx.fill();

    afterCtx.fillStyle = '#58a6ff';
    afterCtx.beginPath();
    afterCtx.arc(size / 2, size / 2, 4, 0, 2 * Math.PI);
    afterCtx.fill();
  }

  // Initial draw when panel is shown
  setTimeout(() => {
    if (window.currentData) {
      drawCholeskyExample();
    }
  }, 200);

  // Draw example covariance visualizations in info panel
  function drawExampleVisualizations() {
    const examples = [
      { id: 'exampleCanvas1', covXX: 0.5, covYY: 0.5, covXY: 0, color: '#8b949e', nPoints: 30 },
      { id: 'exampleCanvas2', covXX: 0.5, covYY: 0.5, covXY: 0.35, color: '#4ecdc4', nPoints: 30 },
      { id: 'exampleCanvas3', covXX: 0.5, covYY: 0.5, covXY: -0.35, color: '#ff6b6b', nPoints: 30 }
    ];

    examples.forEach(ex => {
      const canvas = document.getElementById(ex.id);
      if (!canvas) return;

      const ctx = canvas.getContext('2d');
      const w = canvas.width;
      const h = canvas.height;

      // Clear
      ctx.fillStyle = 'rgba(0,0,0,0.3)';
      ctx.fillRect(0, 0, w, h);

      // Generate example points using Cholesky decomposition
      const L = choleskyDecomposition([[ex.covXX, ex.covXY], [ex.covXY, ex.covYY]]);
      const points = [];
      for (let i = 0; i < ex.nPoints; i++) {
        const z1 = gaussianRandom();
        const z2 = gaussianRandom();
        const x = L[0][0] * z1 + L[0][1] * z2;
        const y = L[1][0] * z1 + L[1][1] * z2;
        points.push([x, y]);
      }

      // Find range
      let minX = -2, maxX = 2, minY = -2, maxY = 2;

      const pad = 10;

      // Draw ellipse
      const cx = w / 2;
      const cy = h / 2;

      // Eigenvalue decomposition
      const a = ex.covXX, b = ex.covXY, d = ex.covYY;
      const trace = a + d;
      const det = a * d - b * b;
      const discriminant = Math.sqrt(Math.max(0, trace * trace / 4 - det));
      const lambda1 = trace / 2 + discriminant;
      const lambda2 = trace / 2 - discriminant;

      let angle;
      if (Math.abs(b) < 1e-10) {
        angle = a >= d ? 0 : Math.PI / 2;
      } else {
        angle = Math.atan2(lambda1 - a, b);
      }

      const scaleX = (w - 2 * pad) / (maxX - minX);
      const scaleY = (h - 2 * pad) / (maxY - minY);
      const rx = 2 * Math.sqrt(lambda1) * scaleX;
      const ry = 2 * Math.sqrt(lambda2) * scaleY;

      ctx.save();
      ctx.translate(cx, cy);
      ctx.rotate(-angle); // Negate for canvas Y-flip

      ctx.beginPath();
      ctx.ellipse(0, 0, rx, ry, 0, 0, Math.PI * 2);
      ctx.strokeStyle = ex.color + '80';
      ctx.lineWidth = 3;
      ctx.stroke();
      ctx.fillStyle = ex.color + '20';
      ctx.fill();

      ctx.restore();

      // Draw points
      for (const [x, y] of points) {
        const px = cx + x * scaleX;
        const py = cy - y * scaleY; // Flip Y

        ctx.fillStyle = ex.color;
        ctx.beginPath();
        ctx.arc(px, py, 4, 0, Math.PI * 2);
        ctx.fill();
      }
    });
  }

  // Draw examples on initial load if panel is open (when manually testing with panel visible)
  // Uncomment the line below if you want examples to render on page load:
  // setTimeout(drawExampleVisualizations, 100);

  // Interactive Scene 5: Euclidean vs Mahalanobis Distance
  // Store state outside the function so it persists across updates
  window.mahalanobisState = window.mahalanobisState || {
    point: null,
    isDragging: false,
    initialized: false,
    cov: null,
    precision: null,
    canvas: null,
    ctx: null,
    rafPending: false
  };

  window.updateMahalanobisViz = function(data) {
    const canvas = document.getElementById('euclideanVsMahalanobis');
    if (!canvas) {
      return;
    }

    // Check if canvas reference changed (which would break event listeners)
    const canvasChanged = window.mahalanobisState.canvas && window.mahalanobisState.canvas !== canvas;
    if (canvasChanged) {
      // Reset initialization flag so listeners get re-attached
      window.mahalanobisState.initialized = false;
    }

    // Store canvas and context in state
    window.mahalanobisState.canvas = canvas;
    window.mahalanobisState.ctx = canvas.getContext('2d');

    const ctx = window.mahalanobisState.ctx;
    const width = canvas.width;
    const height = canvas.height;

    // Get covariance from actual data (Versicolor, dims 0 and 1)
    const covData = compute2DCovMatrix(data, 1, 0, 1);

    // Scale covariance to canvas size for visualization
    const scaleFactor = 1000; // Adjust this to make ellipses visible
    window.mahalanobisState.cov = [
      [covData.covXX * scaleFactor, covData.covXY * scaleFactor],
      [covData.covXY * scaleFactor, covData.covYY * scaleFactor]
    ];

    // Initialize point position on first call
    if (!window.mahalanobisState.point) {
      window.mahalanobisState.point = { x: width / 2 + 80, y: height / 2 + 50 };
    }

    // Compute precision matrix (inverse of covariance)
    function invertMatrix2x2(m) {
      const det = m[0][0] * m[1][1] - m[0][1] * m[1][0];
      if (Math.abs(det) < 1e-10) {
        // Matrix is singular, return identity
        console.warn('Singular covariance matrix, using identity');
        return [[1, 0], [0, 1]];
      }
      return [
        [m[1][1] / det, -m[0][1] / det],
        [-m[1][0] / det, m[0][0] / det]
      ];
    }

    window.mahalanobisState.precision = invertMatrix2x2(window.mahalanobisState.cov);

    // Use requestAnimationFrame to prevent flickering during rapid updates
    if (!window.mahalanobisState.rafPending) {
      window.mahalanobisState.rafPending = true;
      requestAnimationFrame(() => {
        window.mahalanobisState.rafPending = false;
        drawMahalanobisViz();
      });
    }

    // Re-attach event listeners if canvas changed
    if (canvasChanged) {
      initMahalanobisListeners();
    }
  };

  // Global draw function that uses state
  function drawMahalanobisViz() {
    const state = window.mahalanobisState;
    if (!state.canvas || !state.ctx || !state.cov || !state.precision || !state.point) {
      console.warn('Mahalanobis state incomplete:', {
        hasCanvas: !!state.canvas,
        hasCtx: !!state.ctx,
        hasCov: !!state.cov,
        hasPrecision: !!state.precision,
        hasPoint: !!state.point
      });
      return;
    }

    const canvas = state.canvas;
    const ctx = state.ctx;
    const cov = state.cov;
    const precision = state.precision;
    const point = state.point;
    const width = canvas.width;
    const height = canvas.height;
    const mu = { x: width / 2, y: height / 2 };

    function drawEllipse(ctx, cx, cy, cov, scale) {
      // Eigendecomposition for drawing ellipse
      const a = cov[0][0], b = cov[0][1], d = cov[1][1];
      const trace = a + d;
      const det = a * d - b * b;
      const lambda1 = trace / 2 + Math.sqrt(trace * trace / 4 - det);
      const lambda2 = trace / 2 - Math.sqrt(trace * trace / 4 - det);

      const angle = b === 0 ? 0 : Math.atan2(lambda1 - a, b);
      const rx = Math.sqrt(lambda1 * scale);
      const ry = Math.sqrt(lambda2 * scale);

      ctx.save();
      ctx.translate(cx, cy);
      ctx.rotate(angle);
      ctx.beginPath();
      ctx.ellipse(0, 0, rx, ry, 0, 0, 2 * Math.PI);
      ctx.restore();
    }

    function computeMahalanobis(p) {
      const dx = p.x - mu.x;
      const dy = p.y - mu.y;
      const d2 = precision[0][0] * dx * dx +
                 2 * precision[0][1] * dx * dy +
                 precision[1][1] * dy * dy;
      return Math.sqrt(Math.abs(d2));
    }

    function computeEuclidean(p) {
      const dx = p.x - mu.x;
      const dy = p.y - mu.y;
      return Math.sqrt(dx * dx + dy * dy);
    }

    ctx.clearRect(0, 0, width, height);

    // Draw multiple ellipse contours (iso-Mahalanobis distance)
    ctx.strokeStyle = 'rgba(78, 205, 196, 0.3)';
    ctx.lineWidth = 1;
    for (let i = 1; i <= 3; i++) {
      drawEllipse(ctx, mu.x, mu.y, cov, i);
      ctx.stroke();
    }

    // Highlight the contour closest to current point
    const mahal = computeMahalanobis(point);
    const scale = mahal * mahal;
    ctx.strokeStyle = 'rgba(78, 205, 196, 0.8)';
    ctx.lineWidth = 2;
    drawEllipse(ctx, mu.x, mu.y, cov, scale);
    ctx.stroke();

    // Draw eigenvector arrows showing principal axes
    const a = cov[0][0], b = cov[0][1], d = cov[1][1];
    const trace = a + d;
    const det = a * d - b * b;
    const lambda1 = trace / 2 + Math.sqrt(trace * trace / 4 - det);
    const lambda2 = trace / 2 - Math.sqrt(trace * trace / 4 - det);
    const angle = b === 0 ? 0 : Math.atan2(lambda1 - a, b);

    // Draw eigenvector 1 (major axis) - wider spread
    const ev1_len = Math.sqrt(lambda1) * 1.5;
    const ev1_dx = Math.cos(angle) * ev1_len;
    const ev1_dy = Math.sin(angle) * ev1_len;

    ctx.strokeStyle = 'rgba(255, 136, 0, 0.6)';
    ctx.fillStyle = 'rgba(255, 136, 0, 0.8)';
    ctx.lineWidth = 2;
    ctx.setLineDash([]);

    // Draw arrow line
    ctx.beginPath();
    ctx.moveTo(mu.x, mu.y);
    ctx.lineTo(mu.x + ev1_dx, mu.y + ev1_dy);
    ctx.stroke();

    // Draw arrowhead
    const arrowSize = 8;
    ctx.beginPath();
    ctx.moveTo(mu.x + ev1_dx, mu.y + ev1_dy);
    ctx.lineTo(mu.x + ev1_dx - arrowSize * Math.cos(angle - Math.PI / 6),
               mu.y + ev1_dy - arrowSize * Math.sin(angle - Math.PI / 6));
    ctx.lineTo(mu.x + ev1_dx - arrowSize * Math.cos(angle + Math.PI / 6),
               mu.y + ev1_dy - arrowSize * Math.sin(angle + Math.PI / 6));
    ctx.closePath();
    ctx.fill();

    // Draw eigenvector 2 (minor axis) - narrower spread
    const ev2_angle = angle + Math.PI / 2;
    const ev2_len = Math.sqrt(lambda2) * 1.5;
    const ev2_dx = Math.cos(ev2_angle) * ev2_len;
    const ev2_dy = Math.sin(ev2_angle) * ev2_len;

    ctx.strokeStyle = 'rgba(88, 166, 255, 0.6)';
    ctx.fillStyle = 'rgba(88, 166, 255, 0.8)';
    ctx.lineWidth = 2;

    // Draw arrow line
    ctx.beginPath();
    ctx.moveTo(mu.x, mu.y);
    ctx.lineTo(mu.x + ev2_dx, mu.y + ev2_dy);
    ctx.stroke();

    // Draw arrowhead
    ctx.beginPath();
    ctx.moveTo(mu.x + ev2_dx, mu.y + ev2_dy);
    ctx.lineTo(mu.x + ev2_dx - arrowSize * Math.cos(ev2_angle - Math.PI / 6),
               mu.y + ev2_dy - arrowSize * Math.sin(ev2_angle - Math.PI / 6));
    ctx.lineTo(mu.x + ev2_dx - arrowSize * Math.cos(ev2_angle + Math.PI / 6),
               mu.y + ev2_dy - arrowSize * Math.sin(ev2_angle + Math.PI / 6));
    ctx.closePath();
    ctx.fill();

    // Label eigenvalues with fixed-width backgrounds to prevent jarring
    ctx.font = '11px monospace';
    const labelWidth = 50;
    const labelHeight = 16;
    const labelOffset = 15; // Distance beyond arrow tip

    // Œª‚ÇÅ label - positioned beyond arrow tip
    const label1_x = mu.x + ev1_dx + Math.cos(angle) * labelOffset;
    const label1_y = mu.y + ev1_dy + Math.sin(angle) * labelOffset;

    ctx.textAlign = 'center';
    ctx.fillStyle = 'rgba(13, 17, 23, 0.9)';
    ctx.fillRect(label1_x - labelWidth/2, label1_y - labelHeight/2, labelWidth, labelHeight);
    ctx.strokeStyle = 'rgba(255, 136, 0, 0.3)';
    ctx.lineWidth = 1;
    ctx.strokeRect(label1_x - labelWidth/2, label1_y - labelHeight/2, labelWidth, labelHeight);
    ctx.fillStyle = '#ff8800';
    ctx.fillText('Œª‚ÇÅ=' + lambda1.toFixed(1), label1_x, label1_y + 4);

    // Œª‚ÇÇ label - positioned beyond arrow tip
    const label2_x = mu.x + ev2_dx + Math.cos(ev2_angle) * labelOffset;
    const label2_y = mu.y + ev2_dy + Math.sin(ev2_angle) * labelOffset;

    ctx.fillStyle = 'rgba(13, 17, 23, 0.9)';
    ctx.fillRect(label2_x - labelWidth/2, label2_y - labelHeight/2, labelWidth, labelHeight);
    ctx.strokeStyle = 'rgba(88, 166, 255, 0.3)';
    ctx.lineWidth = 1;
    ctx.strokeRect(label2_x - labelWidth/2, label2_y - labelHeight/2, labelWidth, labelHeight);
    ctx.fillStyle = '#58a6ff';
    ctx.fillText('Œª‚ÇÇ=' + lambda2.toFixed(1), label2_x, label2_y + 4);

    // Draw mean
    ctx.fillStyle = '#ff8800';
    ctx.beginPath();
    ctx.arc(mu.x, mu.y, 6, 0, 2 * Math.PI);
    ctx.fill();

    // Draw point
    ctx.fillStyle = '#58a6ff';
    ctx.beginPath();
    ctx.arc(point.x, point.y, 8, 0, 2 * Math.PI);
    ctx.fill();

    // Draw line from mu to point
    ctx.strokeStyle = 'rgba(88, 166, 255, 0.5)';
    ctx.lineWidth = 1;
    ctx.setLineDash([5, 5]);
    ctx.beginPath();
    ctx.moveTo(mu.x, mu.y);
    ctx.lineTo(point.x, point.y);
    ctx.stroke();
    ctx.setLineDash([]);

    // Update distance displays
    const euclidean = computeEuclidean(point);
    document.getElementById('euclideanDist').textContent = euclidean.toFixed(2);
    document.getElementById('mahalanobisDist').textContent = mahal.toFixed(2);

    // Update covariance matrix display
    document.getElementById('covMat00').textContent = cov[0][0].toFixed(2);
    document.getElementById('covMat01').textContent = cov[0][1].toFixed(2);
    document.getElementById('covMat10').textContent = cov[1][0].toFixed(2);
    document.getElementById('covMat11').textContent = cov[1][1].toFixed(2);
  }

  // Add event listeners only once (or when canvas changes)
  function initMahalanobisListeners() {
    if (window.mahalanobisState.initialized) {
      return;
    }
    window.mahalanobisState.initialized = true;

    const canvas = document.getElementById('euclideanVsMahalanobis');
    if (!canvas) {
      return;
    }

    canvas.addEventListener('mousedown', (e) => {
      if (!window.mahalanobisState.point) {
        return; // Safety check
      }
      if (!window.mahalanobisState.cov) {
        console.warn('No covariance in state!');
        return;
      }

      const rect = canvas.getBoundingClientRect();
      const mx = e.clientX - rect.left;
      const my = e.clientY - rect.top;

      // Move point to mouse position
      window.mahalanobisState.point.x = mx;
      window.mahalanobisState.point.y = my;
      window.mahalanobisState.isDragging = true;
      // Redraw with requestAnimationFrame
      if (!window.mahalanobisState.rafPending) {
        window.mahalanobisState.rafPending = true;
        requestAnimationFrame(() => {
          window.mahalanobisState.rafPending = false;
          drawMahalanobisViz();
        });
      }
    }, { capture: true });

    canvas.addEventListener('mousemove', (e) => {
      if (!window.mahalanobisState.isDragging || !window.mahalanobisState.point) return;
      const rect = canvas.getBoundingClientRect();
      if (e.clientX >= rect.left && e.clientX <= rect.right &&
          e.clientY >= rect.top && e.clientY <= rect.bottom) {
        window.mahalanobisState.point.x = e.clientX - rect.left;
        window.mahalanobisState.point.y = e.clientY - rect.top;
        // Redraw with requestAnimationFrame
        if (!window.mahalanobisState.rafPending) {
          window.mahalanobisState.rafPending = true;
          requestAnimationFrame(() => {
            window.mahalanobisState.rafPending = false;
            drawMahalanobisViz();
          });
        }
      }
    });

    canvas.addEventListener('mouseup', () => {
      window.mahalanobisState.isDragging = false;
    });

    canvas.addEventListener('mouseleave', () => {
      window.mahalanobisState.isDragging = false;
    });
  }

  // Initialize on page load
  if (window.currentData) {
    updateMahalanobisViz(window.currentData);
  }
  initMahalanobisListeners();

  // Comparative precision examples
  function drawComparativePrecisionExamples() {
    const configs = [
      { id: 'precisionLow', variance: 1.0 },
      { id: 'precisionMed', variance: 0.25 },
      { id: 'precisionHigh', variance: 0.04 }
    ];

    configs.forEach(config => {
      const canvas = document.getElementById(config.id);
      if (!canvas) return;

      const ctx = canvas.getContext('2d');
      const width = canvas.width;
      const height = canvas.height;
      const mu = { x: width / 2, y: height / 2 };
      const point = { x: width / 2 + 50, y: height / 2 }; // Fixed 50px offset

      ctx.clearRect(0, 0, width, height);

      const radius = Math.sqrt(config.variance) * 31.6; // Scale factor

      // Draw ellipse (circle)
      ctx.strokeStyle = 'rgba(78, 205, 196, 0.6)';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.arc(mu.x, mu.y, radius, 0, 2 * Math.PI);
      ctx.stroke();

      // Draw fainter outer contours
      ctx.strokeStyle = 'rgba(78, 205, 196, 0.25)';
      ctx.lineWidth = 1;
      for (let i = 2; i <= 3; i++) {
        ctx.beginPath();
        ctx.arc(mu.x, mu.y, radius * i, 0, 2 * Math.PI);
        ctx.stroke();
      }

      // Draw mean
      ctx.fillStyle = '#ff8800';
      ctx.beginPath();
      ctx.arc(mu.x, mu.y, 5, 0, 2 * Math.PI);
      ctx.fill();

      // Draw point
      ctx.fillStyle = '#58a6ff';
      ctx.beginPath();
      ctx.arc(point.x, point.y, 6, 0, 2 * Math.PI);
      ctx.fill();

      // Draw line from mu to point
      ctx.strokeStyle = 'rgba(88, 166, 255, 0.4)';
      ctx.lineWidth = 1;
      ctx.setLineDash([3, 3]);
      ctx.beginPath();
      ctx.moveTo(mu.x, mu.y);
      ctx.lineTo(point.x, point.y);
      ctx.stroke();
      ctx.setLineDash([]);
    });
  }

  // Draw comparative examples initially and whenever needed
  drawComparativePrecisionExamples();

  // ========================================
  // Wikipedia Sidebar Functionality
  // ========================================

  (function() {
    const wikiSidebar = document.getElementById('wikiSidebar');
    const wikiBackdrop = document.getElementById('wikiBackdrop');
    const wikiClose = document.getElementById('wikiClose');
    const wikiBack = document.getElementById('wikiBack');
    const wikiTitle = document.getElementById('wikiTitle');
    const wikiBody = document.getElementById('wikiBody');
    const wikiLoading = document.getElementById('wikiLoading');
    const wikiLink = document.getElementById('wikiLink');

    // History stack for back navigation
    const history = [];

    // Check if any required elements are missing
    if (!wikiSidebar || !wikiBackdrop || !wikiClose || !wikiBack || !wikiTitle || !wikiBody || !wikiLoading || !wikiLink) {
      console.error('‚ùå Wikipedia sidebar initialization failed: Missing required elements');
      return;
    }

    // Extract Wikipedia article title from URL
    function getWikiTitle(url) {
      const match = url.match(/wikipedia\.org\/wiki\/([^#?]+)/);
      return match ? decodeURIComponent(match[1]) : null;
    }

    // Open sidebar
    function openSidebar() {
      wikiSidebar.classList.add('active');
      wikiBackdrop.classList.add('active');
      document.body.style.overflow = 'hidden'; // Prevent background scrolling
    }

    // Close sidebar
    function closeSidebar() {
      wikiSidebar.classList.remove('active');
      wikiBackdrop.classList.remove('active');
      document.body.style.overflow = '';
    }

    // Fetch Wikipedia summary
    async function fetchWikiSummary(title) {
      try {
        const apiUrl = `https://en.wikipedia.org/api/rest_v1/page/summary/${encodeURIComponent(title)}`;
        const response = await fetch(apiUrl);

        if (!response.ok) {
          throw new Error(`HTTP error! status: ${response.status}`);
        }

        const data = await response.json();
        return data;
      } catch (error) {
        console.error('Error fetching Wikipedia summary:', error);
        throw error;
      }
    }

    // Fetch "See also" links from Wikipedia HTML page
    async function fetchSeeAlsoLinks(title) {
      try {
        const pageUrl = `https://en.wikipedia.org/wiki/${encodeURIComponent(title)}`;
        // Use CORS proxy to get around CORS restrictions
        const response = await fetch(`https://corsproxy.io/?${encodeURIComponent(pageUrl)}`);

        if (!response.ok) {
          console.log('‚ùå See also fetch failed:', response.status);
          return [];
        }

        const html = await response.text();
        console.log('‚úì Fetched HTML, length:', html.length);

        // Parse HTML to find "See also" section
        const parser = new DOMParser();
        const doc = parser.parseFromString(html, 'text/html');

        // Try multiple strategies to find "See also" section
        let seeAlsoSection = null;

        // Strategy 1: Look for h2 with .mw-headline containing "See also"
        const headingsWithClass = doc.querySelectorAll('h2 .mw-headline');
        console.log('üìã Found headings with .mw-headline:', headingsWithClass.length);

        for (const heading of headingsWithClass) {
          console.log('  Heading (strategy 1):', heading.textContent.trim());
          if (heading.textContent.trim() === 'See also') {
            seeAlsoSection = heading.closest('h2').nextElementSibling;
            console.log('‚úì Found "See also" section (strategy 1), tag:', seeAlsoSection?.tagName);
            break;
          }
        }

        // Strategy 2: Look for any h2 containing "See also"
        if (!seeAlsoSection) {
          const allH2s = doc.querySelectorAll('h2');
          console.log('üìã Trying strategy 2: Found h2 tags:', allH2s.length);

          for (const h2 of allH2s) {
            console.log('  H2 text:', h2.textContent.trim());
            if (h2.textContent.includes('See also')) {
              console.log('  Found "See also" h2, searching for next UL in document...');

              // Find the next UL element after this h2 in the entire document
              let current = h2;
              let found = false;
              let searchCount = 0;
              const maxSearch = 20; // Limit search to prevent infinite loops

              while (current && searchCount < maxSearch) {
                searchCount++;

                // Try nextSibling
                if (current.nextSibling) {
                  current = current.nextSibling;

                  // Skip text nodes
                  if (current.nodeType === 1) { // Element node
                    if (current.tagName === 'UL') {
                      seeAlsoSection = current;
                      console.log('‚úì Found UL via nextSibling traversal');
                      found = true;
                      break;
                    }

                    // Check if UL is inside this element
                    const ulInside = current.querySelector('ul');
                    if (ulInside) {
                      seeAlsoSection = ulInside;
                      console.log('‚úì Found UL inside', current.tagName);
                      found = true;
                      break;
                    }
                  }
                } else {
                  // Go up to parent and continue
                  current = current.parentElement;
                  if (!current) break;
                }
              }

              if (found) break;
              console.log('  Searched', searchCount, 'nodes, no UL found');
            }
          }
        }

        if (!seeAlsoSection || seeAlsoSection.tagName !== 'UL') {
          console.log('‚ùå No UL found for "See also" section');
          return [];
        }

        console.log('‚úì Found UL with', seeAlsoSection.children.length, 'items');

        // Extract links from the list
        const links = [];
        const listItems = seeAlsoSection.querySelectorAll('li > a');
        console.log('üìé Found list items with links:', listItems.length);

        for (const link of listItems) {
          const href = link.getAttribute('href');
          if (href && href.startsWith('/wiki/') && !href.includes(':')) {
            const linkTitle = href.replace('/wiki/', '');
            const displayTitle = link.textContent.trim();
            links.push({ title: linkTitle, display: displayTitle });
            console.log(`  ‚Üí ${displayTitle} (${linkTitle})`);
            if (links.length >= 4) break; // Only take first 4
          }
        }

        console.log('‚úì Returning', links.length, 'See also links');
        return links;
      } catch (error) {
        console.error('Error fetching See also links:', error);
        return [];
      }
    }

    // Knowledge graph of related topics for common pages (top 4 most relevant)
    const relatedTopics = {
      'Petal': ['Flower', 'Sepal', 'Stamen', 'Pollination'],
      'Mixture_model': ['Gaussian_mixture_model', 'Expectation‚Äìmaximization_algorithm', 'Statistical_model', 'Latent_variable'],
      'Gene_expression': ['Transcription_(biology)', 'Translation_(biology)', 'Gene_regulation', 'RNA'],
      'Gaussian_mixture_model': ['Mixture_model', 'Expectation‚Äìmaximization_algorithm', 'K-means_clustering', 'Cluster_analysis'],
      'Covariance_matrix': ['Covariance', 'Variance', 'Principal_component_analysis', 'Eigenvalues_and_eigenvectors'],
      'Eigendecomposition_of_a_matrix': ['Eigenvalues_and_eigenvectors', 'Linear_algebra', 'Principal_component_analysis', 'Matrix_(mathematics)']
    };

    // Display Wikipedia content
    function displayWikiContent(data) {
      wikiTitle.textContent = data.title || 'Wikipedia';

      // Add thumbnail image if available
      let imageHtml = '';
      if (data.thumbnail && data.thumbnail.source) {
        imageHtml = `
          <div style="float: right; margin: 0 0 8px 12px; width: 80px; height: 80px; overflow: hidden;">
            <img src="${data.thumbnail.source}"
                 alt="${data.title}"
                 style="width: 100%; height: 100%; object-fit: cover; border-radius: 4px; border: 1px solid var(--grid); opacity: 0.7;">
          </div>
        `;
      }

      // Use extract_html if available for rich formatting, otherwise fall back to plain extract
      let content = data.extract_html || `<p>${data.extract || 'No summary available.'}</p>`;

      // Strip out inline color styles that make text black
      content = content.replace(/color:\s*#?[0-9a-fA-F]{3,6}/gi, '');
      content = content.replace(/style="[^"]*color[^"]*"/gi, (match) => {
        // Remove only color property, keep other styles
        return match.replace(/color:\s*[^;"]+;?/gi, '');
      });

      wikiBody.innerHTML = imageHtml + content;

      wikiLink.href = data.content_urls?.desktop?.page || '#';

      // Make internal Wikipedia links in the content open in sidebar
      const wikiBodyLinks = wikiBody.querySelectorAll('a[href*="wikipedia.org"]');
      wikiBodyLinks.forEach(link => {
        link.addEventListener('click', (e) => handleWikiLinkClick(e, link.href));
      });

      // Fetch and display "See also" links dynamically
      console.log('üîç Fetching See also links for:', data.title);
      fetchSeeAlsoLinks(data.title.replace(/ /g, '_')).then(seeAlsoLinks => {
        console.log('‚úì Got See also links:', seeAlsoLinks);
        if (seeAlsoLinks.length > 0) {
          const relatedHtml = `
            <div style="margin-top: 24px; padding-top: 20px; border-top: 1px solid var(--grid);">
              <h4 style="margin: 0 0 12px 0; font-size: 14px; color: var(--accent); font-weight: 600; letter-spacing: 0.5px;">SEE ALSO</h4>
              <div style="display: flex; flex-direction: column; gap: 8px;">
                ${seeAlsoLinks.map(link => {
                  return `
                    <a href="https://en.wikipedia.org/wiki/${encodeURIComponent(link.title)}"
                       class="wiki-related-link"
                       data-topic="${link.title}"
                       style="display: flex; align-items: center; padding: 10px 12px; background: rgba(88, 166, 255, 0.06); border-radius: 4px; text-decoration: none; transition: all 0.2s ease; border: 1px solid transparent;">
                      <span style="color: var(--accent); font-size: 16px; margin-right: 10px; font-weight: bold;">‚Üí</span>
                      <span style="color: var(--text); font-size: 14px; flex: 1;">${link.display}</span>
                    </a>
                  `;
                }).join('')}
              </div>
            </div>
          `;
          wikiBody.innerHTML += relatedHtml;

          // Add click handlers to related links
          const relatedLinks = wikiBody.querySelectorAll('.wiki-related-link');
          relatedLinks.forEach(link => {
            link.addEventListener('click', (e) => handleWikiLinkClick(e, link.href));
            link.addEventListener('mouseenter', function() {
              this.style.background = 'rgba(88, 166, 255, 0.12)';
              this.style.borderColor = 'var(--accent)';
            });
            link.addEventListener('mouseleave', function() {
              this.style.background = 'rgba(88, 166, 255, 0.06)';
              this.style.borderColor = 'transparent';
            });
          });
        }
      });

      // Hide loading, show content
      wikiLoading.style.display = 'none';
      wikiBody.classList.add('loaded');
    }

    // Display error message
    function displayError(message) {
      wikiTitle.textContent = 'Error';
      wikiBody.innerHTML = `<p style="color: var(--accent2);">${message}</p>`;
      wikiLoading.style.display = 'none';
      wikiBody.classList.add('loaded');
    }

    // Handle Wikipedia link click
    async function handleWikiLinkClick(event, url, isBackNavigation = false) {
      console.log('üîó Wikipedia link clicked:', url);
      event.preventDefault();
      console.log('‚úì Default navigation prevented');

      const title = getWikiTitle(url);
      if (!title) {
        console.error('‚ùå Could not extract Wikipedia title from URL:', url);
        return;
      }
      console.log('üìñ Extracted title:', title);

      // Save current page to history (unless this is a back navigation)
      if (!isBackNavigation && wikiBody.innerHTML && wikiTitle.textContent !== 'Loading...') {
        history.push({
          title: wikiTitle.textContent,
          content: wikiBody.innerHTML,
          url: wikiLink.href
        });
        wikiBack.style.display = 'flex';
      }

      // Reset sidebar state
      wikiLoading.style.display = 'flex';
      wikiBody.classList.remove('loaded');
      wikiBody.innerHTML = '';
      wikiTitle.textContent = 'Loading...';

      // Open sidebar
      console.log('üö™ Opening sidebar...');
      openSidebar();

      // Fetch and display content
      try {
        console.log('üì° Fetching Wikipedia summary for:', title);
        const data = await fetchWikiSummary(title);
        console.log('‚úì Data received:', data.title);
        displayWikiContent(data);
      } catch (error) {
        console.error('‚ùå Error fetching Wikipedia content:', error);
        displayError('Failed to load Wikipedia content. Please try again later.');
      }
    }

    // Add click listeners to all Wikipedia links
    function initWikiLinks() {
      const wikiLinks = document.querySelectorAll('a[href*="wikipedia.org/wiki/"]');
      console.log(`üîó Found ${wikiLinks.length} Wikipedia link(s) on page`);

      wikiLinks.forEach((link, index) => {
        console.log(`  ${index + 1}. ${link.href}`);
        link.addEventListener('click', (e) => handleWikiLinkClick(e, link.href));
      });

      if (wikiLinks.length > 0) {
        console.log('‚úì Click listeners attached to all Wikipedia links');
      } else {
        console.warn('‚ö†Ô∏è No Wikipedia links found - sidebar will not work');
      }
    }

    // Expose globally so it can be called when DOM content is updated
    window.initWikiLinks = initWikiLinks;

    // Back button click
    wikiBack.addEventListener('click', () => {
      if (history.length > 0) {
        const previous = history.pop();
        wikiTitle.textContent = previous.title;
        wikiBody.innerHTML = previous.content;
        wikiLink.href = previous.url;

        // Re-attach event listeners to related links
        const relatedLinks = wikiBody.querySelectorAll('.wiki-related-link');
        relatedLinks.forEach(link => {
          link.addEventListener('click', (e) => handleWikiLinkClick(e, link.href));
          link.addEventListener('mouseenter', function() {
            this.style.background = 'rgba(88, 166, 255, 0.12)';
            this.style.borderColor = 'var(--accent)';
          });
          link.addEventListener('mouseleave', function() {
            this.style.background = 'rgba(88, 166, 255, 0.06)';
            this.style.borderColor = 'transparent';
          });
        });

        // Hide back button if no more history
        if (history.length === 0) {
          wikiBack.style.display = 'none';
        }
      }
    });

    // Close button click
    wikiClose.addEventListener('click', () => {
      closeSidebar();
      // Clear history when closing
      history.length = 0;
      wikiBack.style.display = 'none';
    });

    // Backdrop click
    wikiBackdrop.addEventListener('click', () => {
      closeSidebar();
      // Clear history when closing
      history.length = 0;
      wikiBack.style.display = 'none';
    });

    // Escape key to close
    document.addEventListener('keydown', (e) => {
      if (e.key === 'Escape' && wikiSidebar.classList.contains('active')) {
        closeSidebar();
      }
    });

    // Initialize Wikipedia links
    initWikiLinks();

    // Re-initialize when DOM changes (if you dynamically add content)
    // You can call initWikiLinks() again after adding new Wikipedia links
  })();

</script>
</body>
</html>
