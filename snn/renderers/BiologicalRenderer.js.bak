/**
 * BiologicalRenderer.js
 *
 * Renders biological neuron visualization with dendrites, soma, and axon.
 * Includes animated synaptic activity and action potential propagation.
 */

import { NeuronRendererBase } from './NeuronRendererBase.js';

export class BiologicalRenderer extends NeuronRendererBase {
  /**
   * Render biological neuron visualization
   * @param {CanvasRenderingContext2D} ctx
   * @param {object} modelState - {membrane, time, lastSpike, spikes, threshold, tau, input}
   * @param {object} bounds - {x, y, width, height}
   */
  render(ctx, modelState, bounds) {
    const { x, y, width, height } = bounds;

    // Center the neuron (fill entire bounds, no title)
    const neuronX = x + width / 2;
    const neuronY = y + height / 2;
    const somaRadius = 45;
    const axonLength = 180;

    // Draw pulse input visualization first (behind neuron)
    this._drawPulseInput(ctx, modelState, neuronX, neuronY, somaRadius);

    this._drawDendrites(ctx, modelState, neuronX, neuronY, somaRadius);
    this._drawSoma(ctx, modelState, neuronX, neuronY, somaRadius);
    this._drawAxon(ctx, modelState, neuronX + somaRadius, neuronY, axonLength);
  }

  _drawDendrites(ctx, modelState, centerX, centerY, somaRadius) {
    const dendriteCount = 3;

    for (let i = 0; i < dendriteCount; i++) {
      const angle = -Math.PI / 2 + (i - 1) * Math.PI / 5;
      const length = 80;
      const endX = centerX + Math.cos(angle) * length;
      const endY = centerY + Math.sin(angle) * length;

      // Draw dendrite
      ctx.strokeStyle = this.colors.dendrite;
      ctx.lineWidth = 3;
      ctx.beginPath();
      ctx.moveTo(endX, endY);
      ctx.lineTo(centerX, centerY);
      ctx.stroke();

      // Draw synapse receptor
      ctx.fillStyle = '#2a4566';
      ctx.beginPath();
      ctx.arc(endX, endY, 5, 0, Math.PI * 2);
      ctx.fill();
      ctx.strokeStyle = this.colors.calcium;
      ctx.lineWidth = 2;
      ctx.stroke();

      // Animate synaptic activity
      this._drawSynapticActivity(ctx, modelState, endX, endY, centerX, centerY, angle, i);
    }
  }

  _drawPulseInput(ctx, modelState, centerX, centerY, somaRadius) {
    // Calculate current pulse value if pulse train is enabled
    if (!modelState.pulseTrain) return;

    const period = 1000 / (modelState.pulseFrequency || 10);
    const timeInPeriod = modelState.time % period;
    const pulseDuration = modelState.pulseDuration || 5;

    if (timeInPeriod > pulseDuration) return; // No pulse active

    // Calculate pulse intensity (for alpha function or rectangular)
    let intensity = 0;
    if (modelState.pulseShape === 'alpha') {
      const tau = pulseDuration / 4;
      const normalized = timeInPeriod / tau;
      const alpha = normalized * Math.exp(1 - normalized);
      intensity = alpha; // 0 to 1
    } else {
      intensity = 1.0; // Full intensity for rectangular
    }

    // Draw glowing effect around dendrite region
    const dendriteAngles = [-Math.PI / 2 - Math.PI / 5, -Math.PI / 2, -Math.PI / 2 + Math.PI / 5];

    dendriteAngles.forEach((angle, i) => {
      const length = 80;
      const endX = centerX + Math.cos(angle) * length;
      const endY = centerY + Math.sin(angle) * length;

      // Draw glow at synapse
      const gradient = ctx.createRadialGradient(endX, endY, 0, endX, endY, 15);
      gradient.addColorStop(0, `rgba(76, 255, 107, ${intensity * 0.6})`);
      gradient.addColorStop(0.5, `rgba(76, 255, 107, ${intensity * 0.3})`);
      gradient.addColorStop(1, 'rgba(76, 255, 107, 0)');

      ctx.fillStyle = gradient;
      ctx.beginPath();
      ctx.arc(endX, endY, 15, 0, Math.PI * 2);
      ctx.fill();
    });

    // Label on first dendrite
    const angle = dendriteAngles[0];
    const length = 80;
    const labelX = centerX + Math.cos(angle) * length;
    const labelY = centerY + Math.sin(angle) * length;

    ctx.fillStyle = `rgba(76, 255, 107, ${intensity})`;
    ctx.font = 'bold 10px sans-serif';
    ctx.textAlign = 'left';
    ctx.fillText('Input Pulse', labelX - 40, labelY - 20);
    ctx.font = '9px sans-serif';
    ctx.fillText(`${(intensity * 100).toFixed(0)}%`, labelX - 40, labelY - 10);
  }

  _drawSynapticActivity(ctx, modelState, endX, endY, centerX, centerY, angle, index) {
    const phase = (this.synapticPhase + index * 0.4) % 1;

    if (phase < 0.15) {
      // Neurotransmitter approaching synapse
      const progress = 1 - phase / 0.15;
      const ntX = endX - Math.cos(angle) * 25 * progress;
      const ntY = endY - Math.sin(angle) * 25 * progress;

      ctx.fillStyle = this.colors.neurotransmitter;
      ctx.beginPath();
      ctx.arc(ntX, ntY, 5, 0, Math.PI * 2);
      ctx.fill();

      // Label on first dendrite
      if (index === 0 && phase < 0.1) {
        ctx.fillStyle = this.colors.neurotransmitter;
        ctx.font = 'bold 11px sans-serif';
        ctx.textAlign = 'left';
        ctx.fillText('Neurotransmitter', ntX + 8, ntY);
      }
    } else if (phase < 0.8) {
      // Ion current flowing into dendrite
      const ionPhase = (phase - 0.15) / 0.65;
      const ionX = endX + (centerX - endX) * ionPhase;
      const ionY = endY + (centerY - endY) * ionPhase;

      ctx.fillStyle = this.colors.calcium;
      ctx.beginPath();
      ctx.arc(ionX, ionY, 4, 0, Math.PI * 2);
      ctx.fill();

      // Label
      if (index === 1 && ionPhase > 0.3 && ionPhase < 0.5) {
        ctx.fillStyle = this.colors.calcium;
        ctx.font = 'bold 11px sans-serif';
        ctx.textAlign = 'right';
        ctx.fillText('Ca²⁺ influx', ionX - 8, ionY);
      }
    }
  }

  _drawSoma(ctx, modelState, centerX, centerY, radius) {
    // Soma with intensity based on membrane potential
    const intensity = Math.min(1, modelState.membrane / modelState.threshold);
    ctx.fillStyle = `rgba(74, 163, 255, ${0.2 + intensity * 0.6})`;
    ctx.beginPath();
    ctx.arc(centerX, centerY, radius, 0, Math.PI * 2);
    ctx.fill();
    ctx.strokeStyle = this.colors.soma;
    ctx.lineWidth = 3;
    ctx.stroke();

    // Membrane potential value
    ctx.fillStyle = this.colors.somaText;
    ctx.font = 'bold 14px sans-serif';
    ctx.textAlign = 'center';
    ctx.fillText(`V=${modelState.membrane.toFixed(2)}`, centerX, centerY + 6);

    // Label
    ctx.fillStyle = this.colors.label;
    ctx.font = 'bold 13px sans-serif';
    ctx.fillText('Soma', centerX, centerY + radius + 18);
    ctx.font = '11px sans-serif';
    ctx.fillText('(integration)', centerX, centerY + radius + 32);
  }

  _drawAxon(ctx, modelState, startX, centerY, length) {
    const endX = startX + length;

    // Draw axon hillock
    const hillockWidth = 15;
    ctx.fillStyle = '#2a4566';
    ctx.beginPath();
    ctx.moveTo(startX, centerY - 6);
    ctx.lineTo(startX + hillockWidth, centerY - 8);
    ctx.lineTo(startX + hillockWidth, centerY + 8);
    ctx.lineTo(startX, centerY + 6);
    ctx.closePath();
    ctx.fill();
    ctx.strokeStyle = this.colors.soma;
    ctx.lineWidth = 2;
    ctx.stroke();

    // Axon hillock label
    ctx.fillStyle = this.colors.label;
    ctx.font = '9px sans-serif';
    ctx.textAlign = 'center';
    ctx.fillText('Hillock', startX + hillockWidth / 2, centerY - 12);

    // Draw axon
    ctx.strokeStyle = this.colors.axon;
    ctx.lineWidth = 4;
    ctx.beginPath();
    ctx.moveTo(startX + hillockWidth, centerY);
    ctx.lineTo(endX, centerY);
    ctx.stroke();

    // Draw voltage-gated channels
    this._drawChannels(ctx, startX + hillockWidth, centerY, length - hillockWidth, 3);

    // Animate action potential
    this._drawActionPotential(ctx, modelState, startX + hillockWidth, centerY, length - hillockWidth);

    // Label
    ctx.fillStyle = this.colors.label;
    ctx.font = 'bold 13px sans-serif';
    ctx.textAlign = 'center';
    ctx.fillText('Axon', (startX + hillockWidth + endX) / 2, centerY + 60);
    ctx.font = '11px sans-serif';
    ctx.fillText('(voltage-gated Na⁺/K⁺ channels)', (startX + hillockWidth + endX) / 2, centerY + 74);
  }

  _drawChannels(ctx, startX, centerY, length, count) {
    for (let i = 0; i < count; i++) {
      const channelX = startX + (i + 1) * (length / (count + 1));

      ctx.fillStyle = '#2a4566';
      ctx.fillRect(channelX - 3, centerY - 8, 6, 16);
      ctx.strokeStyle = '#4a6a99';
      ctx.lineWidth = 1;
      ctx.strokeRect(channelX - 3, centerY - 8, 6, 16);
    }
  }

  _drawActionPotential(ctx, modelState, startX, centerY, length) {
    const timeSinceSpike = modelState.time - modelState.lastSpike;

    if (timeSinceSpike >= 0 && timeSinceSpike < 100) {
      const progress = timeSinceSpike / 100;
      const spikeX = startX + length * progress;

      // Draw multiple Na+ ions flowing inward (above axon)
      const numNaIons = 5;
      for (let i = 0; i < numNaIons; i++) {
        const offset = (i - 2) * 20; // Spread ions around main spike
        const ionX = spikeX + offset;
        const ionProgress = Math.max(0, Math.min(1, progress + (i - 2) * 0.1));
        const alpha = Math.max(0, 1 - Math.abs(i - 2) * 0.2); // Fade ions further from center

        if (ionX >= startX && ionX <= startX + length) {
          // Na+ flowing inward (from outside to inside membrane)
          const yOffset = -18 - Math.sin(ionProgress * Math.PI) * 5;
          ctx.fillStyle = `rgba(255, 107, 107, ${0.4 + alpha * 0.3})`;
          ctx.beginPath();
          ctx.arc(ionX, centerY + yOffset, 5, 0, Math.PI * 2);
          ctx.fill();

          // Draw Na+ label on center ion
          if (i === 2) {
            ctx.fillStyle = this.colors.sodium;
            ctx.font = 'bold 13px sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText('Na⁺', ionX, centerY + yOffset - 8);
            ctx.font = '10px sans-serif';
            ctx.fillText('(influx)', ionX, centerY + yOffset - 18);
          }
        }
      }

      // K+ efflux (blue) - trails behind with multiple ions
      if (progress > 0.3) {
        const numKIons = 5;
        for (let i = 0; i < numKIons; i++) {
          const offset = (i - 2) * 20;
          const kX = startX + length * (progress - 0.3) + offset;
          const alpha = Math.max(0, 1 - Math.abs(i - 2) * 0.2);

          if (kX >= startX && kX <= startX + length) {
            const kProgress = Math.max(0, Math.min(1, (progress - 0.3) * 1.4 + (i - 2) * 0.1));
            const yOffset = 18 + Math.sin(kProgress * Math.PI) * 5;
            ctx.fillStyle = `rgba(74, 163, 255, ${0.4 + alpha * 0.3})`;
            ctx.beginPath();
            ctx.arc(kX, centerY + yOffset, 5, 0, Math.PI * 2);
            ctx.fill();

            // Draw K+ label on center ion
            if (i === 2) {
              ctx.fillStyle = this.colors.potassium;
              ctx.font = 'bold 13px sans-serif';
              ctx.textAlign = 'center';
              ctx.fillText('K⁺', kX, centerY + yOffset + 8);
              ctx.font = '10px sans-serif';
              ctx.fillText('(efflux)', kX, centerY + yOffset + 18);
            }
          }
        }
      }

      // Action potential wave
      ctx.strokeStyle = this.colors.sodium;
      ctx.lineWidth = 3;
      ctx.beginPath();
      ctx.arc(spikeX, centerY, 10, 0, Math.PI * 2);
      ctx.stroke();
    }
  }
}

export default BiologicalRenderer;
