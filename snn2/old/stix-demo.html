<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>STIX Math Lite Demo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <style>
    body {
      margin: 0;
      padding: 16px 24px;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, sans-serif;
      background: #0d1117;
      color: #e6edf3;
    }
    h1, h2 {
      font-weight: 500;
      margin: 0.5em 0;
    }
    code {
      background: #111720;
      padding: 2px 4px;
      border-radius: 3px;
      font-size: 0.9em;
    }
    .section {
      margin: 1.2em 0;
      padding: 0.8em 1.0em;
      border-radius: 6px;
      border: 1px solid #30363d;
      background: #0f1622;
    }
  </style>
</head>
<body>
  <h1>STIX Math Lite Demo</h1>
  <p>
    This page shows a minimal inline/display math renderer using a single STIX
    font from a CDN. Math is written with LaTeX-like delimiters and converted
    to HTML after <code>DOMContentLoaded</code>.
  </p>

  <div class="section">
    <h2>Inline math examples</h2>
    <p>
      Posterior probability: \( p(y \mid x) = \frac{p(x \mid y)\,p(y)}{p(x)} \).
    </p>
    <p>
      Logistic unit: \( \sigma(z) = \frac{1}{1 + e^{-z}} \), cross-entropy
      loss: \( \ell = - \big( y \log \hat{y} + (1-y)\log(1-\hat{y}) \big) \).
    </p>
    <p>
      Superscripts and subscripts:
      \( w_i^2 + w_i w_j + w_{k+1}^3 \).
    </p>
  </div>

  <div class="section">
    <h2>Display math examples</h2>
    <p>Normal density:</p>
    \[
      p(x) = \frac{1}{\sqrt{2\pi\sigma^2}} \exp\left(
        -\frac{(x - \mu)^2}{2\sigma^2}
      \right)
    \]

    <p>Softmax for class \(k\) over logits \(z_j\):</p>
    \[
      p_k = \frac{\exp(z_k)}{\sum_{j=1}^{K} \exp(z_j)}
    \]

    <p>Simple fraction identity:</p>
    \[
      \frac{a}{b} + \frac{c}{d}
      = \frac{ad + bc}{bd}
    \]
  </div>

  <div class="section">
    <h2>What the parser supports</h2>
    <ul>
      <li>Inline: <code>\( ... \)</code></li>
      <li>Display: <code>\[ ... \]</code> or <code>$$ ... $$</code></li>
      <li><code>\frac{a}{b}</code> with nested braces in numerator/denominator</li>
      <li><code>\sqrt{...}</code> → √(...)</li>
      <li>Macros: <code>\sigma</code>, <code>\mu</code>, <code>\pi</code>, <code>\sum</code>, <code>\exp</code>, <code>\log</code>, <code>\ell</code>, <code>\mid</code>, <code>\left</code>, <code>\right</code>, <code>\big</code>, <code>\,</code>, <code>\hat{y}</code></li>
      <li>Superscripts: <code>x^2</code>, <code>x^{2+1}</code></li>
      <li>Subscripts: <code>x_1</code>, <code>x_{k+1}</code></li>
    </ul>
  </div>

  <script>
  (function () {
    const MATH_FONT_FAMILY = '"STIX Two Text", "Times New Roman", serif';
    const FONT_HREF = 'https://fonts.googleapis.com/css2?family=STIX+Two+Text&display=swap';

    function ensureFontLink() {
      const hrefSub = 'STIX+Two+Text';
      for (const s of document.styleSheets) {
        try {
          if (s.href && s.href.indexOf(hrefSub) !== -1) return;
        } catch (_) {}
      }
      const link = document.createElement('link');
      link.rel = 'stylesheet';
      link.href = FONT_HREF;
      document.head.appendChild(link);
    }

    function injectMathCSS() {
      if (document.getElementById('math-lite-css')) return;
      const style = document.createElement('style');
      style.id = 'math-lite-css';
      style.textContent = `
.math-inline, .math-display {
  font-family: ${MATH_FONT_FAMILY};
  font-size: 1.0em;
  line-height: 1.35;
}
.math-display {
  display: block;
  margin: 0.8em 0;
  text-align: center;
}
.math-inline code, .math-display code {
  font-family: inherit;
}
.math-frac {
  display: inline-flex;
  flex-direction: column;
  align-items: center;
  vertical-align: middle;
  line-height: 1.15;
  margin: 0 0.15em;
}
.math-frac-num {
  border-bottom: 1px solid currentColor;
  padding: 0 0.20em 0.10em;
}
.math-frac-den {
  padding: 0.10em 0.20em 0;
}
.math-sup {
  vertical-align: super;
  font-size: 0.8em;
}
.math-sub {
  vertical-align: sub;
  font-size: 0.8em;
}
`;
      document.head.appendChild(style);
    }

    function escapeHTML(str) {
      return str
        .replace(/&/g, '&amp;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;');
    }

    function extractGroup(text, startIdx) {
      const n = text.length;
      let i = startIdx;
      if (text[i] !== '{') return null;
      i++;
      let depth = 1;
      let content = '';
      for (; i < n; i++) {
        const ch = text[i];
        if (ch === '{') {
          depth++;
          content += ch;
        } else if (ch === '}') {
          depth--;
          if (depth === 0) {
            i++;
            return { content, nextIndex: i };
          }
          content += ch;
        } else {
          content += ch;
        }
      }
      return null;
    }

    function preprocessPlain(seg) {
      let s = seg.trim();

      s = s.replace(/\\hat\s*\{([^{}])\}/g, function (_, ch) {
        return ch + '\u0302';
      });

      s = s.replace(/\\sqrt\s*\{([^{}]+)\}/g, function (_, inner) {
        return '√(' + inner + ')';
      });

      s = s.replace(/\\,/g, ' ');

      const MACROS = {
        '\\sigma': 'σ',
        '\\mu': 'μ',
        '\\pi': 'π',
        '\\ell': 'ℓ',
        '\\log': 'log',
        '\\exp': 'exp',
        '\\sum': '∑',
        '\\mid': '|',
        '\\left': '',
        '\\right': '',
        '\\big': ''
      };

      s = s.replace(/\\[a-zA-Z]+/g, function (m) {
        if (Object.prototype.hasOwnProperty.call(MACROS, m)) {
          return MACROS[m];
        }
        return m.slice(1);
      });

      return s;
    }

    function renderSimpleMath(seg) {
      let s = preprocessPlain(seg);
      s = escapeHTML(s);

      // base^{...}
      s = s.replace(/([^{}\s])\^(\{([^{}]+)\})/g,
        function (_, base, _grp, body) {
          return base + '<span class="math-sup">' + renderSimpleMath(body) + '</span>';
        });

      // base_{...}
      s = s.replace(/([^{}\s])_(\{([^{}]+)\})/g,
        function (_, base, _grp, body) {
          return base + '<span class="math-sub">' + renderSimpleMath(body) + '</span>';
        });

      // base^x
      s = s.replace(/([^{}\s])\^([A-Za-z0-9+\-])/g,
        function (_, base, sup) {
          return base + '<span class="math-sup">' + sup + '</span>';
        });

      // base_x
      s = s.replace(/([^{}\s])_([A-Za-z0-9+\-])/g,
        function (_, base, sub) {
          return base + '<span class="math-sub">' + sub + '</span>';
        });

      return s;
    }

    function renderMathInline(src) {
      const text = src.trim();
      const n = text.length;
      let i = 0;
      let out = '';

      while (i < n) {
        const idx = text.indexOf('\\frac', i);
        if (idx === -1) {
          out += renderSimpleMath(text.slice(i));
          break;
        }
        if (idx > i) {
          out += renderSimpleMath(text.slice(i, idx));
        }
        let j = idx + 5;
        while (j < n && /\s/.test(text[j])) j++;
        if (j >= n || text[j] !== '{') {
          out += renderSimpleMath('\\frac');
          i = j;
          continue;
        }
        const numGroup = extractGroup(text, j);
        if (!numGroup) {
          out += renderSimpleMath('\\frac');
          i = j;
          continue;
        }
        j = numGroup.nextIndex;
        while (j < n && /\s/.test(text[j])) j++;
        if (j >= n || text[j] !== '{') {
          out += renderSimpleMath('\\frac');
          i = j;
          continue;
        }
        const denGroup = extractGroup(text, j);
        if (!denGroup) {
          out += renderSimpleMath('\\frac');
          i = j;
          continue;
        }
        const numHTML = renderMathInline(numGroup.content);
        const denHTML = renderMathInline(denGroup.content);
        out += '<span class="math-frac">' +
                 '<span class="math-frac-num">' + numHTML + '</span>' +
                 '<span class="math-frac-den">' + denHTML + '</span>' +
               '</span>';
        i = denGroup.nextIndex;
      }

      return out;
    }

    function processTextNode(node) {
      const text = node.nodeValue;
      if (!(/\\\(|\\\)|\\\[|\\\]|\$\$/g.test(text))) return;

      const parent = node.parentNode;
      const frag = document.createDocumentFragment();
      let i = 0;

      while (i < text.length) {
        const rel = text.slice(i);
        const match = rel.match(/\\\(|\\\)|\\\[|\\\]|\$\$/);
        if (!match) {
          frag.appendChild(document.createTextNode(text.slice(i)));
          break;
        }
        const idx = i + match.index;
        const token = match[0];

        if (idx > i) {
          frag.appendChild(document.createTextNode(text.slice(i, idx)));
        }

        if (token === '\\(' || token === '\\[' || token === '$$') {
          const isDisplay = (token === '\\[' || token === '$$');
          const closeTok = token === '\\(' ? '\\)' : (token === '\\[' ? '\\]' : '$$');
          const start = idx + token.length;
          const closeIdx = text.indexOf(closeTok, start);
          if (closeIdx === -1) {
            frag.appendChild(document.createTextNode(text.slice(idx, start)));
            i = start;
            continue;
          }
          const content = text.slice(start, closeIdx);
          const el = document.createElement(isDisplay ? 'div' : 'span');
          el.className = isDisplay ? 'math-display' : 'math-inline';
          el.setAttribute('data-math-src', content);
          el.innerHTML = renderMathInline(content);
          frag.appendChild(el);
          i = closeIdx + closeTok.length;
        } else {
          frag.appendChild(document.createTextNode(token));
          i = idx + token.length;
        }
      }

      parent.replaceChild(frag, node);
    }

    function walk(node) {
      if (node.nodeType === Node.TEXT_NODE) {
        processTextNode(node);
        return;
      }
      if (node.nodeType !== Node.ELEMENT_NODE) return;

      const tag = node.tagName;
      if (tag === 'SCRIPT' || tag === 'STYLE' || tag === 'CODE' || tag === 'PRE') return;

      const children = Array.from(node.childNodes);
      for (const c of children) walk(c);
    }

    function run() {
      ensureFontLink();
      injectMathCSS();
      walk(document.body);
    }

    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', run);
    } else {
      run();
    }
  })();
  </script>
</body>
</html>
