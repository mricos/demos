<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>Graph-Life | Generative Graph Morphogenesis with Coupled Oscillators</title>
<meta name="viewport" content="width=device-width,initial-scale=1" />
<style>
  :root{color-scheme:dark;--bg:#0b0b0f;--fg:#cfd8e3;--ui:#0e1223;--ui2:#0b0f1f;--ink:#a9b8ff;--hl:#86d0ff;--edge:#e9eef6;--accent:#7aa2ff;--accent2:#ffd166}
  html,body{height:100%;margin:0;background:var(--bg);color:var(--fg);font:12px/1.35 system-ui,Segoe UI,Roboto,sans-serif;overflow:hidden}
  *{box-sizing:border-box}
  .wrap{display:grid;grid-template-columns:320px 1fr;grid-template-rows:44px 1fr;height:100vh}
  .top{grid-column:1/-1;display:flex;align-items:center;gap:8px;padding:6px 10px;background:var(--ui2);border-bottom:1px solid #171a2a}
  .top .sp{flex:1}
  .stat{color:#9fb3ff;font-variant-numeric:tabular-nums}
  button{padding:4px 8px;background:#192038;color:#dbe5ff;border:1px solid #2a3558;border-radius:6px;cursor:pointer}
  button:disabled{opacity:.6;cursor:not-allowed}
  button:focus-visible{outline:2px solid rgba(134,208,255,.6);outline-offset:2px}
  .side{grid-row:2;grid-column:1;display:flex;flex-direction:column;min-width:240px;max-width:360px;width:100%;
        background:linear-gradient(#0d1226,#0b0f21);border-right:1px solid #1a2140}
  .sideHeader{display:flex;align-items:center;gap:8px;padding:8px;border-bottom:1px solid #1a2140}
  .sideBody{overflow:auto;padding:6px}
  details{border-bottom:1px solid #131a38;background:#0c1130}
  details>summary{cursor:pointer;list-style:none;padding:7px 10px;font-weight:600;display:flex;align-items:center;gap:8px;white-space:nowrap;overflow:hidden;text-overflow:ellipsis}
  details>summary::-webkit-details-marker{display:none}
  .panel{padding:8px;display:grid;gap:8px}
  .ctl{display:grid;grid-template-columns: 1fr 120px 44px;gap:6px;align-items:center}
  .ctl label{color:#c9d4ff;opacity:.9}
  .ctl output{justify-self:end;color:var(--hl);font-variant-numeric:tabular-nums}
  input[type=range]{width:100%;height:16px}
  input[type=number]{width:110px}
  .row{display:flex;gap:10px;align-items:center;flex-wrap:wrap}
  .chk{display:flex;align-items:center;gap:6px}
  .qpair{display:grid;grid-template-columns:auto 120px;gap:6px;align-items:center}
  .wheel{width:120px;height:120px;border-radius:50%;position:relative;border:1px solid #2a3558;overflow:hidden}
  .wheel canvas{width:100%;height:100%}
  .thumb{position:absolute;width:10px;height:10px;border-radius:50%;background:#fff;border:2px solid #111;box-shadow:0 0 0 2px rgba(0,0,0,.25);pointer-events:none}
  #cv{grid-row:2;grid-column:2;display:block;width:100%;height:100%;background:#000}

  .fab{position:fixed;right:16px;bottom:16px;width:56px;height:56px;border-radius:50%;
       background:#2a3558;color:#fff;border:1px solid #3d4a78;display:grid;place-items:center;
       box-shadow:0 8px 22px rgba(0,0,0,.35);cursor:pointer}
  .fab span{font-size:26px;line-height:1.1;font-weight:700}
  .sheet{position:fixed;right:16px;bottom:84px;width:320px;max-height:70vh;background:#0f142b;border:1px solid #2b365d;border-radius:12px;overflow:auto;display:none}
  .sheet.open{display:block}
  .sheet .sec{border-top:1px solid #1a2140}
  .sheet summary{padding:10px 12px;cursor:pointer;font-weight:600}
  .sheet .content{padding:8px 12px 12px;color:#b9c5ff}
  .badge{font-size:11px;background:#1a2244;border:1px solid #2e3a70;padding:1px 6px;border-radius:6px}
  .fab.learn{right:84px}
  .sheet.learn{right:84px;width:360px;max-height:75vh}
  .ctl2{display:grid;grid-template-columns: 1fr 110px;gap:6px;align-items:center;padding:2px 0}
  .row.tight{display:flex;gap:8px;align-items:center;flex-wrap:wrap}

  /* mini charts */
  .charts{display:grid;gap:8px;padding:8px}
  .chartBox{background:#0b1129;border:1px solid #1f2a55;border-radius:8px;padding:6px}
  .chartHead{display:flex;align-items:center;justify-content:space-between;margin-bottom:4px}
  .chartHead .ttl{font-weight:600;color:#a8b7ff}
  .chartHead .val{font-variant-numeric:tabular-nums;color:#d5defe}
  .mini{display:block;width:100%;height:80px;border-radius:6px;background:#070b1d}
</style>
<script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.20.0/dist/tf.min.js"></script>
</head>
<body>
  <div class="wrap">
    <div class="top">
      <button id="reset">Reset</button>
      <button id="save">Save PNG</button>
      <label class="row" style="gap:6px;margin-left:10px">
        Seed
        <input id="seed" type="number" value="1337" min="0" step="1">
        <button id="reseed">Apply</button>
      </label>
      <button id="hardSync" title="Set all phases to the same value now">Hard sync now</button>
      <div class="sp"></div>
      <div id="stats" class="stat">nodes: 0</div>
    </div>

    <aside id="side" class="side">
      <div class="sideHeader">
        <div class="title">Controls</div><div class="sp"></div>
        <div class="qpair"><span>Grav</span><input id="gravQuick" type="range" min="0" max="0.004" step="0.0001" value="0.0035"></div>
        <div class="qpair"><span>K</span><input id="coupleQuick" type="range" min="0" max="2.0" step="0.01" value="0.50"></div>
      </div>

      <div class="sideBody">
        <details open><summary>Presets</summary>
          <div class="panel row">
            <button data-preset="trilobe">Tri-lobe figure</button>
            <button data-preset="filaments">Filaments</button>
            <button data-preset="locked">Locked topology</button>
            <button data-preset="sync">Synchronize</button>
          </div>
        </details>

        <details open><summary>Growth & Topology</summary>
          <div class="panel">
            <div class="ctl"><label>Branch probability</label><input id="pBranch" type="range" min="0" max="0.2" step="0.002" value="0.018"><output id="pBranch_v">0.018</output></div>
            <div class="ctl"><label>Target edge length (L₀)</label><input id="L0" type="range" min="8" max="40" step="1" value="16"><output id="L0_v">16</output></div>
            <div class="ctl"><label>Loop-close radius ×L₀</label><input id="closeMul" type="range" min="0.9" max="2.5" step="0.05" value="1.04"><output id="closeMul_v">1.04</output></div>
            <div class="ctl"><label>Max nodes</label><input id="maxNodes" type="range" min="200" max="5000" step="10" value="1600"><output id="maxNodes_v">1600</output></div>
            <label class="chk"><input id="lockTopo" type="checkbox"> Lock topology at max</label>
          </div>
        </details>

        <details><summary>Geometry</summary>
          <div class="panel">
            <div class="ctl"><label>Repulsion</label><input id="repel" type="range" min="50" max="2500" step="10" value="520"><output id="repel_v">520</output></div>
            <div class="ctl"><label>Gravity</label><input id="grav" type="range" min="0" max="0.004" step="0.0001" value="0.0035"><output id="grav_v">0.0035</output></div>
          </div>
        </details>

        <details><summary>Phase</summary>
          <div class="panel">
            <div class="ctl"><label>Base freq ω₀</label><input id="omega0" type="range" min="0" max="0.12" step="0.001" value="0.015"><output id="omega0_v">0.015</output></div>
            <div class="ctl"><label>Coupling K</label><input id="couple" type="range" min="0" max="2.0" step="0.01" value="0.50"><output id="couple_v">0.50</output></div>
            <div class="ctl"><label>FM amplitude A</label><input id="modAmp" type="range" min="0" max="0.25" step="0.002" value="0.02"><output id="modAmp_v">0.020</output></div>
            <div class="ctl"><label>FM freq fₘ</label><input id="modFreq" type="range" min="0" max="2.0" step="0.01" value="0.16"><output id="modFreq_v">0.16</output></div>
            <div class="ctl"><label>Detune spread σ<sub>ω</sub></label><input id="detune" type="range" min="0" max="0.08" step="0.001" value="0.004"><output id="detune_v">0.004</output></div>
            <div class="ctl"><label>Phase diffusion</label><input id="diffuse" type="range" min="0" max="1.0" step="0.01" value="0.10"><output id="diffuse_v">0.10</output></div>
            <div class="row">
              <div>
                <div id="wheel" class="wheel"><canvas width="120" height="120"></canvas><div class="thumb" id="wheelThumb"></div></div>
                <div class="row" style="margin-top:6px">
                  <label class="chk"><input id="phaseColor" type="checkbox" checked> Color=phase</label>
                  <label class="chk"><input id="showVec" type="checkbox" checked> Vectors</label>
                </div>
              </div>
              <div style="flex:1">
                <div class="ctl"><label>Antenna length</label><input id="vecLen" type="range" min="0" max="36" step="1" value="12"><output id="vecLen_v">12</output></div>
              </div>
            </div>
          </div>
        </details>

        <details><summary>Antenna Crossing</summary>
          <div class="panel">
            <div class="row">
              <label class="chk"><input id="crossEnable" type="checkbox" checked> Enable</label>
              <label class="chk"><input id="crossHighlight" type="checkbox" checked> Highlight</label>
            </div>
            <div class="ctl"><label>Budget (pairs/frame)</label><input id="crossBudget" type="range" min="0" max="6000" step="50" value="1200"><output id="crossBudget_v">1200</output></div>
            <div class="ctl"><label>Bias magnitude (cycles)</label><input id="biasMag" type="range" min="0" max="0.5" step="0.005" value="0.08"><output id="biasMag_v">0.080</output></div>
            <div class="ctl"><label>Blend strength</label><input id="biasStrength" type="range" min="0" max="1" step="0.02" value="0.40"><output id="biasStrength_v">0.40</output></div>
            <div class="ctl"><label>Action</label>
              <select id="crossAction">
                <option value="nudge" selected>Phase nudge (+/−)</option>
                <option value="align">Align (mean)</option>
                <option value="swap">Swap phases</option>
                <option value="fkick">Freq kick (±)</option>
              </select>
              <output></output>
            </div>
            <div class="ctl"><label>Swap min Δφ</label><input id="swapMin" type="range" min="0" max="0.5" step="0.01" value="0.15"><output id="swapMin_v">0.15</output></div>
            <div class="ctl"><label>Lock where meet</label>
              <select id="lockMode">
                <option value="none" selected>None</option>
                <option value="edge">Add edge</option>
                <option value="pin">Pin 500ms</option>
                <option value="phaselock">Phase-lock 500ms</option>
              </select>
              <output></output>
            </div>
          </div>
        </details>

        <details open><summary>Learning (backprop)</summary>
          <div class="panel">
            <div class="ctl"><label>Unroll steps</label><input id="bpSteps" type="range" min="10" max="400" step="10" value="80"><output id="bpSteps_v">80</output></div>
            <div class="ctl"><label>LR</label><input id="bpLR" type="range" min="0.00001" max="0.05" step="0.00001" value="0.001"><output id="bpLR_v">0.00100</output></div>
            <div class="ctl"><label>Target</label>
              <select id="bpTarget">
                <option value="trefoil" selected>Trefoil SDF</option>
                <option value="ring">Ring</option>
                <option value="flower">Flower</option>
              </select><output></output>
            </div>
            <div class="row">
              <button id="bpInit">Init learnable</button>
              <button id="bpStep">Train 1 it</button>
              <button id="bp10">Train ×10</button>
              <button id="bpRun">Run</button>
              <button id="bpStop" disabled>Stop</button>
            </div>
            <div class="row">
              <span id="bpStatus" class="badge">loss: n/a</span>
              <span id="bpEpoch" class="badge">epoch: 0</span>
              <span id="bpAcc" class="badge">acc: n/a</span>
            </div>
          </div>
        </details>

        <details open><summary>Training metrics</summary>
          <div class="charts">
            <div class="chartBox">
              <div class="chartHead"><span class="ttl">Loss / Epoch</span><span id="lossVal" class="val">–</span></div>
              <canvas id="lossChart" class="mini" width="280" height="80"></canvas>
            </div>
            <div class="chartBox">
              <div class="chartHead"><span class="ttl">Accuracy / Epoch</span><span id="accVal" class="val">–</span></div>
              <canvas id="accChart" class="mini" width="280" height="80"></canvas>
            </div>
          </div>
        </details>

        <details><summary>Interaction</summary>
          <div class="panel"><div class="row">Drag = move • <b>Shift+Drag</b> = set phase • Esc = cancel</div></div>
        </details>
      </div>
    </aside>

    <canvas id="cv" aria-label="Graph canvas"></canvas>
  </div>

  <button id="fab" class="fab" title="Concepts & tips"><span>ℹ︎</span></button>
  <div id="sheet" class="sheet" aria-hidden="true">
    <details class="sec" open><summary>Sync vs. twisted states</summary>
      <div class="content">Rings/filaments admit k-twisted equilibria. Moderate K with small detune and diffusion yields gradients; high K with zero detune synchronizes.</div>
    </details>
    <details class="sec"><summary>Antenna crossings</summary>
      <div class="content">At vector crossings: nudge, align, swap, or frequency kick. Optional locks: add edge, pin, or temporary phase lock.</div>
    </details>
    <details class="sec"><summary>Model</summary>
      <div class="content">Mass–spring edges + repulsion + weak gravity; Kuramoto coupling; morphogenetic rewrites (edge split, tip branch, loop close). Phase→hue rendering.</div>
    </details>
  </div>

<script>
/* ===========================
   Core simulation (unchanged)
   =========================== */
(()=> {
  const $ = id => document.getElementById(id);
  const OUT=(id,v)=>{ const el=$(id); if(el) el.textContent=v; };

  /* Canvas */
  const cv=$('cv'), ctx=cv.getContext('2d');
  const dpr=Math.max(1, Math.min(2, window.devicePixelRatio||1));
  let W=0,H=0; function fit(){const w=cv.clientWidth*dpr|0,h=cv.clientHeight*dpr|0;if(w===W&&h===H)return;W=cv.width=w;H=cv.height=h;ctx.setTransform(dpr,0,0,dpr,0,0);} addEventListener('resize',fit); fit();

  /* Controls */
  const seedEl=$('seed'), reseedBtn=$('reseed'), saveBtn=$('save'), resetBtn=$('reset'), hardSyncBtn=$('hardSync');
  const PBR=$('pBranch'), L0=$('L0'), CM=$('closeMul'), RP=$('repel'), GV=$('grav'), MAXN=$('maxNodes'), LOCK=$('lockTopo');
  const OMG=$('omega0'), K=$('couple'), A=$('modAmp'), FM=$('modFreq'), PHC=$('phaseColor'), SHV=$('showVec'), VLEN=$('vecLen');
  const DETUNE=$('detune'), DIFF=$('diffuse');
  const CEN=$('crossEnable'), CBUD=$('crossBudget'), BMAG=$('biasMag'), BST=$('biasStrength'), CACT=$('crossAction'), CHI=$('crossHighlight');
  const LMODE=$('lockMode'), SWMIN=$('swapMin');
  const GVQ=$('gravQuick'), KVQ=$('coupleQuick');

  const outs=[['pBranch','pBranch_v',3],['L0','L0_v',0],['closeMul','closeMul_v',2],['repel','repel_v',0],['grav','grav_v',4],
              ['maxNodes','maxNodes_v',0],['omega0','omega0_v',3],['couple','couple_v',2],['modAmp','modAmp_v',3],
              ['modFreq','modFreq_v',2],['vecLen','vecLen_v',0],['crossBudget','crossBudget_v',0],['biasMag','biasMag_v',3],
              ['biasStrength','biasStrength_v',2],['detune','detune_v',3],['diffuse','diffuse_v',2],['swapMin','swapMin_v',2]];
  for (const [i,o,p] of outs){ const el=$(i), oo=$(o); if(el&&oo){ el.addEventListener('input',()=>oo.textContent=(+el.value).toFixed(p)); oo.textContent=(+el.value).toFixed(p); } }
  GVQ.addEventListener('input',()=>{ GV.value=GVQ.value; OUT('grav_v',(+GV.value).toFixed(4)); });
  GV.addEventListener('input',()=>{ GVQ.value=GV.value; });
  KVQ.addEventListener('input',()=>{ K.value=KVQ.value; OUT('couple_v',(+K.value).toFixed(2)); });
  K.addEventListener('input',()=>{ KVQ.value=K.value; });

  /* Color wheel */
  const wheelCanvas=$('wheel').querySelector('canvas'), wctx=wheelCanvas.getContext('2d'), thumb=$('wheelThumb');
  const WZ=wheelCanvas.width, HZ=wheelCanvas.height, CX=WZ/2, CY=HZ/2, R=CX-1;
  let wheelAngle=0;
  function hue2rgb(v){ const h=v*6,i=h|0,f=h-i,q=1-f,t=f;let r,g,b;
    if(i===0){r=1;g=t;b=0}else if(i===1){r=q;g=1;b=0}
    else if(i===2){r=0;g=1;b=t}else if(i===3){r=0;g=q;b=1}
    else if(i===4){r=t;g=0;b=1}else{r=1;g=0;b=q}
    return [(r*255)|0,(g*255)|0,(b*255)|0];
  }
  function drawWheel(){
    const img=wctx.createImageData(WZ,HZ), d=img.data;
    for(let y=0;y<HZ;y++)for(let x=0;x<WZ;x++){
      const dx=x-CX, dy=y-CY, rr=Math.hypot(dx,dy), k=(y*WZ+x)*4;
      if(rr>R){ d[k+3]=0; continue; }
      let ang=Math.atan2(dy,dx); if(ang<0) ang+=Math.PI*2; const hue=ang/(Math.PI*2);
      const [r,g,b]=hue2rgb(hue); d[k]=r; d[k+1]=g; d[k+2]=b; d[k+3]=255;
    }
    wctx.putImageData(img,0,0); const r=R-6; const x=CX+r*Math.cos(wheelAngle), y=CY+r*Math.sin(wheelAngle);
    thumb.style.left=(x-5)+'px'; thumb.style.top=(y-5)+'px';
  }
  function setWheelFromEvent(e){
    const rect=wheelCanvas.getBoundingClientRect();
    const x=(e.clientX-rect.left)*(WZ/rect.width); const y=(e.clientY-rect.top)*(HZ/rect.height);
    wheelAngle=Math.atan2(y-CY,x-CX); drawWheel();
  }
  wheelCanvas.addEventListener('mousedown',e=>{ setWheelFromEvent(e); draggingWheel=true; });
  let draggingWheel=false; addEventListener('mousemove',e=>{ if(draggingWheel) setWheelFromEvent(e); });
  addEventListener('mouseup',()=>draggingWheel=false); drawWheel();

  /* RNG */
  function makePRNG(seed){ let s=seed>>>0; return ()=>{ s|=0; s=(s+0x6D2B79F5)|0; let t=Math.imul(s^s>>>15,1|s); t^=t+Math.imul(t^t>>>7,61|t); return ((t^t>>>14)>>>0)/4294967296; }; }
  let rand=makePRNG(+seedEl.value||1337);

  /* Graph */
  let nodes=[], edges=[], time=0, freqKicks=[], pinLocks=[], phaseLocks=[], flashes=[];
  window.nodes = nodes; window.edges = edges; window.cv = cv;

  const makeNode=(x,y)=>({x,y,vx:0,vy:0,phi:rand(),age:0,deg:0,domega:0});
  const addEdge=(i,j)=>{ if(i===j) return; for(const [u,v] of edges){ if((u===i&&v===j)||(u===j&&v===i)) return; } edges.push([i,j]); nodes[i].deg++; nodes[j].deg++; };

  function seed(kind="ring"){
    nodes.length=0; edges.length=0; freqKicks=[]; pinLocks=[]; phaseLocks=[]; flashes=[];
    const cx=cv.width/dpr/2, cy=cv.height/dpr/2;
    if (kind==="trihub"){
      const R=42, R2=92;
      const ids=[0,1,2].map(k=>nodes.push(makeNode(cx+R*Math.cos(2*Math.PI*k/3), cy+R*Math.sin(2*Math.PI*k/3)))-1);
      addEdge(ids[0],ids[1]); addEdge(ids[1],ids[2]); addEdge(ids[2],ids[0]);
      for(let k=0;k<3;k++){ const b=2*Math.PI*k/3+Math.PI/3;
        const n1=nodes.push(makeNode(cx+R2*Math.cos(b), cy+R2*Math.sin(b)))-1; addEdge(ids[k],n1); }
    } else {
      const R=120; for(let k=0;k<12;k++){ const a=2*Math.PI*k/12; nodes.push(makeNode(cx+R*Math.cos(a), cy+R*Math.sin(a))); }
      for(let k=0;k<12;k++) addEdge(k,(k+1)%12);
      const tip=nodes.length; nodes.push(makeNode(cx+R*1.45, cy)); addEdge(0,tip);
    }
    for(const n of nodes){ n.domega=(rand()*2-1)*(+DETUNE.value); }
    window.nodes = nodes; window.edges = edges;
  }
  function reseed(){ rand=makePRNG(+seedEl.value||0); seed("trihub"); }
  reseed();
  resetBtn.onclick=()=>seed("ring");
  reseedBtn.onclick=()=>reseed();
  hardSyncBtn.onclick=()=>{ if(nodes.length){ const ph=nodes[0].phi; for(const n of nodes) n.phi=ph; } };

  const dist2=(a,b)=>{const dx=a.x-b.x, dy=a.y-b.y; return dx*dx+dy*dy; };
  const wrap1=v=>{v%=1; return v<0?v+1:v; };
  const shortestPhase=d=>{ d-=Math.floor(d+0.5); return d; };
  function nodeRadius(n){return 5+Math.min(4,0.25*Math.log1p(n.age));}
  function antennaEnd(n){ const len=+VLEN.value, R=nodeRadius(n); const ang=2*Math.PI*n.phi;
    return {x:n.x + (R+len)*Math.cos(ang), y:n.y + (R+len)*Math.sin(ang)};
  }
  function segInter(a,b,c,d){
    const x1=a.x,y1=a.y,x2=b.x,y2=b.y,x3=c.x,y3=c.y,x4=d.x,y4=d.y;
    const den=(x1-x2)*(y3-y4)-(y1-y2)*(x3-x4); if(Math.abs(den)<1e-6) return null;
    const t=((x1-x3)*(y3-y4)-(y1-y3)*(x3-x4))/den;
    const u=((x1-x3)*(y1-y2)-(y1-y3)*(x1-x2))/den;
    if(t>0 && t<1 && u>0 && u<1){ return {x:x1+t*(x2-x1), y:y1+t*(y2-y1)}; }
    return null;
  }

  function step(dt){
    const L0v=+L0.value, kSpring=0.03, repulse=+RP.value, damp=0.15;
    const grav=+GV.value, couple=+K.value, pBranch=+PBR.value;
    const closeR2=(L0v*(+CM.value))**2, omega0=+OMG.value;
    const maxNodes=(+MAXN.value|0), canRewrite=(nodes.length<maxNodes)&&!LOCK.checked?true:(nodes.length<maxNodes);

    time += dt;

    const sumCouple = new Float32Array(nodes.length);
    for (const [i,j] of edges){ const s=Math.sin(2*Math.PI*(nodes[j].phi - nodes[i].phi)); sumCouple[i]+=s; sumCouple[j]-=s; }

    const baseFM = (+A.value) * Math.sin(2*Math.PI*(+FM.value)*time);

    const kickNow = new Float32Array(nodes.length);
    freqKicks = freqKicks.filter(k=> time-k.t0 < 0.5 );
    for (const k of freqKicks){ const age=time-k.t0; kickNow[k.i]+=k.amp*(1-age/0.5); }

    phaseLocks = phaseLocks.filter(pl=> time<pl.until );
    for (const pl of phaseLocks){ nodes[pl.i].phi=pl.ph; nodes[pl.j].phi=pl.ph; }

    for (let i=0;i<nodes.length;i++){
      const n=nodes[i];
      const freq = omega0 + baseFM + n.domega + kickNow[i] + couple*sumCouple[i];
      n.phi = wrap1(n.phi + dt*freq);
      n.age+=dt;
    }

    if (+DIFF.value>0){
      const dphi=new Float32Array(nodes.length), s=+DIFF.value*0.02;
      for (const [i,j] of edges){ const d = shortestPhase(nodes[j].phi - nodes[i].phi); dphi[i]+=d; dphi[j]-=d; }
      for (let i=0;i<nodes.length;i++) nodes[i].phi = wrap1(nodes[i].phi + s*dphi[i]);
    }

    for (const [i,j] of edges){
      const a=nodes[i], b=nodes[j];
      let dx=b.x-a.x, dy=b.y-a.y; const d=Math.hypot(dx,dy)||1e-6, f=kSpring*(d-L0v);
      dx/=d; dy/=d; a.vx+=f*dx; a.vy+=f*dy; b.vx-=f*dx; b.vy-=f*dy;
    }

    pinLocks = pinLocks.filter(pl=> time<pl.until );
    for (const pl of pinLocks){
      const k=0.25;
      const a=nodes[pl.i], b=nodes[pl.j];
      a.vx += k*(pl.x - a.x); a.vy += k*(pl.y - a.y);
      b.vx += k*(pl.x - b.x); b.vy += k*(pl.y - b.y);
    }

    const cx=cv.width/dpr/2, cy=cv.height/dpr/2;
    for (let i=0;i<nodes.length;i++){
      const a=nodes[i];
      for (let j=i+1;j<nodes.length;j++){
        const b=nodes[j]; let dx=b.x-a.x, dy=b.y-a.y; let r2=dx*dx+dy*dy + 25;
        let f=repulse/r2; const inv=Math.sqrt(r2); dx/=inv; dy/=inv;
        a.vx-=f*dx; a.vy-=f*dy; b.vx+=f*dx; b.vy+=f*dy;
      }
      a.vx += -grav*(a.x - cx);
      a.vy += -grav*(a.y - cy);
    }

    for (const n of nodes){ n.vx*=(1-damp); n.vy*=(1-damp); n.x+=dt*60*n.vx; n.y+=dt*60*n.vy; }

    if (canRewrite){
      const newEdges=[];
      for (let ei=0; ei<edges.length; ei++){
        const e=edges[ei]; if(!e) continue;
        const [i,j]=e; const a=nodes[i], b=nodes[j];
        const d=Math.hypot(a.x-b.x, a.y-b.y);
        if (d>2.2*L0v && nodes.length<maxNodes){
          const mid=nodes.push(makeNode((a.x+b.x)/2,(a.y+b.y)/2))-1;
          nodes[i].deg--; nodes[j].deg--; newEdges.push([i,mid],[mid,j]); edges[ei]=null;
        }
      }
      edges = edges.filter(Boolean).concat(newEdges);

      for (let i=0;i<nodes.length;i++){
        if (nodes.length>=maxNodes) break;
        const n=nodes[i];
        if (n.deg<=2 && rand()<(+PBR.value)*dt){
          let tx=0,ty=0,cnt=0;
          for(const [u,v] of edges){ if(u===i){tx+=nodes[v].x-n.x; ty+=nodes[v].y-n.y; cnt++;} else if(v===i){tx+=nodes[u].x-n.x; ty+=nodes[u].y-n.y; cnt++;} }
          let nx = cnt? -ty : (rand()*2-1), ny = cnt? tx : (rand()*2-1);
          const s=Math.hypot(nx,ny)||1e-6; nx/=s; ny/=s;
          const j=nodes.push(makeNode(n.x+nx*L0v, n.y+ny*L0v))-1; addEdge(i,j);
          const closeR2=(L0v*(+CM.value))**2; let target=-1,best=1e9;
          for(let k=0;k<nodes.length-1;k++){ if(k===i) continue;
            const r2=dist2(nodes[j],nodes[k]); if(r2<closeR2 && r2<best){best=r2; target=k;}
          }
          if (target>=0) addEdge(j,target);
        }
      }
    }

    $('stats').textContent=`nodes: ${nodes.length}`;
    window.nodes = nodes; window.edges = edges;
  }

  const birthColor=age=>{const x=Math.min(1,age/60); return hue2rgb(x*0.85);};
  function pruneFlashes(now){ flashes = flashes.filter(s=> now - s.t < 120); }
  function draw(){
    ctx.clearRect(0,0,cv.width,cv.height);
    ctx.save(); ctx.scale(dpr,dpr);
    ctx.lineWidth=2; ctx.strokeStyle=getComputedStyle(document.documentElement).getPropertyValue('--edge').trim()||"#e9eef6";
    ctx.globalAlpha=0.7; ctx.beginPath();
    for (const [i,j] of edges){ const a=nodes[i], b=nodes[j]; ctx.moveTo(a.x,a.y); ctx.lineTo(b.x,b.y); }
    ctx.stroke(); ctx.globalAlpha=1;
    const hueBias = 0; // fixed
    for (const n of nodes){
      const phaseHue = (n.phi + hueBias)%1;
      const [r,g,b]=(PHC.checked ? hue2rgb(phaseHue) : birthColor(n.age));
      ctx.fillStyle=`rgb(${r},${g},${b})`;
      const R=nodeRadius(n);
      ctx.beginPath(); ctx.arc(n.x,n.y,R,0,Math.PI*2); ctx.fill();
      if (SHV.checked && +VLEN.value>0){
        const ang=2*Math.PI*n.phi, len=R + (+VLEN.value);
        ctx.beginPath(); ctx.lineWidth=1.25; ctx.strokeStyle=`rgba(${r},${g},${b},0.9)`;
        ctx.moveTo(n.x,n.y); ctx.lineTo(n.x+len*Math.cos(ang), n.y+len*Math.sin(ang)); ctx.stroke();
      }
    }
    if (flashes.length){
      ctx.lineWidth=3; ctx.strokeStyle="rgba(255,255,120,.95)";
      ctx.beginPath();
      for (const s of flashes){ ctx.moveTo(s.A1.x,s.A1.y); ctx.lineTo(s.A2.x,s.A2.y); ctx.moveTo(s.B1.x,s.B1.y); ctx.lineTo(s.B2.x,s.B2.y); }
      ctx.stroke();
    }
    ctx.restore();
  }

  let last=performance.now();
  function tick(t){ fit(); const dt=Math.min(0.05,(t-last)/1000); last=t; for(let k=0;k<2;k++) step(dt/2); pruneFlashes(performance.now()); draw(); requestAnimationFrame(tick); }
  requestAnimationFrame(tick);

  function applyPreset(name){
    if (name==="trilobe"){
      seedEl.value = 1337; reseed();
      L0.value=14; PBR.value=0.010; CM.value=1.02; RP.value=640; GV.value=0.0032; MAXN.value=1800;
      OMG.value=0.014; K.value=0.55; A.value=0.015; FM.value=0.14;
      DETUNE.value=0.006; DIFF.value=0.14; PHC.checked=true; SHV.checked=true; VLEN.value=10;
    } else if (name==="filaments"){
      seedEl.value = 2024; reseed();
      L0.value=18; PBR.value=0.032; CM.value=1.75; RP.value=280; GV.value=0.0020; MAXN.value=1600;
      OMG.value=0.012; K.value=0.12; A.value=0.02; FM.value=0.12;
      DETUNE.value=0.004; DIFF.value=0.06; PHC.checked=true; SHV.checked=true; VLEN.value=8;
    } else if (name==="locked"){
      MAXN.value=nodes.length; LOCK.checked=true; GV.value=0.0030;
      K.value=0.6; A.value=0; DIFF.value=0.10; DETUNE.value=0.003; PHC.checked=true; SHV.checked=true; VLEN.value=12;
    } else if (name==="sync"){
      A.value=0; K.value=1.2; OMG.value=0.02; PHC.checked=true; SHV.checked=true; VLEN.value=14; GV.value=0.0035;
      DETUNE.value=0.0; DIFF.value=0.0; CEN.checked=false; LMODE.value='none';
    }
    [['pBranch','pBranch_v',3],['L0','L0_v',0],['closeMul','closeMul_v',2],['repel','repel_v',0],['grav','grav_v',4],
     ['omega0','omega0_v',3],['couple','couple_v',2],['modAmp','modAmp_v',3],['modFreq','modFreq_v',2]].forEach(([i,o,p])=>{ const el=$(i),oo=$(o); if(el&&oo) oo.textContent=(+el.value).toFixed(p); });
  }
  document.querySelectorAll('[data-preset]').forEach(b=>b.addEventListener('click',()=>applyPreset(b.dataset.preset)));
  applyPreset('trilobe');

  const fab=$('fab'), sheet=$('sheet');
  fab.onclick=()=>{ sheet.classList.toggle('open'); sheet.ariaHidden = sheet.classList.contains('open') ? "false":"true"; };

  /* Export helpers */
  window.__sim = { cv, hue2rgb, wrap1 };
})();
</script>

<script>
/* ===========================
   Backprop controller + charts
   =========================== */
(()=> {
  const $ = id => document.getElementById(id);

  // --- mini chart utilities (loss, acc) ---
  const lossChart = $('lossChart'), accChart = $('accChart');
  const lossCtx = lossChart.getContext('2d'), accCtx = accChart.getContext('2d');
  const lossHist = []; const accHist = []; const MAXPTS = 300;
  function drawSpark(ctx, data, color, fill=false){
    const W = ctx.canvas.width, H = ctx.canvas.height;
    ctx.clearRect(0,0,W,H);
    if (data.length<2) return;
    const n = data.length;
    const xmin = Math.max(0, n - MAXPTS);
    const view = data.slice(xmin);
    const dmin = Math.min(...view), dmax = Math.max(...view);
    const rng = (dmax-dmin) || 1e-6;
    ctx.lineWidth = 1.5;
    ctx.strokeStyle = color;
    ctx.beginPath();
    for (let i=0;i<view.length;i++){
      const x = i*(W-6)/(view.length-1)+3;
      const y = H-3 - (view[i]-dmin)/rng*(H-6);
      if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
    }
    ctx.stroke();
    if (fill){
      const grad = ctx.createLinearGradient(0,0,0,H);
      grad.addColorStop(0, color+'aa'); grad.addColorStop(1, '#00000000');
      ctx.fillStyle = grad;
      ctx.lineTo(W-3,H-3); ctx.lineTo(3,H-3); ctx.closePath(); ctx.fill();
    }
    // last point marker
    const i = view.length-1;
    const x = i*(W-6)/(view.length-1)+3;
    const y = H-3 - (view[i]-dmin)/rng*(H-6);
    ctx.fillStyle = color; ctx.beginPath(); ctx.arc(x,y,2.0,0,Math.PI*2); ctx.fill();
  }
  function pushMetric(arr, v){ arr.push(v); if(arr.length>MAXPTS) arr.shift(); }

  // --- UI bindings ---
  [['bpSteps','bpSteps_v',0],['bpLR','bpLR_v',5]].forEach(([i,o,p])=>{
    const el=$(i), oo=$(o); el.addEventListener('input',()=>oo.textContent=(+el.value).toFixed(p));
  });
  const btnInit=$('bpInit'), btnStep=$('bpStep'), btn10=$('bp10'), btnRun=$('bpRun'), btnStop=$('bpStop');

  // --- controller ---
  let ctrl=null, opt=null, epoch=0, running=false;

  function mlp(inDim, hidden, outDim){
    const glorot=(r,c)=>tf.variable(tf.randomUniform([r,c],-Math.sqrt(6/(r+c)),Math.sqrt(6/(r+c))));
    const zeros =(n)=>tf.variable(tf.zeros([n]));
    return { W1:glorot(inDim,hidden), b1:zeros(hidden), W2:glorot(hidden,outDim), b2:zeros(outDim) };
  }
  function ctrlApply(params,X){ // -> [N,4]
    const h=tf.relu(tf.add(tf.matMul(X,params.W1),params.b1));
    const z=tf.tanh(tf.add(tf.matMul(h,params.W2),params.b2));
    const pB=z.slice([0,0],[-1,1]).add(1).mul(0.5).mul(0.2);
    const kS=z.slice([0,1],[-1,1]).add(1).mul(0.5);
    const rG=z.slice([0,2],[-1,1]).add(1).mul(0.5);
    const dP=z.slice([0,3],[-1,1]).mul(0.1);
    return tf.concat([pB,kS,rG,dP],1);
  }

  // pairwise helpers
  function pairwise(XY){
    const N=XY.shape[0], Xi=XY.reshape([N,1,2]), Xj=XY.reshape([1,N,2]);
    const D=Xj.sub(Xi), r2=D.square().sum(-1).add(1e-9), r=r2.sqrt();
    const U=D.div(r.expandDims(-1)); const mask=tf.ones([N,N]).sub(tf.eye(N));
    return {U,r,mask,N};
  }
  function forcesSpring(XY, edgesIdx, L0val, kSpringGain){
    if (!edgesIdx.length) return tf.zerosLike(XY);
    const N=XY.shape[0], E=edgesIdx.length, idx=tf.tensor2d(edgesIdx,[E,2],'int32');
    const ia=idx.slice([0,0],[E,1]).reshape([E]); const ib=idx.slice([0,1],[E,1]).reshape([E]);
    const a=tf.gather(XY,ia), b=tf.gather(XY,ib);
    const d=b.sub(a), dist=d.norm('euclidean',1).add(1e-9), u=d.div(dist.expandDims(1));
    const k=(typeof kSpringGain.shape!=='undefined')?tf.gather(kSpringGain.reshape([N]),ia):tf.fill([E],kSpringGain);
    const f=dist.sub(tf.scalar(L0val)).mul(0.03).mul(k);
    const Fa=u.mul(f.expandDims(1)), Fb=Fa.neg();
    const accA=tf.unsortedSegmentSum(Fa,ia,N), accB=tf.unsortedSegmentSum(Fb,ib,N);
    return accA.add(accB);
  }
  function forcesRepel(XY, repelGain){
    const {U,r,mask,N}=pairwise(XY);
    const gi=repelGain.reshape([N,1]), gj=repelGain.reshape([1,N]), g=gi.add(gj).mul(0.5);
    const f=g.div(r.square().add(1e-6));
    const F=U.mul(f.expandDims(-1)).mul(mask.expandDims(-1));
    return F.sum(1);
  }
  function kuramotoStep(PHI, edgesIdx, omega0, couple){
    const N=PHI.shape[0]; if(!edgesIdx.length) return PHI.add(tf.scalar(omega0));
    const idx=tf.tensor2d(edgesIdx,[edgesIdx.length,2],'int32');
    const ia=idx.slice([0,0],[-1,1]).reshape([-1]), ib=idx.slice([0,1],[-1,1]).reshape([-1]);
    const phi_i=tf.gather(PHI,ia), phi_j=tf.gather(PHI,ib);
    const s=tf.sin(phi_j.sub(phi_i).mul(2*Math.PI));
    const sumI=tf.unsortedSegmentSum(s.reshape([-1,1]),ia,N);
    const sumJ=tf.unsortedSegmentSum(s.neg().reshape([-1,1]),ib,N);
    const sum=sumI.add(sumJ).reshape([N]);
    return PHI.add(tf.scalar(omega0)).add(sum.mul(tf.scalar(couple)));
  }
  function featuresLocal(XY,PHI,deg,R){
    const {r,mask}=pairwise(XY);
    const near=r.lessEqual(tf.scalar(R)).mul(mask);
    const cnt=near.sum(1).add(1e-6);
    const mdist=r.mul(near).sum(1).div(cnt);
    const N=XY.shape[0], phiI=PHI.reshape([N,1]), phiJ=PHI.reshape([1,N]);
    const vphi=phiJ.sub(phiI).square().mul(near).sum(1).div(cnt);
    const gdeg=tf.tensor1d(deg,'float32');
    return tf.stack([gdeg,mdist,vphi,tf.onesLike(gdeg)],1);
  }
  function targetSDF(name,XY,cx,cy){
    const P=XY.sub(tf.tensor([cx,cy])), r=P.norm('euclidean',1);
    if(name==='ring'){ return r.sub(tf.scalar(120)).abs(); }
    const th=tf.atan2(P.slice([0,1],[-1,1]),P.slice([0,0],[-1,1])).reshape([-1]);
    if(name==='flower'){ const R=tf.scalar(100).add(tf.scalar(25).mul(tf.cos(th.mul(6)))); return r.sub(R).abs(); }
    const R=tf.scalar(110).add(tf.scalar(35).mul(tf.cos(th.mul(3)))); return r.sub(R).abs(); // trefoil proxy
  }

  async function forwardMetrics(ctrlParams){
    const nodes = window.nodes, edges = window.edges;
    const N=nodes.length, E=edges.length, edgesIdx=edges.map(([i,j])=>[i,j]);
    const L0val=+$('L0').value, omega0=+$('omega0').value, couple=+$('couple').value;
    const steps=+$('bpSteps').value;
    const center=[window.cv.width/(window.devicePixelRatio||1)/2, window.cv.height/(window.devicePixelRatio||1)/2];
    const tgt=$('bpTarget').value;
    const res = tf.tidy(()=>{
      let XY=tf.tensor2d(nodes.map(n=>[n.x,n.y]),[N,2],'float32');
      let PHI=tf.tensor1d(nodes.map(n=>n.phi),'float32');
      const deg=(()=>{ const d=new Array(N).fill(0); for(const [i,j] of edgesIdx){d[i]++; d[j]++;} return d; })();
      for(let t=0;t<steps;t++){
        const Xfeat=featuresLocal(XY,PHI,deg,L0val*1.5);
        const U=ctrlApply(ctrlParams,Xfeat);
        const u_kS=U.slice([0,1],[-1,1]);
        const u_RP=U.slice([0,2],[-1,1]);
        const u_dP=U.slice([0,3],[-1,1]).reshape([N]);
        const Fspr=forcesSpring(XY,edgesIdx,L0val,u_kS.add(1e-3));
        const Frep=forcesRepel(XY,u_RP.mul(600));
        XY=XY.add(Fspr.add(Frep).mul(tf.scalar(0.4)));
        PHI=tf.mod(kuramotoStep(PHI,edgesIdx,omega0,couple).add(u_dP), tf.scalar(1));
      }
      const sdf=targetSDF(tgt,XY,center[0],center[1]);
      const loss=sdf.mean();
      const tau=tf.scalar(6.0); // px threshold
      const acc=tf.mean(sdf.lessEqual(tau).toFloat());
      return {loss, acc};
    });
    const [lv, av] = await Promise.all([res.loss.data(), res.acc.data()]);
    res.loss.dispose(); res.acc.dispose();
    return {loss:+lv[0], acc:+av[0]};
  }

  async function trainOnce(){
    if (!window.nodes || !window.edges || !ctrl) return {loss:NaN,acc:NaN};
    const nodes = window.nodes, edges = window.edges;
    const N=nodes.length, edgesIdx=edges.map(([i,j])=>[i,j]);
    const steps=+$('bpSteps').value, omega0=+$('omega0').value, couple=+$('couple').value, L0val=+$('L0').value;
    const tgt=$('bpTarget').value, lr=+$('bpLR').value;
    if (!opt) opt=tf.train.adam(lr);
    const center=[window.cv.width/(window.devicePixelRatio||1)/2, window.cv.height/(window.devicePixelRatio||1)/2];

    let lossNum=NaN;
    const lossTensor = opt.minimize(()=>tf.tidy(()=>{
      let XY=tf.tensor2d(nodes.map(n=>[n.x,n.y]),[N,2],'float32');
      let PHI=tf.tensor1d(nodes.map(n=>n.phi),'float32');
      const deg=(()=>{ const d=new Array(N).fill(0); for(const [i,j] of edgesIdx){d[i]++; d[j]++;} return d; })();
      for(let t=0;t<steps;t++){
        const Xfeat=featuresLocal(XY,PHI,deg,L0val*1.5);
        const U=ctrlApply(ctrl,Xfeat);
        const u_kS=U.slice([0,1],[-1,1]);
        const u_RP=U.slice([0,2],[-1,1]);
        const u_dP=U.slice([0,3],[-1,1]).reshape([N]);
        const Fspr=forcesSpring(XY,edgesIdx,L0val,u_kS.add(1e-3));
        const Frep=forcesRepel(XY,u_RP.mul(600));
        XY=XY.add(Fspr.add(Frep).mul(tf.scalar(0.4)));
        PHI=tf.mod(kuramotoStep(PHI,edgesIdx,omega0,couple).add(u_dP), tf.scalar(1));
      }
      const sdf=targetSDF(tgt,XY,center[0],center[1]);
      const Lshape=sdf.mean();
      // optional regularizers
      return Lshape;
    }), true);

    const ld = await lossTensor.data(); lossNum=+ld[0]; lossTensor.dispose();

    // compute accuracy with fresh forward (no grad), keeps UI responsive
    const {acc} = await forwardMetrics(ctrl);

    return {loss:lossNum, acc};
  }

  function updateCharts(loss, acc){
    if (Number.isFinite(loss)){ pushMetric(lossHist, loss); $('lossVal').textContent = loss.toFixed(4); }
    if (Number.isFinite(acc)){ pushMetric(accHist, acc); $('accVal').textContent = (acc*100).toFixed(1)+'%'; }
    drawSpark(lossCtx, lossHist, getComputedStyle(document.documentElement).getPropertyValue('--accent').trim()||'#7aa2ff', true);
    drawSpark(accCtx, accHist, getComputedStyle(document.documentElement).getPropertyValue('--accent2').trim()||'#ffd166', true);
  }

  async function trainLoop(iters){
    btnRun.disabled = true; btnStop.disabled = false; btnStep.disabled=true; btn10.disabled=true; const status=$('bpStatus');
    for (let i=0; running && (iters<0 || i<iters); i++){
      const {loss,acc} = await trainOnce();
      epoch += 1;
      $('bpEpoch').textContent = `epoch: ${epoch}`;
      $('bpAcc').textContent = `acc: ${Number.isFinite(acc)?(acc*100).toFixed(1)+'%':'n/a'}`;
      status.textContent = `loss: ${Number.isFinite(loss)?loss.toFixed(4):'n/a'}`;
      updateCharts(loss,acc);
      await tf.nextFrame(); // keep UI responsive
    }
    btnRun.disabled = false; btnStop.disabled = true; btnStep.disabled=false; btn10.disabled=false;
  }

  // buttons
  btnInit.onclick = ()=>{
    if (ctrl){ Object.values(ctrl).forEach(v=>v.dispose&&v.dispose()); ctrl=null; }
    ctrl = mlp(4,32,4); opt = tf.train.adam(+$('bpLR').value);
    epoch=0; lossHist.length=0; accHist.length=0;
    $('bpEpoch').textContent='epoch: 0'; $('bpStatus').textContent='loss: n/a'; $('accVal').textContent='–'; $('lossVal').textContent='–';
    updateCharts(NaN,NaN);
  };
  btnStep.onclick = async ()=>{ running=true; await trainLoop(1); running=false; };
  btn10.onclick  = async ()=>{ running=true; await trainLoop(10); running=false; };
  btnRun.onclick = async ()=>{ if(running) return; running=true; await trainLoop(-1); running=false; };
  btnStop.onclick= ()=>{ running=false; };

  // init once
  btnInit.click();
})();
</script>
</body>
</html>
