<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Cubic Julia Set – z ↦ z³ + c</title>
<style>
  :root { color-scheme: dark; --bg:#0b0b10; --fg:#d8dee9; --accent:#88c0d0; --muted:#666; }
  html,body { height:100%; margin:0; background:var(--bg); color:var(--fg); font:12px/1.3 system-ui,Segoe UI,Roboto,Ubuntu,Arial,sans-serif; }
  .wrap { display:grid; grid-template-rows:auto 1fr; height:100%; }
  .controls { display:flex; gap:16px; padding:10px 12px; align-items:center; border-bottom:1px solid #181820; background:#0f111a; }
  .ctl { display:grid; grid-template-columns:80px 220px 64px; gap:8px; align-items:center; }
  .ctl label { color:#aab; }
  .ctl output { text-align:right; color:var(--accent); font-variant-numeric:tabular-nums; }
  input[type="range"] { width:100%; }
  .hint { margin-left:auto; color:#889; }
  canvas { width:100%; height:100%; display:block; cursor:grab; }
  canvas:active { cursor:grabbing; }
</style>
</head>
<body>
<div class="wrap">
  <div class="controls">
    <div class="ctl">
      <label for="re">Re(c)</label>
      <input id="re" type="range" min="-1.5" max="1.5" step="0.001" value="-0.1" />
      <output id="re_v">-0.100</output>
    </div>
    <div class="ctl">
      <label for="im">Im(c)</label>
      <input id="im" type="range" min="-1.5" max="1.5" step="0.001" value="0.65" />
      <output id="im_v">0.650</output>
    </div>
    <div class="ctl">
      <label for="it">Iterations</label>
      <input id="it" type="range" min="50" max="1500" step="10" value="400" />
      <output id="it_v">400</output>
    </div>
    <div class="hint">wheel: zoom • drag: pan • dbl-click: reset</div>
  </div>
  <canvas id="cv"></canvas>
</div>

<script>
(() => {
  // --- DOM/state ---
  const cv = document.getElementById('cv');
  const ctx = cv.getContext('2d', { alpha:false });
  const reCtl = document.getElementById('re'),  reOut = document.getElementById('re_v');
  const imCtl = document.getElementById('im'),  imOut = document.getElementById('im_v');
  const itCtl = document.getElementById('it'),  itOut = document.getElementById('it_v');

  let W = 0, H = 0, img, data;
  // complex-plane viewport
  let cx = 0.0, cy = 0.0;          // center in ℂ
  let scale = 3.0;                 // width of view (real-axis span)
  const R2 = 16.0;                 // escape radius^2 (R=4)
  let maxIter = +itCtl.value|0;
  let cRe = +reCtl.value, cIm = +imCtl.value;

  // --- utilities ---
  const fit = () => {
    const dpr = Math.min(2, window.devicePixelRatio || 1);
    const w = Math.floor(cv.clientWidth * dpr);
    const h = Math.floor(cv.clientHeight * dpr);
    if (w === W && h === H) return false;
    W = cv.width = w; H = cv.height = h;
    img = ctx.createImageData(W, 1); data = img.data;
    return true;
  };

  const hsv2rgb = (h, s, v) => {
    // h in [0,1), s,v in [0,1]
    let i = Math.floor(h*6), f = h*6 - i;
    let p = v*(1-s), q = v*(1-s*f), t = v*(1-s*(1-f));
    let r,g,b;
    switch (i % 6) {
      case 0: r=v; g=t; b=p; break;
      case 1: r=q; g=v; b=p; break;
      case 2: r=p; g=v; b=t; break;
      case 3: r=p; g=q; b=v; break;
      case 4: r=t; g=p; b=v; break;
      default:r=v; g=p; b=q; break;
    }
    return [(r*255)|0,(g*255)|0,(b*255)|0];
  };

  // Smooth coloring parameter
  const log2 = Math.log(2);

  // --- render loop (row-by-row to keep UI responsive) ---
  let needsDraw = true, row = 0;
  function draw() {
    if (!needsDraw) return;
    const dx = scale / W;
    const dy = (scale * H / W) / H;
    // top-left complex coordinate
    const x0 = cx - scale/2, y0 = cy - (scale * H / W)/2;

    const start = performance.now();
    while (row < H && (performance.now() - start) < 12) { // ~12 ms budget per frame
      const y = y0 + row * dy;
      for (let xpix=0; xpix<W; xpix++) {
        const x = x0 + xpix * dx;

        // iterate z_{n+1} = z_n^3 + c
        let zr = x, zi = y, i = 0;
        let zr2 = zr*zr, zi2 = zi*zi;
        for (; i < maxIter && (zr2 + zi2) <= R2; i++) {
          // (zr + i zi)^3 = (zr^3 - 3zr zi^2) + i(3 zr^2 zi - zi^3)
          const zr_ = zr*(zr2 - 3*zi2) + cRe;
          const zi_ = zi*(3*zr2 - zi2) + cIm;
          zr = zr_; zi = zi_;
          zr2 = zr*zr; zi2 = zi*zi;
        }

        let r,g,b,a=255;
        if (i === maxIter) {
          // in-set: dark
          r = g = b = 5;
        } else {
          // normalized iteration count (smooth)
          const m = i - Math.log(Math.log(zr2 + zi2) / 2) / log2;
          const hue = (0.75 + m * 0.015) % 1;        // rainbow
          const sat = 1.0;
          const val = 0.95;
          [r,g,b] = hsv2rgb(hue, sat, val);
        }

        const p = xpix*4;
        data[p  ] = r;
        data[p+1] = g;
        data[p+2] = b;
        data[p+3] = a;
      }
      ctx.putImageData(img, 0, row);
      row++;
    }

    if (row >= H) { needsDraw = false; row = 0; }
    requestAnimationFrame(draw);
  }

  const schedule = () => { needsDraw = true; row = 0; requestAnimationFrame(draw); };

  // --- interactions ---
  let dragging = false, lastX=0, lastY=0;
  cv.addEventListener('mousedown', e => { dragging = true; lastX=e.clientX; lastY=e.clientY; });
  window.addEventListener('mouseup',   () => dragging=false);
  window.addEventListener('mousemove', e => {
    if (!dragging) return;
    const dpr = Math.min(2, window.devicePixelRatio || 1);
    const dx = (e.clientX - lastX) * (scale / (W/dpr));
    const dy = (e.clientY - lastY) * (scale * H / W / (H/dpr));
    cx -= dx; cy -= dy; lastX=e.clientX; lastY=e.clientY; schedule();
  }, { passive:true });

  cv.addEventListener('wheel', e => {
    e.preventDefault();
    const dpr = Math.min(2, window.devicePixelRatio || 1);
    const rect = cv.getBoundingClientRect();
    const px = (e.clientX - rect.left) * dpr;
    const py = (e.clientY - rect.top)  * dpr;

    // zoom towards cursor
    const k = Math.exp(-e.deltaY * 0.0015);
    const wx = (px / W - 0.5) * scale;
    const wy = (py / H - 0.5) * (scale * H / W);
    cx += wx * (1 - 1/k);
    cy += wy * (1 - 1/k);
    scale /= k;
    schedule();
  }, { passive:false });

  cv.addEventListener('dblclick', () => { cx=0; cy=0; scale=3.0; schedule(); });

  // --- controls ---
  const syncCtl = () => {
    reOut.textContent = (+reCtl.value).toFixed(3);
    imOut.textContent = (+imCtl.value).toFixed(3);
    itOut.textContent = (maxIter = +itCtl.value|0);
    cRe = +reCtl.value; cIm = +imCtl.value;
    schedule();
  };
  [reCtl, imCtl, itCtl].forEach(el => el.addEventListener('input', syncCtl));

  // --- resize observer ---
  const onResize = () => { if (fit()) schedule(); };
  window.addEventListener('resize', onResize);
  fit(); syncCtl(); schedule();
})();
</script>
</body>
</html>
