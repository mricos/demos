<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<title>Graph-Life: loop-forming agent network</title>
<meta name="viewport" content="width=device-width,initial-scale=1">
<style>
  :root{color-scheme:dark;--bg:#0b0b0f;--fg:#cfd8e3;--ui:#111421;--hl:#86d0ff}
  html,body{height:100%;margin:0;background:var(--bg);color:var(--fg);font:12px system-ui,Segoe UI,Roboto,sans-serif}
  .row{display:flex;gap:14px;align-items:center;padding:8px 10px;background:var(--ui);border-bottom:1px solid #171a2a}
  .ctl{display:grid;grid-template-columns:120px 220px 56px;gap:8px;align-items:center}
  .ctl output{justify-self:end;color:var(--hl);font-variant-numeric:tabular-nums}
  input[type=range]{width:100%}
  canvas{display:block;width:100%;height:calc(100% - 44px);background:#000}
</style>
</head>
<body>
  <div class="row">
    <div class="ctl">
      <label>Branch probability</label>
      <input id="pBranch" type="range" min="0" max="0.2" step="0.002" value="0.040">
      <output id="pBranch_v">0.040</output>
    </div>
    <div class="ctl">
      <label>Coupling (phase)</label>
      <input id="couple" type="range" min="0" max="0.15" step="0.002" value="0.070">
      <output id="couple_v">0.070</output>
    </div>
    <div class="ctl">
      <label>Target edge length</label>
      <input id="L0" type="range" min="8" max="40" step="1" value="22">
      <output id="L0_v">22</output>
    </div>
  </div>
  <canvas id="cv"></canvas>

<script>
/* === Model ================================================================ */
/* Nodes carry: position, velocity (layout), phase (oscillator), age. */
/* Edges are springs; graph rewrites: subdivide long edges, branch stochastically,
   and close loops when tips approach existing nodes. */

(() => {
  const cv = document.getElementById('cv');
  const ctx = cv.getContext('2d');
  const dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));

  /* controls */
  const PBR   = document.getElementById('pBranch');  const PBRv = document.getElementById('pBranch_v');
  const CPL   = document.getElementById('couple');   const CPLv = document.getElementById('couple_v');
  const L0ctl = document.getElementById('L0');       const L0v  = document.getElementById('L0_v');
  const sync = () => { PBRv.textContent=(+PBR.value).toFixed(3);
                       CPLv.textContent=(+CPL.value).toFixed(3);
                       L0v.textContent =(+L0ctl.value|0); };
  [PBR,CPL,L0ctl].forEach(x=>x.addEventListener('input',sync)); sync();

  let W=0,H=0; const fit=()=>{const w=cv.clientWidth*dpr|0,h=cv.clientHeight*dpr|0;
    if(w===W&&h===H)return; W=cv.width=w; H=cv.height=h; ctx.setTransform(dpr,0,0,dpr,0,0)};
  window.addEventListener('resize',fit); fit();

  /* graph containers */
  const nodes=[]; const edges=[]; // edges: [i,j]
  const makeNode=(x,y)=>({x,y,vx:0,vy:0,phi:Math.random(),age:0,deg:0});
  const addEdge=(i,j)=>{ if(i===j) return; edges.push([i,j]); nodes[i].deg++; nodes[j].deg++; };

  /* seed: small 12-gon ring with one spur to bias tri-lobed growth */
  (() => {
    const R = 120; const cx=W/(2*dpr), cy=H/(2*dpr);
    for(let k=0;k<12;k++){ const a=2*Math.PI*k/12;
      nodes.push(makeNode(cx+R*Math.cos(a), cy+R*Math.sin(a))); }
    for(let k=0;k<12;k++) addEdge(k,(k+1)%12);
    const tip = nodes.length; nodes.push(makeNode(cx+R*1.4, cy));
    addEdge(0, tip);
  })();

  /* helpers */
  const dist2=(a,b)=>{const dx=a.x-b.x, dy=a.y-b.y; return dx*dx+dy*dy; };

  /* main simulation step */
  function step(dt){
    const L0 = +L0ctl.value;
    const kSpring = 0.03;
    const repulse = 250;        // Coulomb constant
    const damp = 0.15;
    const grav = 0.0006;        // weak central pull
    const couple = +CPL.value;  // Kuramoto coupling
    const pBranch = +PBR.value;
    const closeR2 = (L0*1.3)**2;

    /* --- oscillator coupling (on topology) --- */
    // compute Laplacian coupling Δphi = mean(neigh - self)
    const dphi = new Float32Array(nodes.length);
    for (const [i,j] of edges){ const d = nodes[j].phi - nodes[i].phi;
      const s = Math.sin(2*Math.PI*d); dphi[i]+=s; dphi[j]-=s; }
    for (let i=0;i<nodes.length;i++){
      nodes[i].phi = (nodes[i].phi + dt*(0.02 + couple*dphi[i])) % 1;
      nodes[i].age += dt;
    }

    /* --- forces for layout --- */
    // edge springs
    for (const [i,j] of edges){
      const a=nodes[i], b=nodes[j];
      let dx=b.x-a.x, dy=b.y-a.y;
      const d=Math.hypot(dx,dy)||1e-6; const f = kSpring*(d-L0);
      dx/=d; dy/=d;
      a.vx+= f*dx; a.vy+= f*dy;
      b.vx-= f*dx; b.vy-= f*dy;
    }
    // repulsion (Barnes–Hut omitted; N small)
    for (let i=0;i<nodes.length;i++){
      const a=nodes[i];
      for (let j=i+1;j<nodes.length;j++){
        const b=nodes[j];
        let dx=b.x-a.x, dy=b.y-a.y; let r2=dx*dx+dy*dy + 25;
        let f = repulse/r2; dx/=Math.sqrt(r2); dy/=Math.sqrt(r2);
        a.vx-= f*dx; a.vy-= f*dy; b.vx+= f*dx; b.vy+= f*dy;
      }
      // weak gravity to center
      a.vx += -grav*(a.x - W/(2*dpr));
      a.vy += -grav*(a.y - H/(2*dpr));
    }
    // integrate
    for (const n of nodes){
      n.vx *= (1-damp); n.vy *= (1-damp);
      n.x += dt*60*n.vx; n.y += dt*60*n.vy;
    }

    /* --- graph rewriting: subdivide long edges --- */
    const newEdges=[]; // accumulate replacements
    for (let ei=0; ei<edges.length; ei++){
      const [i,j] = edges[ei]; const a=nodes[i], b=nodes[j];
      const d = Math.hypot(a.x-b.x, a.y-b.y);
      if (d > 2.2*L0){
        const m = makeNode((a.x+b.x)/2,(a.y+b.y)/2);
        const mid = nodes.push(m)-1;
        nodes[i].deg--; nodes[j].deg--;
        newEdges.push([i,mid],[mid,j]); edges[ei]=null;
      }
    }
    // compact edges
    const e2=[]; for(const e of edges) if(e) e2.push(e); for(const e of newEdges) e2.push(e); edges.length=0; edges.push(...e2);

    /* --- branching from degree-2 “tips”; close loops when near --- */
    for (let i=0;i<nodes.length;i++){
      const n = nodes[i];
      if (n.deg<=2 && Math.random()<pBranch*dt){
        // propose a direction roughly orthogonal to local tangent
        // estimate tangent by neighbors:
        let tx=0,ty=0, cnt=0;
        for(const [u,v] of edges){ if(u===i){tx+=nodes[v].x-n.x; ty+=nodes[v].y-n.y; cnt++;} else if(v===i){tx+=nodes[u].x-n.x; ty+=nodes[u].y-n.y; cnt++;} }
        let nx = cnt? -ty : (Math.random()*2-1);
        let ny = cnt?  tx : (Math.random()*2-1);
        const nrm = Math.hypot(nx,ny)||1e-6; nx/=nrm; ny/=nrm;

        const j = nodes.push(makeNode(n.x + nx*L0, n.y + ny*L0)) - 1;
        addEdge(i,j);
        // loop closure: connect to a nearby existing node (not itself)
        let target=-1, best=1e9;
        for (let k=0;k<nodes.length-1;k++){
          if (k===i) continue;
          const r2 = dist2(nodes[j], nodes[k]);
          if (r2 < closeR2 && r2<best){ best=r2; target=k; }
        }
        if (target>=0) addEdge(j,target);
      }
    }
  }

  /* === Rendering ========================================================== */
  function hue(v){ // v in [0,1) -> rgb
    const h=v*6; const i=h|0, f=h-i;
    const q=1-f, t=f;
    let r,g,b;
    if(i===0){r=1;g=t;b=0}else if(i===1){r=q;g=1;b=0}
    else if(i===2){r=0;g=1;b=t}else if(i===3){r=0;g=q;b=1}
    else if(i===4){r=t;g=0;b=1}else{r=1;g=0;b=q}
    return [(r*255)|0,(g*255)|0,(b*255)|0];
  }

  function draw(){
    ctx.clearRect(0,0,cv.width,cv.height);
    ctx.save(); ctx.scale(dpr,dpr);
    // edges
    ctx.lineWidth = 2; ctx.strokeStyle = "#e9eef6";
    ctx.globalAlpha = 0.7;
    ctx.beginPath();
    for (const [i,j] of edges){
      const a=nodes[i], b=nodes[j];
      ctx.moveTo(a.x, a.y); ctx.lineTo(b.x, b.y);
    }
    ctx.stroke();
    ctx.globalAlpha = 1;

    // nodes
    for (const n of nodes){
      const [r,g,b]=hue(n.phi);
      ctx.fillStyle = `rgb(${r},${g},${b})`;
      const R = 5 + Math.min(4, 0.25*Math.log1p(n.age));
      ctx.beginPath(); ctx.arc(n.x, n.y, R, 0, Math.PI*2); ctx.fill();
    }
    ctx.restore();
  }

  /* === Main loop ========================================================== */
  let last=performance.now();
  function tick(t){
    fit();
    const dt = Math.min(0.05, (t-last)/1000); last=t;
    // multiple micro-steps to stabilize forces
    for(let k=0;k<2;k++) step(dt/2);
    draw();
    requestAnimationFrame(tick);
  }
  requestAnimationFrame(tick);
})();
</script>
</body>
</html>
