<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>Graph-Life | loop-forming agent network</title>
<meta name="viewport" content="width=device-width,initial-scale=1" />
<style>
  :root{color-scheme:dark;--bg:#0b0b0f;--fg:#cfd8e3;--ui:#0e1223;--ui2:#0b0f1f;--ink:#a9b8ff;--hl:#86d0ff;--edge:#e9eef6}
  html,body{height:100%;margin:0;background:var(--bg);color:var(--fg);font:12px/1.35 system-ui,Segoe UI,Roboto,sans-serif;overflow:hidden}
  *{box-sizing:border-box}

  /* Layout: fixed canvas (no page scrolling) */
  .wrap{display:grid;grid-template-columns: 300px 1fr;grid-template-rows: 44px 1fr;height:100vh}
  .top{grid-column:1/-1;display:flex;align-items:center;gap:8px;padding:6px 10px;background:var(--ui2);border-bottom:1px solid #171a2a}
  .top .sp{flex:1}
  .stat{color:#9fb3ff;font-variant-numeric:tabular-nums}
  button{padding:4px 8px;background:#192038;color:#dbe5ff;border:1px solid #2a3558;border-radius:6px}
  button:focus-visible{outline:2px solid rgba(134,208,255,.6);outline-offset:2px}

  /* Sidebar — persistent, independent scroll; starts collapsed sections */
  .side{grid-row:2;grid-column:1;display:flex;flex-direction:column;min-width:240px;max-width:360px;width:100%;
        background:linear-gradient(#0d1226,#0b0f21);border-right:1px solid #1a2140}
  .sideHeader{display:flex;align-items:center;gap:8px;padding:8px;border-bottom:1px solid #1a2140}
  .sideBody{overflow:auto;padding:6px}
  .grp{padding:6px 8px;color:#8fa6ff;border-top:1px solid #141a2f;font-weight:600}
  details{border-bottom:1px solid #131a38;background:#0c1130}
  details>summary{cursor:pointer;list-style:none;padding:7px 10px;font-weight:600;display:flex;align-items:center;gap:8px}
  details>summary::-webkit-details-marker{display:none}
  .panel{padding:8px 8px 10px;display:grid;gap:8px}
  .ctl{display:grid;grid-template-columns: 1fr 120px 44px;gap:6px;align-items:center}
  .ctl label{color:#c9d4ff;opacity:.9}
  .ctl output{justify-self:end;color:var(--hl);font-variant-numeric:tabular-nums}
  input[type=range]{width:100%;height:16px}
  .row{display:flex;gap:10px;align-items:center;flex-wrap:wrap}
  .chk{display:flex;align-items:center;gap:6px}
  .hint{color:#9aa6cc}
  .tight *{margin:0}

  /* Color wheel knob */
  .wheel{width:128px;height:128px;border-radius:50%;position:relative;border:1px solid #2a3558;overflow:hidden}
  .wheel canvas{width:100%;height:100%}
  .thumb{position:absolute;width:10px;height:10px;border-radius:50%;background:#fff;border:2px solid #111;box-shadow:0 0 0 2px rgba(0,0,0,.25);pointer-events:none}

  /* Canvas */
  #cv{grid-row:2;grid-column:2;display:block;width:100%;height:100%;background:#000}

  /* Crossing flash */
  .flash { box-shadow:0 0 0 2px #ff7; }

</style>
</head>
<body>
  <div class="wrap">
    <div class="top">
      <button id="reset">Reset</button>
      <button id="save">Save PNG</button>
      <label class="row" style="gap:6px;margin-left:10px">
        Seed
        <input id="seed" type="number" value="1337" min="0" step="1" style="width:100px">
        <button id="reseed">Apply</button>
      </label>
      <div class="sp"></div>
      <div id="stats" class="stat">nodes: 0</div>
    </div>

    <!-- SIDEBAR -->
    <aside id="side" class="side tight">
      <div class="sideHeader">
        <div class="title">Controls</div>
        <div class="sp"></div>
        <!-- Always-visible quick knobs -->
        <div class="row">
          <label class="row" title="Gravity"><span>Grav</span>
            <input id="gravQuick" type="range" min="0" max="0.004" step="0.0001" value="0.0035" style="width:120px">
          </label>
          <label class="row" title="Coupling K"><span>K</span>
            <input id="coupleQuick" type="range" min="0" max="2.0" step="0.01" value="0.45" style="width:120px">
          </label>
        </div>
      </div>

      <div class="sideBody">
        <div class="grp">Presets</div>
        <details open>
          <summary>Quick setups</summary>
          <div class="panel">
            <div class="row">
              <button data-preset="trilobe">Tri-lobe figure</button>
              <button data-preset="filaments">Filaments</button>
              <button data-preset="locked">Locked topology</button>
              <button data-preset="sync">Synchronize</button>
            </div>
          </div>
        </details>

        <div class="grp">Growth & Topology</div>
        <details><!-- collapsed by default -->
          <summary>Branch / loops / limits</summary>
          <div class="panel">
            <div class="ctl"><label>Branch probability</label><input id="pBranch" type="range" min="0" max="0.2" step="0.002" value="0.018"><output id="pBranch_v">0.018</output></div>
            <div class="ctl"><label>Target edge length (L₀)</label><input id="L0" type="range" min="8" max="40" step="1" value="16"><output id="L0_v">16</output></div>
            <div class="ctl"><label>Loop-close radius ×L₀</label><input id="closeMul" type="range" min="0.9" max="2.5" step="0.05" value="1.04"><output id="closeMul_v">1.04</output></div>
            <div class="ctl"><label>Max nodes</label><input id="maxNodes" type="range" min="200" max="5000" step="10" value="1600"><output id="maxNodes_v">1600</output></div>
            <div class="chk"><input id="lockTopo" type="checkbox"><label for="lockTopo">Lock topology at max</label></div>
          </div>
        </details>

        <div class="grp">Geometry</div>
        <details>
          <summary>Forces</summary>
          <div class="panel">
            <div class="ctl"><label>Repulsion</label><input id="repel" type="range" min="50" max="2500" step="10" value="520"><output id="repel_v">520</output></div>
            <div class="ctl"><label>Gravity</label><input id="grav" type="range" min="0" max="0.004" step="0.0001" value="0.0035"><output id="grav_v">0.0035</output></div>
          </div>
        </details>

        <div class="grp">Phase</div>
        <details>
          <summary>Oscillators & color</summary>
          <div class="panel">
            <div class="ctl"><label>Base freq ω₀ (cy/s)</label><input id="omega0" type="range" min="0" max="0.12" step="0.001" value="0.015"><output id="omega0_v">0.015</output></div>
            <div class="ctl"><label>Coupling K</label><input id="couple" type="range" min="0" max="2.0" step="0.01" value="0.45"><output id="couple_v">0.45</output></div>
            <div class="ctl"><label>FM amplitude A</label><input id="modAmp" type="range" min="0" max="0.25" step="0.002" value="0.02"><output id="modAmp_v">0.020</output></div>
            <div class="ctl"><label>FM freq fₘ (Hz)</label><input id="modFreq" type="range" min="0" max="2.0" step="0.01" value="0.16"><output id="modFreq_v">0.16</output></div>

            <div class="ctl"><label>Detune spread σ<sub>ω</sub></label><input id="detune" type="range" min="0" max="0.08" step="0.001" value="0.004"><output id="detune_v">0.004</output></div>
            <div class="ctl"><label>Phase diffusion (Laplacian)</label><input id="diffuse" type="range" min="0" max="1.0" step="0.01" value="0.10"><output id="diffuse_v">0.10</output></div>

            <div class="row">
              <div>
                <div style="margin-bottom:6px">Hue/phase wheel bias</div>
                <div id="wheel" class="wheel"><canvas width="128" height="128"></canvas><div class="thumb" id="wheelThumb"></div></div>
                <div class="row" style="margin-top:6px">
                  <label class="chk"><input id="phaseColor" type="checkbox" checked> Color=phase</label>
                  <label class="chk"><input id="showVec" type="checkbox" checked> Vectors</label>
                </div>
              </div>
              <div style="flex:1">
                <div class="ctl"><label>Antenna length</label><input id="vecLen" type="range" min="0" max="36" step="1" value="12"><output id="vecLen_v">12</output></div>
              </div>
            </div>
          </div>
        </details>

        <div class="grp">Antenna Crossing</div>
        <details>
          <summary>Detection & response</summary>
          <div class="panel">
            <div class="row">
              <label class="chk"><input id="crossEnable" type="checkbox" checked> Enable detection</label>
              <label class="chk"><input id="crossHighlight" type="checkbox" checked> Highlight events</label>
            </div>
            <div class="ctl"><label>Budget (pairs/frame)</label><input id="crossBudget" type="range" min="0" max="6000" step="50" value="1200"><output id="crossBudget_v">1200</output></div>
            <div class="ctl"><label>Bias magnitude (cycles)</label><input id="biasMag" type="range" min="0" max="0.5" step="0.005" value="0.08"><output id="biasMag_v">0.080</output></div>
            <div class="ctl"><label>Blend strength</label><input id="biasStrength" type="range" min="0" max="1" step="0.02" value="0.40"><output id="biasStrength_v">0.40</output></div>
            <div class="ctl" style="grid-template-columns: 1fr;">
              <label for="crossAction">On crossing → action</label>
              <select id="crossAction">
                <option value="nudge" selected>Phase nudge (+θ to one, −θ to other)</option>
                <option value="align">Align (both → mean)</option>
                <option value="swap">Swap phases</option>
                <option value="fkick">Frequency kick (±Δω for 0.5 s)</option>
              </select>
            </div>
          </div>
        </details>

      </div>
    </aside>

    <canvas id="cv" aria-label="Graph canvas"></canvas>
  </div>

<script>
(() => {
  const $ = id => document.getElementById(id);
  const OUT=(id,v)=>{ const el=$(id); if(el) el.textContent=v; };

  /* Canvas */
  const cv=$('cv'), ctx=cv.getContext('2d');
  const dpr=Math.max(1, Math.min(2, window.devicePixelRatio||1));
  let W=0,H=0; function fit(){const w=cv.clientWidth*dpr|0,h=cv.clientHeight*dpr|0;if(w===W&&h===H)return;W=cv.width=w;H=cv.height=h;ctx.setTransform(dpr,0,0,dpr,0,0);} addEventListener('resize',fit); fit();

  /* Controls */
  const seedEl=$('seed'); const reseedBtn=$('reseed');
  const saveBtn=$('save'); const resetBtn=$('reset');

  const PBR=$('pBranch'), L0=$('L0'), CM=$('closeMul'), RP=$('repel'), GV=$('grav'), MAXN=$('maxNodes'), LOCK=$('lockTopo');
  const OMG=$('omega0'), K=$('couple'), A=$('modAmp'), FM=$('modFreq'), PHC=$('phaseColor'), SHV=$('showVec'), VLEN=$('vecLen');
  const DETUNE=$('detune'), DIFF=$('diffuse');
  const CEN=$('crossEnable'), CBUD=$('crossBudget'), BMAG=$('biasMag'), BST=$('biasStrength'), CACT=$('crossAction'), CHI=$('crossHighlight');

  // quick mirrors
  const GVQ=$('gravQuick'), KVQ=$('coupleQuick');
  GVQ.addEventListener('input',()=>{ GV.value=GVQ.value; OUT('grav_v',(+GV.value).toFixed(4)); });
  GV.addEventListener('input',()=>{ GVQ.value=GV.value; });
  KVQ.addEventListener('input',()=>{ K.value=KVQ.value; OUT('couple_v',(+K.value).toFixed(2)); });
  K.addEventListener('input',()=>{ KVQ.value=K.value; });

  const outputs=[['pBranch','pBranch_v',3],['L0','L0_v',0],['closeMul','closeMul_v',2],['repel','repel_v',0],['grav','grav_v',4],
                 ['maxNodes','maxNodes_v',0],['omega0','omega0_v',3],['couple','couple_v',2],['modAmp','modAmp_v',3],
                 ['modFreq','modFreq_v',2],['vecLen','vecLen_v',0],['crossBudget','crossBudget_v',0],['biasMag','biasMag_v',3],
                 ['biasStrength','biasStrength_v',2],['detune','detune_v',3],['diffuse','diffuse_v',2]];
  for(const [i,o,p] of outputs){ const el=$(i), oo=$(o); if(el&&oo){ el.addEventListener('input',()=>oo.textContent=(+el.value).toFixed(p)); oo.textContent=(+el.value).toFixed(p); } }

  /* Color wheel bias (phase & hue) */
  const wheelEl=$('wheel'); const wheelCanvas=wheelEl.querySelector('canvas'); const wctx=wheelCanvas.getContext('2d'); const thumb=$('wheelThumb');
  const WZ=wheelCanvas.width, HZ=wheelCanvas.height, CX=WZ/2, CY=HZ/2, R=CX-1;
  let wheelAngle=0; // radians, maps to global phase/hue bias
  function drawWheel(){
    const img=wctx.createImageData(WZ,HZ); const d=img.data;
    for(let y=0;y<HZ;y++){ for(let x=0;x<WZ;x++){
      const dx=x-CX, dy=y-CY, r=Math.sqrt(dx*dx+dy*dy); if(r>R){ const k=(y*WZ+x)*4; d[k+3]=0; continue; }
      let ang=Math.atan2(dy,dx); if(ang<0) ang+=Math.PI*2; const hue=ang/(Math.PI*2);
      const [rr,gg,bb]=hue2rgb(hue); const k=(y*WZ+x)*4; d[k]=rr; d[k+1]=gg; d[k+2]=bb; d[k+3]=255;
    }}
    wctx.putImageData(img,0,0);
    placeThumb();
  }
  function placeThumb(){ const r=R-6; const x=CX + r*Math.cos(wheelAngle), y=CY + r*Math.sin(wheelAngle);
    thumb.style.left=(x-5)+'px'; thumb.style.top=(y-5)+'px';
  }
  function setWheelFromEvent(e){
    const rect=wheelCanvas.getBoundingClientRect(); const x=(e.clientX-rect.left)*(WZ/rect.width); const y=(e.clientY-rect.top)*(HZ/rect.height);
    wheelAngle=Math.atan2(y-CY,x-CX); drawWheel();
  }
  wheelCanvas.addEventListener('mousedown',e=>{ setWheelFromEvent(e); draggingWheel=true; });
  let draggingWheel=false; addEventListener('mousemove',e=>{ if(draggingWheel) setWheelFromEvent(e); });
  addEventListener('mouseup',()=>draggingWheel=false);
  drawWheel();

  /* RNG (deterministic) */
  function makePRNG(seed){
    let s=seed>>>0; return ()=>{ s|=0; s=(s+0x6D2B79F5)|0; let t=Math.imul(s^s>>>15,1|s); t^=t+Math.imul(t^t>>>7,61|t); return ((t^t>>>14)>>>0)/4294967296; };
  }
  let rand=makePRNG(+seedEl.value||1337);

  /* Graph state */
  let nodes=[], edges=[], time=0, temporaryFreqKicks=[];
  const dprInv=1/dpr;
  const makeNode=(x,y)=>({x,y,vx:0,vy:0,phi:rand(),age:0,deg:0, domega:0 });
  const addEdge=(i,j)=>{ if(i===j) return; edges.push([i,j]); nodes[i].deg++; nodes[j].deg++; };

  function seed(kind="ring"){
    nodes=[]; edges=[]; temporaryFreqKicks=[];
    const cx=W*(dprInv)/2, cy=H*(dprInv)/2;
    if (kind==="trihub"){
      const R=42, R2=92;
      const ids=[0,1,2].map(k=>nodes.push(makeNode(cx+R*Math.cos(2*Math.PI*k/3), cy+R*Math.sin(2*Math.PI*k/3)))-1);
      addEdge(ids[0],ids[1]); addEdge(ids[1],ids[2]); addEdge(ids[2],ids[0]);
      for(let k=0;k<3;k++){ const b=2*Math.PI*k/3+Math.PI/3;
        const n1=nodes.push(makeNode(cx+R2*Math.cos(b), cy+R2*Math.sin(b)))-1; addEdge(ids[k],n1); }
    } else {
      const R=120; for(let k=0;k<12;k++){ const a=2*Math.PI*k/12; nodes.push(makeNode(cx+R*Math.cos(a), cy+R*Math.sin(a))); }
      for(let k=0;k<12;k++) addEdge(k,(k+1)%12);
      const tip=nodes.length; nodes.push(makeNode(cx+R*1.45, cy)); addEdge(0,tip);
    }
    // assign detuned domega
    for(const n of nodes){ n.domega=(rand()*2-1)*(+DETUNE.value); }
  }

  function reseed(){ rand=makePRNG(+seedEl.value||0); seed("trihub"); }

  reseed();
  resetBtn.onclick=()=>seed("ring");
  reseedBtn.onclick=()=>reseed();

  const dist2=(a,b)=>{const dx=a.x-b.x, dy=a.y-b.y; return dx*dx+dy*dy; };
  const wrap1=v=>{v%=1; return v<0?v+1:v; };

  function nodeRadius(n){return 5+Math.min(4,0.25*Math.log1p(n.age));}
  function antennaEnd(n){
    const len=+VLEN.value, R=nodeRadius(n); const ang=2*Math.PI*n.phi;
    return {x:n.x + (R+len)*Math.cos(ang), y:n.y + (R+len)*Math.sin(ang)};
  }
  function segInter(a,b,c,d){
    const x1=a.x,y1=a.y,x2=b.x,y2=b.y,x3=c.x,y3=c.y,x4=d.x,y4=d.y;
    const den=(x1-x2)*(y3-y4)-(y1-y2)*(x3-x4);
    if(Math.abs(den)<1e-6) return false;
    const t=((x1-x3)*(y3-y4)-(y1-y3)*(x3-x4))/den;
    const u=((x1-x3)*(y1-y2)-(y1-y3)*(x1-x2))/den;
    return t>0 && t<1 && u>0 && u<1;
  }

  /* Phase Laplacian (diffusion) */
  function phaseDiffusion(str){
    if(str<=0) return;
    const dphi=new Float32Array(nodes.length);
    for (const [i,j] of edges){
      let d = shortestPhase(nodes[j].phi - nodes[i].phi);
      dphi[i]+=d; dphi[j]-=d;
    }
    for (let i=0;i<nodes.length;i++){
      nodes[i].phi = wrap1(nodes[i].phi + str*0.02*dphi[i]); // small stable step
    }
  }
  function shortestPhase(d){ d-=Math.floor(d+0.5); return d; } // map to [-0.5,0.5)

  /* Dynamics */
  function step(dt){
    const L0v=+L0.value, kSpring=0.03, repulse=+RP.value, damp=0.15;
    const grav=+GV.value, couple=+K.value, pBranch=+PBR.value;
    const closeR2=(L0v*(+CM.value))**2, omega0=+OMG.value;
    const maxNodes=(+MAXN.value|0);
    const canRewrite = (nodes.length<maxNodes) && !LOCK.checked ? true : (nodes.length<maxNodes);
    const hueBias = wheelAngle/(2*Math.PI); // cycles

    time += dt;

    // Global FM + detuning + temporary frequency kicks
    const baseFM = (+A.value) * Math.sin(2*Math.PI*(+FM.value)*time);
    const kickNow = (i)=>{ let k=0; for(const p of temporaryFreqKicks){ if(p.i===i){ k += p.amp*Math.exp(-(time-p.t0)/0.5); } } return k; };

    // Kuramoto sum
    const sumCouple = new Float32Array(nodes.length);
    for (const [i,j] of edges){ const s=Math.sin(2*Math.PI*(nodes[j].phi - nodes[i].phi)); sumCouple[i]+=s; sumCouple[j]-=s; }

    // integrate phases
    for (let i=0;i<nodes.length;i++){
      const n=nodes[i];
      const domega = n.domega; // detuned
      const freq = omega0 + baseFM + domega + kickNow(i) + couple*sumCouple[i];
      n.phi = wrap1(n.phi + dt*freq + hueBias*0); // hueBias is visual bias; keep phase physics unbiased
      n.age+=dt;
    }

    // optional phase diffusion
    phaseDiffusion(+DIFF.value*dt);

    // springs
    for (const [i,j] of edges){
      const a=nodes[i], b=nodes[j];
      let dx=b.x-a.x, dy=b.y-a.y; const d=Math.hypot(dx,dy)||1e-6, f=kSpring*(d-L0v);
      dx/=d; dy/=d; a.vx+=f*dx; a.vy+=f*dy; b.vx-=f*dx; b.vy-=f*dy;
    }
    // repulsion + gravity
    const cx=W*(1/dpr)/2, cy=H*(1/dpr)/2;
    for (let i=0;i<nodes.length;i++){
      const a=nodes[i];
      for (let j=i+1;j<nodes.length;j++){
        const b=nodes[j]; let dx=b.x-a.x, dy=b.y-a.y; let r2=dx*dx+dy*dy + 25;
        let f=repulse/r2; const inv=Math.sqrt(r2); dx/=inv; dy/=inv;
        a.vx-=f*dx; a.vy-=f*dy; b.vx+=f*dx; b.vy+=f*dy;
      }
      a.vx += -grav*(a.x - cx);
      a.vy += -grav*(a.y - cy);
    }
    // integrate
    for (const n of nodes){ n.vx*=(1-damp); n.vy*=(1-damp); n.x+=dt*60*n.vx; n.y+=dt*60*n.vy; }

    // rewriting
    if (canRewrite){
      const newEdges=[];
      for (let ei=0; ei<edges.length; ei++){
        const e=edges[ei]; if(!e) continue;
        const [i,j]=e; const a=nodes[i], b=nodes[j];
        const d=Math.hypot(a.x-b.x, a.y-b.y);
        if (d>2.2*L0v && nodes.length<maxNodes){
          const mid=nodes.push(makeNode((a.x+b.x)/2,(a.y+b.y)/2))-1;
          nodes[i].deg--; nodes[j].deg--; newEdges.push([i,mid],[mid,j]); edges[ei]=null;
        }
      }
      edges = edges.filter(Boolean).concat(newEdges);

      // branch + loop close
      for (let i=0;i<nodes.length;i++){
        if (nodes.length>=maxNodes) break;
        const n=nodes[i];
        if (n.deg<=2 && rand()<pBranch*dt){
          let tx=0,ty=0,cnt=0;
          for(const [u,v] of edges){ if(u===i){tx+=nodes[v].x-n.x; ty+=nodes[v].y-n.y; cnt++;} else if(v===i){tx+=nodes[u].x-n.x; ty+=nodes[u].y-n.y; cnt++;} }
          let nx = cnt? -ty : (rand()*2-1), ny = cnt? tx : (rand()*2-1);
          const s=Math.hypot(nx,ny)||1e-6; nx/=s; ny/=s;
          const j=nodes.push(makeNode(n.x+nx*L0v, n.y+ny*L0v))-1; addEdge(i,j);

          let target=-1,best=1e9;
          for(let k=0;k<nodes.length-1;k++){ if(k===i) continue;
            const r2=dist2(nodes[j],nodes[k]); if(r2<closeR2 && r2<best){best=r2; target=k;}
          }
          if (target>=0) addEdge(j,target);
        }
      }
    }

    // antenna crossing actions
    if (CEN.checked && +VLEN.value>0 && nodes.length>1){
      const N=nodes.length, budget=(+CBUD.value|0), bias=(+BMAG.value), str=(+BST.value);
      const theta = wheelAngle/(2*Math.PI); // cycles on color wheel → phase offset
      for (let m=0;m<budget;m++){
        const i=(rand()*N)|0, j=(rand()*N)|0; if(i===j) continue;
        const a=nodes[i], b=nodes[j];
        const A1={x:a.x,y:a.y}, A2=antennaEnd(a), B1={x:b.x,y:b.y}, B2=antennaEnd(b);
        if (segInter(A1,A2,B1,B2)){
          if (CHI.checked) flashCanvas(A1,A2,B1,B2);
          if (CACT.value==='nudge'){
            a.phi = wrap1(a.phi + str*( bias+theta ));
            b.phi = wrap1(b.phi - str*( bias+theta ));
          } else if (CACT.value==='align'){
            const mean=wrap1(a.phi + shortestPhase(b.phi-a.phi)/2);
            a.phi=b.phi=mean;
          } else if (CACT.value==='swap'){
            const t=a.phi; a.phi=b.phi; b.phi=t;
          } else if (CACT.value==='fkick'){
            temporaryFreqKicks.push({i,amp:(bias+theta),t0:time});
            temporaryFreqKicks.push({i:j,amp:-(bias+theta),t0:time});
          }
        }
      }
      // cleanup old kicks
      temporaryFreqKicks = temporaryFreqKicks.filter(p=> time-p.t0 < 2.0 );
    }

    $('stats').textContent=`nodes: ${nodes.length}`;
  }

  /* Render */
  function hue2rgb(v){ const h=v*6,i=h|0,f=h-i,q=1-f,t=f;let r,g,b;
    if(i===0){r=1;g=t;b=0}else if(i===1){r=q;g=1;b=0}
    else if(i===2){r=0;g=1;b=t}else if(i===3){r=0;g=q;b=1}
    else if(i===4){r=t;g=0;b=1}else{r=1;g=0;b=q}
    return [(r*255)|0,(g*255)|0,(b*255)|0];
  }
  const birthColor=age=>{const x=Math.min(1,age/60); return hue2rgb(x*0.85);};

  function draw(){
    ctx.clearRect(0,0,cv.width,cv.height);
    ctx.save(); ctx.scale(dpr,dpr);
    // edges
    ctx.lineWidth=2; ctx.strokeStyle=getComputedStyle(document.documentElement).getPropertyValue('--edge').trim()||"#e9eef6";
    ctx.globalAlpha=0.7; ctx.beginPath();
    for (const [i,j] of edges){ const a=nodes[i], b=nodes[j]; ctx.moveTo(a.x,a.y); ctx.lineTo(b.x,b.y); }
    ctx.stroke(); ctx.globalAlpha=1;
    // nodes
    const hueBias = wheelAngle/(2*Math.PI);
    for (const n of nodes){
      const phaseHue = wrap1(n.phi + hueBias);
      const [r,g,b]=(PHC.checked ? hue2rgb(phaseHue) : birthColor(n.age));
      ctx.fillStyle=`rgb(${r},${g},${b})`;
      const R=nodeRadius(n);
      ctx.beginPath(); ctx.arc(n.x,n.y,R,0,Math.PI*2); ctx.fill();
      if (SHV.checked && +VLEN.value>0){
        const ang=2*Math.PI*n.phi, len=R + (+VLEN.value);
        ctx.beginPath(); ctx.lineWidth=1.25; ctx.strokeStyle=`rgba(${r},${g},${b},0.9)`;
        ctx.moveTo(n.x,n.y); ctx.lineTo(n.x+len*Math.cos(ang), n.y+len*Math.sin(ang)); ctx.stroke();
      }
    }
    // draw crossing flashes (if any)
    if (flashSegs.length){
      ctx.lineWidth=3; ctx.strokeStyle="rgba(255,255,120,.9)";
      ctx.beginPath();
      for (const s of flashSegs){ ctx.moveTo(s.x1,s.y1); ctx.lineTo(s.x2,s.y2); ctx.moveTo(s.x3,s.y3); ctx.lineTo(s.x4,s.y4); }
      ctx.stroke();
    }
    ctx.restore();
  }

  /* Crossing flash visuals */
  let flashSegs=[];
  function flashCanvas(A1,A2,B1,B2){
    flashSegs.push({x1:A1.x,y1:A1.y,x2:A2.x,y2:A2.y,x3:B1.x,y3:B1.y,x4:B2.x,y4:B2.y,t:performance.now()});
  }
  function pruneFlashes(now){ flashSegs = flashSegs.filter(s=> now - s.t < 120); }

  /* Mouse: move node / shift=phase */
  let drag = {idx:-1, phaseMode:false};
  function eventPos(e){const rect=cv.getBoundingClientRect(); return {x:(e.clientX-rect.left), y:(e.clientY-rect.top)};}
  function pickNode(px,py){
    let best=-1,bd2=100;
    for (let i=0;i<nodes.length;i++){
      const n=nodes[i], d2=(n.x-px)*(n.x-px)+(n.y-py)*(n.y-py);
      if (d2<bd2){ bd2=d2; best=i; }
    }
    return best;
  }
  cv.addEventListener('mousedown',e=>{
    const p=eventPos(e), i=pickNode(p.x,p.y);
    if (i>=0){ drag.idx=i; drag.phaseMode=e.shiftKey; e.preventDefault(); }
  });
  addEventListener('mousemove',e=>{
    if (drag.idx<0) return;
    const p=eventPos(e), n=nodes[drag.idx];
    if (drag.phaseMode){
      const ang=Math.atan2(p.y-n.y, p.x-n.x);
      n.phi = wrap1(ang/(2*Math.PI));
    } else {
      n.x=p.x; n.y=p.y; n.vx=0; n.vy=0;
    }
  });
  ['mouseup','mouseleave','blur'].forEach(ev=>addEventListener(ev,()=>{drag.idx=-1;}));
  addEventListener('keydown',e=>{ if(e.key==='Escape') drag.idx=-1; });

  /* Save PNG */
  saveBtn.onclick=()=>{
    const a=document.createElement('a');
    a.download=`graph-life-${Date.now()}.png`;
    a.href=cv.toDataURL('image/png');
    a.click();
  };

  /* Loop */
  let last=performance.now();
  function tick(t){ fit(); const dt=Math.min(0.05,(t-last)/1000); last=t; for(let k=0;k<2;k++) step(dt/2); pruneFlashes(performance.now()); draw(); requestAnimationFrame(tick); }
  requestAnimationFrame(tick);

  /* Presets — tuned for tri-lobe & screenshot-like looks */
  function applyPreset(name){
    if (name==="trilobe"){
      seedEl.value = 1337; reseed();
      L0.value=14; PBR.value=0.010; CM.value=1.02; RP.value=640; GV.value=0.0032; GVQ.value=GV.value; MAXN.value=1800;
      OMG.value=0.014; K.value=0.55; KVQ.value=K.value; A.value=0.015; FM.value=0.14;
      DETUNE.value=0.006; DIFF.value=0.14;
      PHC.checked=true; SHV.checked=true; VLEN.value=10;
      CEN.checked=true; CBUD.value=1400; BMAG.value=0.06; BST.value=0.45; CACT.value='nudge';
      wheelAngle = Math.PI*0.07; drawWheel();
    } else if (name==="filaments"){
      seedEl.value = 2024; reseed();
      L0.value=18; PBR.value=0.032; CM.value=1.75; RP.value=280; GV.value=0.0020; GVQ.value=GV.value; MAXN.value=1600;
      OMG.value=0.012; K.value=0.12; KVQ.value=K.value; A.value=0.02; FM.value=0.12;
      DETUNE.value=0.004; DIFF.value=0.06;
      PHC.checked=false; SHV.checked=false; VLEN.value=6;
      CEN.checked=false; CBUD.value=400; BMAG.value=0.04; BST.value=0.25; CACT.value='nudge';
      wheelAngle=0; drawWheel();
    } else if (name==="locked"){
      MAXN.value=nodes.length+0; LOCK.checked=true; GV.value=0.0030; GVQ.value=GV.value;
      K.value=0.6; KVQ.value=K.value; A.value=0; DIFF.value=0.10; DETUNE.value=0.003; PHC.checked=true; SHV.checked=true; VLEN.value=12;
      CEN.checked=true; CBUD.value=800; BMAG.value=0.05; BST.value=0.40; CACT.value='align';
      wheelAngle = Math.PI*0.02; drawWheel();
    } else if (name==="sync"){
      A.value=0; K.value=1.2; KVQ.value=K.value; OMG.value=0.02; PHC.checked=true; SHV.checked=true; VLEN.value=14; GV.value=0.0035; GVQ.value=GV.value;
      DETUNE.value=0.0; DIFF.value=0.0; CEN.checked=false;
      wheelAngle=0; drawWheel();
    }
    // reflect numeric outputs
    for(const [i,o,p] of outputs){ const el=$(i), oo=$(o); if(el&&oo) oo.textContent=(+el.value).toFixed(p); }
  }
  document.querySelectorAll('[data-preset]').forEach(b=>b.addEventListener('click',()=>applyPreset(b.dataset.preset)));
  applyPreset('trilobe'); // boot with tri-lobe

})();
</script>
</body>
</html>
