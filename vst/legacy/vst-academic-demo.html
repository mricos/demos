<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Variable Scale Transform: An Interactive Exploration</title>
    
    <!-- MathJax for LaTeX rendering -->
    <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    
    <!-- Marked for Markdown rendering -->
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --bg-primary: #ffffff;
            --bg-secondary: #f8f9fa;
            --bg-tertiary: #e9ecef;
            --text-primary: #212529;
            --text-secondary: #6c757d;
            --accent-primary: #0066cc;
            --accent-secondary: #004499;
            --border-color: #dee2e6;
            --highlight: #fff3cd;
            --highlight-border: #ffc107;
            --success: #28a745;
            --danger: #dc3545;
        }

        body {
            font-family: 'Georgia', 'Times New Roman', serif;
            background: var(--bg-primary);
            color: var(--text-primary);
            line-height: 1.6;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
        }

        /* Header */
        header {
            text-align: center;
            padding: 40px 20px;
            border-bottom: 2px solid var(--border-color);
            margin-bottom: 30px;
        }

        h1 {
            font-size: 32px;
            font-weight: 400;
            margin-bottom: 10px;
            color: var(--text-primary);
        }

        .authors {
            font-size: 14px;
            color: var(--text-secondary);
            font-style: italic;
            margin-bottom: 20px;
        }

        .abstract {
            max-width: 800px;
            margin: 0 auto;
            text-align: left;
            font-size: 14px;
            line-height: 1.8;
            padding: 20px;
            background: var(--bg-secondary);
            border-left: 3px solid var(--accent-primary);
        }

        .abstract h3 {
            font-size: 16px;
            font-weight: 600;
            margin-bottom: 10px;
        }

        /* Layout */
        .main-layout {
            display: grid;
            grid-template-columns: 300px 1fr;
            gap: 30px;
            margin-top: 30px;
        }

        /* Sidebar Navigation */
        .sidebar {
            position: sticky;
            top: 20px;
            height: fit-content;
        }

        .sidebar h3 {
            font-size: 14px;
            font-weight: 600;
            margin-bottom: 15px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            color: var(--text-secondary);
        }

        .nav-list {
            list-style: none;
        }

        .nav-list li {
            margin-bottom: 8px;
        }

        .nav-list a {
            text-decoration: none;
            color: var(--text-primary);
            font-size: 14px;
            display: block;
            padding: 8px 12px;
            border-radius: 4px;
            transition: all 0.2s;
        }

        .nav-list a:hover {
            background: var(--bg-secondary);
            color: var(--accent-primary);
        }

        .nav-list a.active {
            background: var(--accent-primary);
            color: white;
        }

        /* Content */
        .content {
            background: var(--bg-primary);
        }

        .section {
            display: none;
            margin-bottom: 40px;
        }

        .section.active {
            display: block;
        }

        .section h2 {
            font-size: 24px;
            font-weight: 400;
            margin-bottom: 20px;
            padding-bottom: 10px;
            border-bottom: 1px solid var(--border-color);
        }

        .section h3 {
            font-size: 18px;
            font-weight: 600;
            margin: 25px 0 15px 0;
        }

        .section p {
            margin-bottom: 15px;
            text-align: justify;
        }

        /* Two-column layout for theory + visualization */
        .split-view {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 30px;
            margin: 30px 0;
        }

        .theory-panel {
            background: var(--bg-secondary);
            padding: 25px;
            border-radius: 4px;
            border: 1px solid var(--border-color);
        }

        .theory-panel h4 {
            font-size: 16px;
            font-weight: 600;
            margin-bottom: 15px;
            color: var(--accent-primary);
        }

        .theory-panel .math-block {
            background: white;
            padding: 15px;
            border-radius: 4px;
            margin: 15px 0;
            overflow-x: auto;
            border-left: 3px solid var(--accent-primary);
        }

        /* Controls Panel */
        .controls-panel {
            background: var(--bg-secondary);
            padding: 25px;
            border-radius: 4px;
            border: 1px solid var(--border-color);
            margin-bottom: 30px;
        }

        .controls-panel h4 {
            font-size: 16px;
            font-weight: 600;
            margin-bottom: 20px;
            color: var(--text-primary);
        }

        .control-group {
            margin-bottom: 25px;
        }

        .control-label {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
            font-size: 14px;
            font-weight: 500;
        }

        .control-value {
            font-family: 'Courier New', monospace;
            color: var(--accent-primary);
            font-weight: 600;
        }

        input[type="range"] {
            width: 100%;
            height: 4px;
            border-radius: 2px;
            background: var(--bg-tertiary);
            outline: none;
            -webkit-appearance: none;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: var(--accent-primary);
            cursor: pointer;
            border: 2px solid white;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }

        input[type="range"]::-moz-range-thumb {
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: var(--accent-primary);
            cursor: pointer;
            border: 2px solid white;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }

        button {
            padding: 10px 20px;
            background: var(--accent-primary);
            color: white;
            border: none;
            border-radius: 4px;
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            transition: background 0.2s;
            font-family: inherit;
        }

        button:hover {
            background: var(--accent-secondary);
        }

        button.secondary {
            background: white;
            color: var(--accent-primary);
            border: 1px solid var(--accent-primary);
        }

        button.secondary:hover {
            background: var(--bg-secondary);
        }

        /* Visualization */
        .viz-container {
            background: white;
            padding: 20px;
            border-radius: 4px;
            border: 1px solid var(--border-color);
            margin: 20px 0;
        }

        .viz-title {
            font-size: 14px;
            font-weight: 600;
            margin-bottom: 15px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            color: var(--text-secondary);
        }

        canvas {
            width: 100%;
            height: 300px;
            display: block;
            background: var(--bg-primary);
        }

        .canvas-info {
            margin-top: 10px;
            padding-top: 10px;
            border-top: 1px solid var(--border-color);
            font-size: 13px;
            color: var(--text-secondary);
        }

        /* Comparison Table */
        .comparison-table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
            font-size: 14px;
        }

        .comparison-table th {
            background: var(--bg-secondary);
            padding: 12px;
            text-align: left;
            font-weight: 600;
            border-bottom: 2px solid var(--border-color);
        }

        .comparison-table td {
            padding: 12px;
            border-bottom: 1px solid var(--border-color);
        }

        .comparison-table tr:hover {
            background: var(--bg-secondary);
        }

        .metric-better {
            color: var(--success);
            font-weight: 600;
        }

        /* Info Box */
        .info-box {
            background: var(--highlight);
            border: 1px solid var(--highlight-border);
            padding: 15px;
            border-radius: 4px;
            margin: 20px 0;
            font-size: 14px;
        }

        .info-box strong {
            display: block;
            margin-bottom: 5px;
            color: var(--text-primary);
        }

        /* Highlight regions on canvas */
        .highlight-indicator {
            display: inline-block;
            width: 12px;
            height: 12px;
            border-radius: 2px;
            margin-right: 8px;
            vertical-align: middle;
        }

        .highlight-f1 { background: #dc3545; }
        .highlight-f2 { background: #007bff; }
        .highlight-harmonics { background: #28a745; }

        /* Examples grid */
        .examples-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin: 30px 0;
        }

        .example-card {
            background: var(--bg-secondary);
            padding: 20px;
            border-radius: 4px;
            border: 1px solid var(--border-color);
            cursor: pointer;
            transition: all 0.2s;
        }

        .example-card:hover {
            border-color: var(--accent-primary);
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }

        .example-card h4 {
            font-size: 16px;
            font-weight: 600;
            margin-bottom: 10px;
        }

        .example-card p {
            font-size: 13px;
            color: var(--text-secondary);
        }

        /* Responsive */
        @media (max-width: 1024px) {
            .main-layout {
                grid-template-columns: 1fr;
            }

            .sidebar {
                position: static;
            }

            .split-view {
                grid-template-columns: 1fr;
            }
        }

        /* Math typography */
        mjx-container {
            display: inline-block;
            margin: 0.2em 0;
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>The Variable Scale Transform</h1>
            <p class="authors">An Interactive Exploration of Logarithmic Resolution in Time-Frequency Analysis</p>
            <div class="abstract">
                <h3>Abstract</h3>
                <p>The Variable Scale Transform (VST) extends the Laplace transform through introduction of a scaling function λ(t) in the exponential kernel, achieving frequency-dependent resolution that matches perceptual requirements. We demonstrate the VST's advantages for musical signal analysis by comparing its performance against the standard FFT when resolving closely-spaced musical tones. This interactive demonstration allows direct manipulation of fundamental frequencies, scaling parameters, and visualization of the resulting transform properties.</p>
            </div>
        </header>

        <div class="main-layout">
            <aside class="sidebar">
                <h3>Navigation</h3>
                <ul class="nav-list">
                    <li><a href="#introduction" class="nav-link active" data-section="introduction">1. Introduction</a></li>
                    <li><a href="#two-tone" class="nav-link" data-section="two-tone">2. Two-Tone Problem</a></li>
                    <li><a href="#vst-theory" class="nav-link" data-section="vst-theory">3. VST Formulation</a></li>
                    <li><a href="#scaling" class="nav-link" data-section="scaling">4. Scaling Functions</a></li>
                    <li><a href="#comparison" class="nav-link" data-section="comparison">5. FFT vs VST</a></li>
                    <li><a href="#harmonics" class="nav-link" data-section="harmonics">6. Harmonic Analysis</a></li>
                    <li><a href="#examples" class="nav-link" data-section="examples">7. Musical Examples</a></li>
                    <li><a href="#conclusion" class="nav-link" data-section="conclusion">8. Conclusions</a></li>
                </ul>
            </aside>

            <main class="content">
                <!-- Section 1: Introduction -->
                <section id="introduction" class="section active">
                    <h2>1. Introduction: The Problem of Fixed Resolution</h2>
                    
                    <p>The Fourier transform provides uniform frequency resolution across the entire spectrum. For a signal of duration T, each frequency bin has width Δf = 1/T. This uniform resolution is suboptimal for analyzing musical signals, where:</p>
                    
                    <ul style="margin: 15px 0 15px 40px;">
                        <li>Low frequencies require fine resolution (distinguishing E from F)</li>
                        <li>High frequencies contain densely-spaced harmonics that need not be individually resolved</li>
                        <li>Human pitch perception operates on a logarithmic frequency scale</li>
                    </ul>

                    <p>Consider two guitar strings tuned to adjacent notes: E₂ (82.4 Hz) and F₂ (87.3 Hz). The frequency difference is merely 4.9 Hz. Their second harmonics at 164.8 Hz and 174.6 Hz are separated by 9.8 Hz—exactly double. This doubling pattern continues throughout the harmonic series.</p>

                    <div class="info-box">
                        <strong>Key Insight:</strong>
                        Musical intervals represent constant ratios, not constant differences. A transform that allocates resolution logarithmically matches this natural structure.
                    </div>

                    <div class="theory-panel">
                        <h4>Mathematical Foundation</h4>
                        <p>The standard Fourier transform is defined as:</p>
                        <div class="math-block">
                            $$X(f) = \int_{-\infty}^{\infty} x(t) e^{-j2\pi ft} dt$$
                        </div>
                        <p>With uniform frequency sampling, adjacent bins differ by constant Δf. The Variable Scale Transform modifies this kernel to achieve frequency-dependent resolution.</p>
                    </div>
                </section>

                <!-- Section 2: Two-Tone Problem -->
                <section id="two-tone" class="section">
                    <h2>2. The Two-Tone Resolution Problem</h2>
                    
                    <p>We begin with the fundamental challenge: resolving two closely-spaced frequencies. Adjust the sliders below to position two tones and observe how the FFT and VST resolve them differently.</p>

                    <div class="controls-panel">
                        <h4>Tone Configuration</h4>
                        
                        <div class="control-group">
                            <div class="control-label">
                                <span><span class="highlight-indicator highlight-f1"></span>Tone 1 Frequency (Hz)</span>
                                <span class="control-value" id="f1-value">82.4</span>
                            </div>
                            <input type="range" id="f1-slider" min="60" max="200" value="82.4" step="0.1">
                        </div>

                        <div class="control-group">
                            <div class="control-label">
                                <span><span class="highlight-indicator highlight-f2"></span>Tone 2 Frequency (Hz)</span>
                                <span class="control-value" id="f2-value">87.3</span>
                            </div>
                            <input type="range" id="f2-slider" min="60" max="200" value="87.3" step="0.1">
                        </div>

                        <div class="control-group">
                            <div class="control-label">
                                <span>Frequency Separation</span>
                                <span class="control-value" id="separation-value">4.9 Hz</span>
                            </div>
                        </div>

                        <div class="control-group">
                            <div class="control-label">
                                <span>Frequency Ratio</span>
                                <span class="control-value" id="ratio-value">1.059</span>
                            </div>
                        </div>
                    </div>

                    <div class="viz-container">
                        <div class="viz-title">Time Domain Signal</div>
                        <canvas id="two-tone-signal"></canvas>
                        <div class="canvas-info">
                            Two sinusoids with exponential decay envelope. Sample rate: 44100 Hz, Duration: 2.0 s
                        </div>
                    </div>

                    <div class="theory-panel">
                        <h4>Signal Model</h4>
                        <p>The two-tone test signal is constructed as:</p>
                        <div class="math-block">
                            $$x(t) = e^{-\alpha t}\left[\cos(2\pi f_1 t) + \cos(2\pi f_2 t)\right]$$
                        </div>
                        <p>where α is the decay rate (typically 2-3 s⁻¹ for guitar-like transients), and f₁, f₂ are the two fundamental frequencies. The analytic signal representation is:</p>
                        <div class="math-block">
                            $$z(t) = e^{-\alpha t}\left[e^{j2\pi f_1 t} + e^{j2\pi f_2 t}\right]$$
                        </div>
                    </div>
                </section>

                <!-- Section 3: VST Theory -->
                <section id="vst-theory" class="section">
                    <h2>3. Variable Scale Transform Formulation</h2>

                    <div class="split-view">
                        <div class="theory-panel">
                            <h4>Continuous Formulation</h4>
                            <p>The Variable Scale Transform is defined by modifying the Laplace transform's exponential kernel:</p>
                            <div class="math-block">
                                $$\mathcal{V}\{x(t)\}(s) = \int_{0}^{\infty} x(t) e^{-s\lambda(t)} dt$$
                            </div>
                            <p>where λ(t) is a monotonically increasing scaling function. For standard Laplace transform, λ(t) = t. For logarithmic resolution, we use:</p>
                            <div class="math-block">
                                $$\lambda(t) = t^{\alpha}, \quad 0 < \alpha \leq 1$$
                            </div>
                            <p>The complex frequency is s = σ + jω, where σ controls decay and ω represents frequency.</p>
                        </div>

                        <div class="theory-panel">
                            <h4>Resolution Properties</h4>
                            <p>The instantaneous resolution is governed by the derivative:</p>
                            <div class="math-block">
                                $$\lambda'(t) = \alpha t^{\alpha-1}$$
                            </div>
                            <p>For α < 1, λ'(t) decreases with time, providing:</p>
                            <ul style="margin-left: 20px; font-size: 14px;">
                                <li>Fine resolution at early times (low frequencies)</li>
                                <li>Coarse resolution at late times (high frequencies)</li>
                                <li>Smooth transition between regimes</li>
                            </ul>
                            <p>The effective frequency resolution at frequency f scales as:</p>
                            <div class="math-block">
                                $$\Delta f \propto f^{1-\alpha}$$
                            </div>
                        </div>
                    </div>

                    <div class="controls-panel">
                        <h4>Transform Parameters</h4>
                        
                        <div class="control-group">
                            <div class="control-label">
                                <span>Scaling Exponent α</span>
                                <span class="control-value" id="alpha-value">0.75</span>
                            </div>
                            <input type="range" id="alpha-slider" min="0.5" max="1.0" value="0.75" step="0.01">
                        </div>

                        <div class="control-group">
                            <div class="control-label">
                                <span>Quality Factor Q</span>
                                <span class="control-value" id="q-value">15</span>
                            </div>
                            <input type="range" id="q-slider" min="5" max="50" value="15" step="1">
                        </div>

                        <div class="control-group">
                            <div class="control-label">
                                <span>Bins per Octave</span>
                                <span class="control-value" id="bins-value">36</span>
                            </div>
                            <input type="range" id="bins-slider" min="12" max="72" value="36" step="12">
                        </div>
                    </div>
                </section>

                <!-- Section 4: Scaling Functions -->
                <section id="scaling" class="section">
                    <h2>4. Scaling Function Analysis</h2>

                    <p>The choice of scaling function λ(t) determines the resolution characteristics. We examine the power-law family λ(t) = t^α for various α values.</p>

                    <div class="viz-container">
                        <div class="viz-title">Scaling Function λ(t) = t^α</div>
                        <canvas id="scaling-function"></canvas>
                        <div class="canvas-info">
                            Comparison of scaling functions for different α values. Lower α provides more compression.
                        </div>
                    </div>

                    <div class="viz-container">
                        <div class="viz-title">Derivative λ'(t) = α·t^(α-1)</div>
                        <canvas id="scaling-derivative"></canvas>
                        <div class="canvas-info">
                            The derivative represents instantaneous time-scale warping factor.
                        </div>
                    </div>

                    <div class="theory-panel">
                        <h4>Interpretation</h4>
                        <p>The scaling function warps the time axis logarithmically. For α = 0.5:</p>
                        <div class="math-block">
                            $$\lambda(t) = \sqrt{t} \implies d\lambda = \frac{1}{2\sqrt{t}}dt$$
                        </div>
                        <p>Early in the signal (small t), equal time increments dt map to larger λ increments, providing fine frequency resolution. Later (large t), the same dt maps to smaller dλ, coarsening the resolution.</p>
                    </div>
                </section>

                <!-- Section 5: Comparison -->
                <section id="comparison" class="section">
                    <h2>5. Direct Comparison: FFT vs VST</h2>

                    <p>We now directly compare the standard FFT with the Variable Scale Transform for the two-tone signal configured in Section 2.</p>

                    <div style="display: flex; gap: 15px; margin: 20px 0;">
                        <button id="compute-transforms">Compute Transforms</button>
                        <button class="secondary" id="toggle-log-scale">Toggle Log Scale</button>
                    </div>

                    <div class="viz-container">
                        <div class="viz-title">Standard FFT Spectrum</div>
                        <canvas id="fft-spectrum"></canvas>
                        <div class="canvas-info" id="fft-info">
                            FFT Size: 4096, Resolution: 10.8 Hz
                        </div>
                    </div>

                    <div class="viz-container">
                        <div class="viz-title">Variable Scale Transform Spectrum</div>
                        <canvas id="vst-spectrum"></canvas>
                        <div class="canvas-info" id="vst-info">
                            Bins per octave: 36, Logarithmic frequency axis
                        </div>
                    </div>

                    <h3>Quantitative Comparison</h3>

                    <table class="comparison-table">
                        <thead>
                            <tr>
                                <th>Metric</th>
                                <th>FFT</th>
                                <th>VST</th>
                                <th>Improvement</th>
                            </tr>
                        </thead>
                        <tbody id="comparison-table-body">
                            <tr>
                                <td>Bins between tones</td>
                                <td id="fft-bins">—</td>
                                <td id="vst-bins" class="metric-better">—</td>
                                <td id="bins-improvement">—</td>
                            </tr>
                            <tr>
                                <td>Resolution at f₁</td>
                                <td id="fft-res-f1">—</td>
                                <td id="vst-res-f1" class="metric-better">—</td>
                                <td id="res-f1-improvement">—</td>
                            </tr>
                            <tr>
                                <td>Peak separation (σ)</td>
                                <td id="fft-separation">—</td>
                                <td id="vst-separation" class="metric-better">—</td>
                                <td id="separation-improvement">—</td>
                            </tr>
                        </tbody>
                    </table>

                    <div class="theory-panel">
                        <h4>Why VST Performs Better</h4>
                        <p>The FFT with N samples provides constant resolution Δf = f_s/N. To resolve two tones separated by Δf_tones requires:</p>
                        <div class="math-block">
                            $$N \geq \frac{f_s}{\Delta f_{tones}}$$
                        </div>
                        <p>For f₁=82.4 Hz and f₂=87.3 Hz (Δf=4.9 Hz), this requires N ≥ 9000 samples at 44.1 kHz, giving excellent low-frequency resolution but wasteful over-sampling at high frequencies.</p>
                        <p>The VST achieves equivalent low-frequency resolution with B bins per octave:</p>
                        <div class="math-block">
                            $$\Delta f \approx \frac{f}{B} \cdot \frac{\ln(2)}{1}$$
                        </div>
                        <p>With B=36, at 82 Hz: Δf ≈ 1.6 Hz (sufficient), while at 5 kHz: Δf ≈ 100 Hz (coarse but adequate for dense harmonics).</p>
                    </div>
                </section>

                <!-- Section 6: Harmonics -->
                <section id="harmonics" class="section">
                    <h2>6. Harmonic Series Analysis</h2>

                    <p>Musical tones contain harmonic overtones at integer multiples of the fundamental. The VST's logarithmic spacing naturally accommodates this structure.</p>

                    <div class="controls-panel">
                        <h4>Harmonic Configuration</h4>
                        
                        <div class="control-group">
                            <div class="control-label">
                                <span>Fundamental Frequency (Hz)</span>
                                <span class="control-value" id="harm-f0-value">110.0</span>
                            </div>
                            <input type="range" id="harm-f0-slider" min="60" max="400" value="110" step="0.1">
                        </div>

                        <div class="control-group">
                            <div class="control-label">
                                <span>Number of Harmonics</span>
                                <span class="control-value" id="num-harmonics-value">8</span>
                            </div>
                            <input type="range" id="num-harmonics-slider" min="1" max="12" value="8" step="1">
                        </div>

                        <div class="control-group">
                            <div class="control-label">
                                <span>Harmonic Decay Rate</span>
                                <span class="control-value" id="harm-decay-value">3.0</span>
                            </div>
                            <input type="range" id="harm-decay-slider" min="0.5" max="8" value="3" step="0.1">
                        </div>

                        <button id="compute-harmonics">Generate Harmonic Signal</button>
                    </div>

                    <div class="viz-container">
                        <div class="viz-title">VST of Harmonic Series</div>
                        <canvas id="harmonic-vst"></canvas>
                        <div class="canvas-info">
                            <span class="highlight-indicator highlight-harmonics"></span>
                            Peaks correspond to fundamental and harmonics with logarithmic spacing
                        </div>
                    </div>

                    <div class="viz-container">
                        <div class="viz-title">Frequency Resolution vs Frequency</div>
                        <canvas id="resolution-curve"></canvas>
                        <div class="canvas-info">
                            Resolution Δf(f) increases proportionally to f^(1-α)
                        </div>
                    </div>

                    <div class="theory-panel">
                        <h4>Harmonic Signal Model</h4>
                        <p>A musical tone with fundamental f₀ and K harmonics:</p>
                        <div class="math-block">
                            $$x(t) = \sum_{k=1}^{K} A_k e^{-\alpha_k t} \cos(2\pi k f_0 t + \phi_k)$$
                        </div>
                        <p>Typically A_k ∝ 1/k and α_k ∝ k (higher harmonics decay faster). The harmonic frequencies follow:</p>
                        <div class="math-block">
                            $$f_k = k f_0, \quad k = 1, 2, 3, \ldots$$
                        </div>
                        <p>In the VST with logarithmic frequency axis, harmonics appear at equal visual spacing, simplifying pattern recognition.</p>
                    </div>
                </section>

                <!-- Section 7: Examples -->
                <section id="examples" class="section">
                    <h2>7. Musical Examples</h2>

                    <p>The following examples demonstrate the VST applied to realistic musical scenarios. Click any card to load the example configuration.</p>

                    <div class="examples-grid">
                        <div class="example-card" data-example="guitar-chord">
                            <h4>Guitar Power Chord</h4>
                            <p>E₂ + B₂ (perfect fifth)<br>82.4 Hz + 123.5 Hz<br>Common in rock music</p>
                        </div>

                        <div class="example-card" data-example="semitone">
                            <h4>Semitone Interval</h4>
                            <p>E₂ + F₂ (minor second)<br>82.4 Hz + 87.3 Hz<br>Smallest Western interval</p>
                        </div>

                        <div class="example-card" data-example="octave">
                            <h4>Octave</h4>
                            <p>A₂ + A₃<br>110 Hz + 220 Hz<br>Fundamental perceptual unit</p>
                        </div>

                        <div class="example-card" data-example="major-third">
                            <h4>Major Third</h4>
                            <p>C₃ + E₃<br>130.8 Hz + 164.8 Hz<br>Consonant interval</p>
                        </div>

                        <div class="example-card" data-example="tritone">
                            <h4>Tritone</h4>
                            <p>F₂ + B₂<br>87.3 Hz + 123.5 Hz<br>Maximum dissonance</p>
                        </div>

                        <div class="example-card" data-example="bass-notes">
                            <h4>Bass Notes</h4>
                            <p>E₁ + F₁<br>41.2 Hz + 43.7 Hz<br>Challenges FFT resolution</p>
                        </div>
                    </div>

                    <div class="info-box">
                        <strong>Interactive Exploration:</strong>
                        After loading an example, return to Section 2 to adjust frequencies and observe how the VST maintains resolution across different pitch ranges.
                    </div>
                </section>

                <!-- Section 8: Conclusion -->
                <section id="conclusion" class="section">
                    <h2>8. Conclusions and Future Directions</h2>

                    <h3>Summary of Key Results</h3>

                    <p>The Variable Scale Transform addresses fundamental limitations of uniform frequency resolution by introducing a scaling function λ(t) in the exponential kernel. Our interactive demonstration establishes:</p>

                    <ol style="margin: 15px 0 15px 40px;">
                        <li><strong>Improved low-frequency resolution:</strong> The VST provides 3-10× more bins between closely-spaced fundamentals in the musical bass range (60-200 Hz) compared to practical FFT implementations.</li>
                        
                        <li><strong>Computational efficiency:</strong> By accepting coarser resolution at high frequencies where harmonics are perceptually less distinct, the VST reduces computational burden while maintaining perceptual fidelity.</li>
                        
                        <li><strong>Natural harmonic representation:</strong> Logarithmic frequency spacing causes harmonics to appear at regular intervals in the transform domain, simplifying pattern recognition and note detection algorithms.</li>
                        
                        <li><strong>Flexible resolution control:</strong> The scaling exponent α provides continuous control over the frequency-resolution tradeoff, allowing optimization for specific instruments or perceptual criteria.</li>
                    </ol>

                    <h3>Relationship to Existing Methods</h3>

                    <p>The VST shares conceptual similarities with several established techniques:</p>

                    <div class="theory-panel">
                        <h4>Wavelet Transform</h4>
                        <p>Both achieve multi-resolution analysis, but through different mechanisms. Wavelets use dilated basis functions:</p>
                        <div class="math-block">
                            $$W(a,b) = \int x(t) \psi^*\left(\frac{t-b}{a}\right) dt$$
                        </div>
                        <p>VST achieves similar outcomes through time-axis warping within a single integral transform.</p>
                    </div>

                    <div class="theory-panel">
                        <h4>Constant-Q Transform</h4>
                        <p>The CQT achieves logarithmic frequency spacing through geometric arrangement of filter banks. The VST generalizes this concept through the scaling function, providing additional control via α and continuous rather than discrete frequency coverage.</p>
                    </div>

                    <h3>Open Questions and Extensions</h3>

                    <p>Several directions merit further investigation:</p>

                    <ul style="margin: 15px 0 15px 40px;">
                        <li><strong>Optimal scaling functions:</strong> Beyond power laws, what functional forms of λ(t) best match specific perceptual criteria or instrument characteristics?</li>
                        
                        <li><strong>Inverse transform:</strong> Develop efficient synthesis methods enabling signal reconstruction from VST coefficients for applications in audio effects and compression.</li>
                        
                        <li><strong>Adaptive resolution:</strong> Allow λ(t,ω) to depend on both time and frequency, providing instrument-specific or content-adaptive resolution allocation.</li>
                        
                        <li><strong>Real-time implementation:</strong> Optimize discrete VST computation for low-latency applications such as live performance analysis.</li>
                    </ul>

                    <h3>Software Implementation</h3>

                    <p>This interactive demonstration implements the discrete VST as:</p>

                    <div class="theory-panel">
                        <div class="math-block">
                            $$X_\lambda[m] = \sum_{n=0}^{N-1} z[n] \exp\left(-s_m \lambda[n]\right)$$
                        </div>
                        <p>where z[n] is the analytic signal, s_m = σ_m + jω_m are logarithmically-spaced complex frequencies, and λ[n] = (nT_s)^α. The computational complexity is O(MN) for M frequency bins and N samples, comparable to FFT when M ≈ N/log(N).</p>
                    </div>

                    <div class="info-box">
                        <strong>Code Availability:</strong>
                        The complete implementation is available in this self-contained HTML document. View source to examine the SignalProcessor and Visualizer classes implementing the VST algorithm.
                    </div>

                    <h3>Acknowledgments</h3>

                    <p>The Variable Scale Transform builds on fundamental work in time-frequency analysis, wavelet theory, and auditory perception. This interactive demonstration aims to make these concepts accessible for education and research in musical signal processing.</p>
                </section>
            </main>
        </div>
    </div>

    <script>
        // ============================================================================
        // PUB-SUB EVENT SYSTEM
        // ============================================================================
        class EventBus {
            constructor() {
                this.events = {};
            }

            subscribe(event, callback) {
                if (!this.events[event]) this.events[event] = [];
                this.events[event].push(callback);
                return () => this.unsubscribe(event, callback);
            }

            unsubscribe(event, callback) {
                if (!this.events[event]) return;
                this.events[event] = this.events[event].filter(cb => cb !== callback);
            }

            publish(event, data) {
                if (!this.events[event]) return;
                this.events[event].forEach(cb => cb(data));
            }
        }

        const eventBus = new EventBus();

        // ============================================================================
        // SIGNAL PROCESSOR
        // ============================================================================
        class SignalProcessor {
            constructor(sampleRate = 44100) {
                this.sampleRate = sampleRate;
            }

            generateTwoTone(f1, f2, decay, duration) {
                const numSamples = Math.floor(duration * this.sampleRate);
                const signal = new Float32Array(numSamples);
                const analytic = new Float32Array(numSamples * 2);

                for (let n = 0; n < numSamples; n++) {
                    const t = n / this.sampleRate;
                    const envelope = Math.exp(-decay * t);
                    
                    const real = envelope * (Math.cos(2 * Math.PI * f1 * t) + 
                                            Math.cos(2 * Math.PI * f2 * t));
                    const imag = envelope * (Math.sin(2 * Math.PI * f1 * t) + 
                                            Math.sin(2 * Math.PI * f2 * t));
                    
                    signal[n] = real;
                    analytic[n * 2] = real;
                    analytic[n * 2 + 1] = imag;
                }

                return { signal, analytic, numSamples };
            }

            generateHarmonic(f0, numHarmonics, decay, duration) {
                const numSamples = Math.floor(duration * this.sampleRate);
                const signal = new Float32Array(numSamples);
                const analytic = new Float32Array(numSamples * 2);

                for (let n = 0; n < numSamples; n++) {
                    const t = n / this.sampleRate;
                    let real = 0, imag = 0;

                    for (let k = 1; k <= numHarmonics; k++) {
                        const fk = k * f0;
                        const amp = 1.0 / k;
                        const envelope = Math.exp(-decay * k * 0.3 * t);
                        
                        real += amp * envelope * Math.cos(2 * Math.PI * fk * t);
                        imag += amp * envelope * Math.sin(2 * Math.PI * fk * t);
                    }

                    signal[n] = real;
                    analytic[n * 2] = real;
                    analytic[n * 2 + 1] = imag;
                }

                return { signal, analytic, numSamples };
            }

            computeVST(analytic, frequencies, alpha, qFactor) {
                const numSamples = analytic.length / 2;
                const spectrum = new Float32Array(frequencies.length);

                for (let m = 0; m < frequencies.length; m++) {
                    const omega = 2 * Math.PI * frequencies[m];
                    const sigma = omega / qFactor;

                    let sumReal = 0, sumImag = 0;

                    for (let n = 0; n < numSamples; n++) {
                        const t = n / this.sampleRate;
                        const lambda = Math.pow(t + 1e-10, alpha);
                        const expFactor = Math.exp(-sigma * lambda);
                        const phase = omega * lambda;

                        const cosPhase = Math.cos(phase);
                        const sinPhase = Math.sin(phase);

                        const re = analytic[n * 2];
                        const im = analytic[n * 2 + 1];

                        sumReal += expFactor * (re * cosPhase + im * sinPhase);
                        sumImag += expFactor * (im * cosPhase - re * sinPhase);
                    }

                    spectrum[m] = Math.sqrt(sumReal * sumReal + sumImag * sumImag);
                }

                return spectrum;
            }

            computeFFT(signal, fftSize) {
                const real = new Float32Array(fftSize);
                for (let i = 0; i < Math.min(signal.length, fftSize); i++) {
                    real[i] = signal[i];
                }

                const spectrum = new Float32Array(fftSize / 2);
                for (let k = 0; k < fftSize / 2; k++) {
                    let sumReal = 0, sumImag = 0;
                    for (let n = 0; n < fftSize; n++) {
                        const phase = -2 * Math.PI * k * n / fftSize;
                        sumReal += real[n] * Math.cos(phase);
                        sumImag += real[n] * Math.sin(phase);
                    }
                    spectrum[k] = Math.sqrt(sumReal * sumReal + sumImag * sumImag);
                }

                return spectrum;
            }

            generateLogFrequencies(fMin, fMax, binsPerOctave) {
                const frequencies = [];
                let f = fMin;
                while (f <= fMax) {
                    frequencies.push(f);
                    f *= Math.pow(2, 1 / binsPerOctave);
                }
                return frequencies;
            }
        }

        // ============================================================================
        // CANVAS VISUALIZER
        // ============================================================================
        class CanvasViz {
            constructor(canvasId) {
                this.canvas = document.getElementById(canvasId);
                if (!this.canvas) return;
                
                this.ctx = this.canvas.getContext('2d');
                this.resize();
                window.addEventListener('resize', () => this.resize());
            }

            resize() {
                const rect = this.canvas.getBoundingClientRect();
                this.canvas.width = rect.width * window.devicePixelRatio;
                this.canvas.height = rect.height * window.devicePixelRatio;
                this.ctx.scale(window.devicePixelRatio, window.devicePixelRatio);
                this.width = rect.width;
                this.height = rect.height;
            }

            clear() {
                this.ctx.clearRect(0, 0, this.width, this.height);
            }

            drawAxes(padding = 50) {
                this.ctx.strokeStyle = '#dee2e6';
                this.ctx.lineWidth = 1;
                this.ctx.beginPath();
                this.ctx.moveTo(padding, padding);
                this.ctx.lineTo(padding, this.height - padding);
                this.ctx.lineTo(this.width - padding, this.height - padding);
                this.ctx.stroke();
            }

            drawSignal(signal, color = '#0066cc') {
                this.clear();
                const padding = 50;
                this.drawAxes(padding);

                const len = signal.length;
                const xStep = (this.width - 2 * padding) / len;
                
                let yMin = Infinity, yMax = -Infinity;
                for (let i = 0; i < len; i++) {
                    if (signal[i] < yMin) yMin = signal[i];
                    if (signal[i] > yMax) yMax = signal[i];
                }
                
                const yRange = Math.max(Math.abs(yMin), Math.abs(yMax));
                const yScale = (this.height - 2 * padding) * 0.4 / yRange;
                const yCenter = this.height / 2;

                this.ctx.strokeStyle = color;
                this.ctx.lineWidth = 1.5;
                this.ctx.beginPath();

                for (let i = 0; i < len; i++) {
                    const x = padding + i * xStep;
                    const y = yCenter - signal[i] * yScale;
                    if (i === 0) this.ctx.moveTo(x, y);
                    else this.ctx.lineTo(x, y);
                }

                this.ctx.stroke();

                // Zero line
                this.ctx.strokeStyle = '#dee2e6';
                this.ctx.setLineDash([5, 5]);
                this.ctx.beginPath();
                this.ctx.moveTo(padding, yCenter);
                this.ctx.lineTo(this.width - padding, yCenter);
                this.ctx.stroke();
                this.ctx.setLineDash([]);

                // Labels
                this.ctx.fillStyle = '#6c757d';
                this.ctx.font = '11px Arial';
                this.ctx.textAlign = 'right';
                this.ctx.fillText(yRange.toFixed(2), padding - 5, padding + 5);
                this.ctx.fillText('0', padding - 5, yCenter + 4);
                this.ctx.fillText((-yRange).toFixed(2), padding - 5, this.height - padding + 5);
            }

            drawSpectrum(frequencies, spectrum, logX = true, color = '#0066cc', highlights = null) {
                this.clear();
                const padding = 50;
                this.drawAxes(padding);

                const len = spectrum.length;
                let yMax = 0;
                for (let i = 0; i < len; i++) {
                    if (spectrum[i] > yMax) yMax = spectrum[i];
                }

                const plotWidth = this.width - 2 * padding;
                const plotHeight = this.height - 2 * padding;

                if (logX) {
                    const logMin = Math.log10(frequencies[0]);
                    const logMax = Math.log10(frequencies[len - 1]);

                    // Fill under curve
                    this.ctx.fillStyle = 'rgba(0, 102, 204, 0.1)';
                    this.ctx.beginPath();
                    for (let i = 0; i < len; i++) {
                        const logF = Math.log10(frequencies[i]);
                        const x = padding + ((logF - logMin) / (logMax - logMin)) * plotWidth;
                        const y = this.height - padding - (spectrum[i] / yMax) * plotHeight;
                        if (i === 0) {
                            this.ctx.moveTo(x, this.height - padding);
                            this.ctx.lineTo(x, y);
                        } else {
                            this.ctx.lineTo(x, y);
                        }
                    }
                    this.ctx.lineTo(this.width - padding, this.height - padding);
                    this.ctx.closePath();
                    this.ctx.fill();

                    // Stroke
                    this.ctx.strokeStyle = color;
                    this.ctx.lineWidth = 2;
                    this.ctx.beginPath();
                    for (let i = 0; i < len; i++) {
                        const logF = Math.log10(frequencies[i]);
                        const x = padding + ((logF - logMin) / (logMax - logMin)) * plotWidth;
                        const y = this.height - padding - (spectrum[i] / yMax) * plotHeight;
                        if (i === 0) this.ctx.moveTo(x, y);
                        else this.ctx.lineTo(x, y);
                    }
                    this.ctx.stroke();

                    // Highlights
                    if (highlights) {
                        highlights.forEach(h => {
                            const logF = Math.log10(h.freq);
                            const x = padding + ((logF - logMin) / (logMax - logMin)) * plotWidth;
                            
                            this.ctx.strokeStyle = h.color;
                            this.ctx.lineWidth = 2;
                            this.ctx.setLineDash([5, 5]);
                            this.ctx.beginPath();
                            this.ctx.moveTo(x, padding);
                            this.ctx.lineTo(x, this.height - padding);
                            this.ctx.stroke();
                            this.ctx.setLineDash([]);

                            this.ctx.fillStyle = h.color;
                            this.ctx.font = '11px Arial';
                            this.ctx.fillText(h.label, x + 3, padding + 15);
                        });
                    }

                    // Frequency labels
                    this.ctx.fillStyle = '#6c757d';
                    this.ctx.font = '11px Arial';
                    this.ctx.textAlign = 'center';
                    [50, 100, 200, 500, 1000, 2000, 5000].forEach(f => {
                        if (f >= frequencies[0] && f <= frequencies[len - 1]) {
                            const logF = Math.log10(f);
                            const x = padding + ((logF - logMin) / (logMax - logMin)) * plotWidth;
                            this.ctx.fillText(f >= 1000 ? `${f/1000}k` : f, x, this.height - padding + 20);
                        }
                    });
                } else {
                    // Linear scale
                    const fMax = frequencies[len - 1];
                    
                    this.ctx.fillStyle = 'rgba(220, 53, 69, 0.1)';
                    this.ctx.beginPath();
                    for (let i = 0; i < len; i++) {
                        const x = padding + (frequencies[i] / fMax) * plotWidth;
                        const y = this.height - padding - (spectrum[i] / yMax) * plotHeight;
                        if (i === 0) {
                            this.ctx.moveTo(x, this.height - padding);
                            this.ctx.lineTo(x, y);
                        } else {
                            this.ctx.lineTo(x, y);
                        }
                    }
                    this.ctx.lineTo(this.width - padding, this.height - padding);
                    this.ctx.closePath();
                    this.ctx.fill();

                    this.ctx.strokeStyle = '#dc3545';
                    this.ctx.lineWidth = 2;
                    this.ctx.beginPath();
                    for (let i = 0; i < len; i++) {
                        const x = padding + (frequencies[i] / fMax) * plotWidth;
                        const y = this.height - padding - (spectrum[i] / yMax) * plotHeight;
                        if (i === 0) this.ctx.moveTo(x, y);
                        else this.ctx.lineTo(x, y);
                    }
                    this.ctx.stroke();

                    // Highlights
                    if (highlights) {
                        highlights.forEach(h => {
                            const x = padding + (h.freq / fMax) * plotWidth;
                            
                            this.ctx.strokeStyle = h.color;
                            this.ctx.lineWidth = 2;
                            this.ctx.setLineDash([5, 5]);
                            this.ctx.beginPath();
                            this.ctx.moveTo(x, padding);
                            this.ctx.lineTo(x, this.height - padding);
                            this.ctx.stroke();
                            this.ctx.setLineDash([]);

                            this.ctx.fillStyle = h.color;
                            this.ctx.font = '11px Arial';
                            this.ctx.fillText(h.label, x + 3, padding + 15);
                        });
                    }
                }

                this.ctx.fillStyle = '#6c757d';
                this.ctx.font = '11px Arial';
                this.ctx.textAlign = 'center';
                this.ctx.fillText('Frequency (Hz)', this.width / 2, this.height - 10);
            }

            drawFunction(xData, yData, color = '#0066cc', lineWidth = 2) {
                this.clear();
                const padding = 50;
                this.drawAxes(padding);

                const len = xData.length;
                let xMin = Infinity, xMax = -Infinity;
                let yMin = Infinity, yMax = -Infinity;

                for (let i = 0; i < len; i++) {
                    if (xData[i] < xMin) xMin = xData[i];
                    if (xData[i] > xMax) xMax = xData[i];
                    if (yData[i] < yMin) yMin = yData[i];
                    if (yData[i] > yMax) yMax = yData[i];
                }

                const xRange = xMax - xMin;
                const yRange = yMax - yMin;
                const plotWidth = this.width - 2 * padding;
                const plotHeight = this.height - 2 * padding;

                this.ctx.strokeStyle = color;
                this.ctx.lineWidth = lineWidth;
                this.ctx.beginPath();

                for (let i = 0; i < len; i++) {
                    const x = padding + ((xData[i] - xMin) / xRange) * plotWidth;
                    const y = this.height - padding - ((yData[i] - yMin) / yRange) * plotHeight;
                    if (i === 0) this.ctx.moveTo(x, y);
                    else this.ctx.lineTo(x, y);
                }

                this.ctx.stroke();

                // Labels
                this.ctx.fillStyle = '#6c757d';
                this.ctx.font = '11px Arial';
                this.ctx.textAlign = 'center';
                this.ctx.fillText(xMin.toFixed(2), padding, this.height - padding + 20);
                this.ctx.fillText(xMax.toFixed(2), this.width - padding, this.height - padding + 20);
                
                this.ctx.textAlign = 'right';
                this.ctx.fillText(yMax.toFixed(2), padding - 5, padding + 5);
                this.ctx.fillText(yMin.toFixed(2), padding - 5, this.height - padding + 5);
            }
        }

        // ============================================================================
        // APPLICATION STATE
        // ============================================================================
        const state = {
            f1: 82.4,
            f2: 87.3,
            alpha: 0.75,
            qFactor: 15,
            binsPerOctave: 36,
            decay: 2.5,
            duration: 2.0,
            fftSize: 4096,
            currentSignal: null,
            currentAnalytic: null,
            harmF0: 110,
            numHarmonics: 8,
            harmDecay: 3.0
        };

        // ============================================================================
        // INITIALIZE
        // ============================================================================
        const processor = new SignalProcessor();
        const vizzes = {
            twoTone: new CanvasViz('two-tone-signal'),
            fft: new CanvasViz('fft-spectrum'),
            vst: new CanvasViz('vst-spectrum'),
            scalingFunc: new CanvasViz('scaling-function'),
            scalingDeriv: new CanvasViz('scaling-derivative'),
            harmonicVst: new CanvasViz('harmonic-vst'),
            resolutionCurve: new CanvasViz('resolution-curve')
        };

        // ============================================================================
        // NAVIGATION
        // ============================================================================
        document.querySelectorAll('.nav-link').forEach(link => {
            link.addEventListener('click', (e) => {
                e.preventDefault();
                const section = link.dataset.section;
                
                document.querySelectorAll('.nav-link').forEach(l => l.classList.remove('active'));
                link.classList.add('active');
                
                document.querySelectorAll('.section').forEach(s => s.classList.remove('active'));
                document.getElementById(section).classList.add('active');
                
                window.scrollTo({ top: 0, behavior: 'smooth' });
            });
        });

        // ============================================================================
        // CONTROLS
        // ============================================================================
        function setupSlider(sliderId, valueId, callback) {
            const slider = document.getElementById(sliderId);
            const display = document.getElementById(valueId);
            slider.addEventListener('input', (e) => {
                const val = parseFloat(e.target.value);
                const decimals = slider.step.includes('.') ? slider.step.split('.')[1].length : 0;
                display.textContent = val.toFixed(decimals);
                callback(val);
            });
        }

        setupSlider('f1-slider', 'f1-value', (v) => {
            state.f1 = v;
            updateTwoTone();
        });

        setupSlider('f2-slider', 'f2-value', (v) => {
            state.f2 = v;
            updateTwoTone();
        });

        setupSlider('alpha-slider', 'alpha-value', (v) => {
            state.alpha = v;
            eventBus.publish('alpha-changed', v);
        });

        setupSlider('q-slider', 'q-value', (v) => {
            state.qFactor = v;
        });

        setupSlider('bins-slider', 'bins-value', (v) => {
            state.binsPerOctave = v;
        });

        setupSlider('harm-f0-slider', 'harm-f0-value', (v) => {
            state.harmF0 = v;
        });

        setupSlider('num-harmonics-slider', 'num-harmonics-value', (v) => {
            state.numHarmonics = v;
        });

        setupSlider('harm-decay-slider', 'harm-decay-value', (v) => {
            state.harmDecay = v;
        });

        function updateTwoTone() {
            const sep = Math.abs(state.f2 - state.f1);
            const ratio = Math.max(state.f1, state.f2) / Math.min(state.f1, state.f2);
            
            document.getElementById('separation-value').textContent = sep.toFixed(1) + ' Hz';
            document.getElementById('ratio-value').textContent = ratio.toFixed(3);

            const result = processor.generateTwoTone(state.f1, state.f2, state.decay, state.duration);
            state.currentSignal = result.signal;
            state.currentAnalytic = result.analytic;
            
            vizzes.twoTone.drawSignal(result.signal);
            
            eventBus.publish('signal-updated', result);
        }

        // ============================================================================
        // COMPUTE TRANSFORMS
        // ============================================================================
        let useLogScale = true;

        document.getElementById('compute-transforms').addEventListener('click', () => {
            if (!state.currentSignal) updateTwoTone();

            // FFT
            const fftSpec = processor.computeFFT(state.currentSignal, state.fftSize);
            const fftFreqs = new Float32Array(state.fftSize / 2);
            for (let i = 0; i < state.fftSize / 2; i++) {
                fftFreqs[i] = (i * 44100) / state.fftSize;
            }

            const highlights = [
                { freq: state.f1, color: '#dc3545', label: `f₁=${state.f1.toFixed(1)}` },
                { freq: state.f2, color: '#007bff', label: `f₂=${state.f2.toFixed(1)}` }
            ];

            vizzes.fft.drawSpectrum(fftFreqs, fftSpec, false, '#dc3545', highlights);

            const fftRes = 44100 / state.fftSize;
            document.getElementById('fft-info').textContent = 
                `FFT Size: ${state.fftSize}, Resolution: ${fftRes.toFixed(2)} Hz`;

            // VST
            const vstFreqs = processor.generateLogFrequencies(40, 500, state.binsPerOctave);
            const vstSpec = processor.computeVST(state.currentAnalytic, vstFreqs, state.alpha, state.qFactor);

            vizzes.vst.drawSpectrum(vstFreqs, vstSpec, true, '#0066cc', highlights);

            document.getElementById('vst-info').textContent = 
                `Bins per octave: ${state.binsPerOctave}, α: ${state.alpha}`;

            // Metrics
            const sep = Math.abs(state.f2 - state.f1);
            const fftBins = sep / fftRes;
            const vstBins = vstFreqs.filter(f => 
                f >= Math.min(state.f1, state.f2) && f <= Math.max(state.f1, state.f2)
            ).length;

            document.getElementById('fft-bins').textContent = fftBins.toFixed(1);
            document.getElementById('vst-bins').textContent = vstBins;
            document.getElementById('bins-improvement').textContent = `${(vstBins / fftBins).toFixed(1)}×`;

            const vstResF1 = state.f1 / state.binsPerOctave * Math.log(2);
            document.getElementById('fft-res-f1').textContent = fftRes.toFixed(2) + ' Hz';
            document.getElementById('vst-res-f1').textContent = vstResF1.toFixed(2) + ' Hz';
            document.getElementById('res-f1-improvement').textContent = 
                `${(fftRes / vstResF1).toFixed(1)}×`;

            // Peak separation (in standard deviations)
            const fftSep = sep / fftRes;
            const vstSep = sep / vstResF1;
            document.getElementById('fft-separation').textContent = fftSep.toFixed(1) + ' σ';
            document.getElementById('vst-separation').textContent = vstSep.toFixed(1) + ' σ';
            document.getElementById('separation-improvement').textContent = 
                `${(vstSep / fftSep).toFixed(1)}×`;
        });

        document.getElementById('toggle-log-scale').addEventListener('click', () => {
            useLogScale = !useLogScale;
            document.getElementById('compute-transforms').click();
        });

        // ============================================================================
        // SCALING FUNCTIONS
        // ============================================================================
        function updateScalingViz() {
            const tData = [];
            const lambdaData = {
                '0.5': [], '0.75': [], '1.0': []
            };
            const derivData = {
                '0.5': [], '0.75': [], '1.0': []
            };

            for (let i = 0; i <= 200; i++) {
                const t = (i / 200) * 2.0;
                tData.push(t);
                
                [0.5, 0.75, 1.0].forEach(alpha => {
                    lambdaData[alpha.toFixed(2)].push(Math.pow(t + 0.001, alpha));
                    derivData[alpha.toFixed(2)].push(alpha * Math.pow(t + 0.001, alpha - 1));
                });
            }

            // Draw all three scaling functions
            vizzes.scalingFunc.clear();
            vizzes.scalingFunc.drawAxes(50);
            
            const colors = { '0.50': '#dc3545', '0.75': '#0066cc', '1.00': '#28a745' };
            Object.keys(lambdaData).forEach(alpha => {
                vizzes.scalingFunc.ctx.strokeStyle = colors[alpha];
                vizzes.scalingFunc.ctx.lineWidth = 2;
                vizzes.scalingFunc.ctx.beginPath();
                
                const padding = 50;
                const plotWidth = vizzes.scalingFunc.width - 2 * padding;
                const plotHeight = vizzes.scalingFunc.height - 2 * padding;
                
                const yMax = Math.max(...lambdaData[alpha]);
                
                for (let i = 0; i < tData.length; i++) {
                    const x = padding + (tData[i] / 2.0) * plotWidth;
                    const y = vizzes.scalingFunc.height - padding - (lambdaData[alpha][i] / yMax) * plotHeight;
                    if (i === 0) vizzes.scalingFunc.ctx.moveTo(x, y);
                    else vizzes.scalingFunc.ctx.lineTo(x, y);
                }
                
                vizzes.scalingFunc.ctx.stroke();
            });

            // Legend
            let legendY = 20;
            Object.keys(colors).forEach(alpha => {
                vizzes.scalingFunc.ctx.fillStyle = colors[alpha];
                vizzes.scalingFunc.ctx.fillRect(60, legendY, 20, 3);
                vizzes.scalingFunc.ctx.font = '11px Arial';
                vizzes.scalingFunc.ctx.fillText(`α=${alpha}`, 85, legendY + 4);
                legendY += 20;
            });

            // Derivatives
            vizzes.scalingDeriv.clear();
            vizzes.scalingDeriv.drawAxes(50);
            
            Object.keys(derivData).forEach(alpha => {
                vizzes.scalingDeriv.ctx.strokeStyle = colors[alpha];
                vizzes.scalingDeriv.ctx.lineWidth = 2;
                vizzes.scalingDeriv.ctx.beginPath();
                
                const padding = 50;
                const plotWidth = vizzes.scalingDeriv.width - 2 * padding;
                const plotHeight = vizzes.scalingDeriv.height - 2 * padding;
                
                const yMax = Math.max(...derivData[alpha].filter(v => !isNaN(v) && isFinite(v)));
                
                for (let i = 0; i < tData.length; i++) {
                    if (!isFinite(derivData[alpha][i])) continue;
                    const x = padding + (tData[i] / 2.0) * plotWidth;
                    const y = vizzes.scalingDeriv.height - padding - (derivData[alpha][i] / yMax) * plotHeight;
                    if (i === 0) vizzes.scalingDeriv.ctx.moveTo(x, y);
                    else vizzes.scalingDeriv.ctx.lineTo(x, y);
                }
                
                vizzes.scalingDeriv.ctx.stroke();
            });
        }

        // ============================================================================
        // HARMONICS
        // ============================================================================
        document.getElementById('compute-harmonics').addEventListener('click', () => {
            const result = processor.generateHarmonic(
                state.harmF0, 
                state.numHarmonics, 
                state.harmDecay, 
                state.duration
            );

            const vstFreqs = processor.generateLogFrequencies(40, 5000, state.binsPerOctave);
            const vstSpec = processor.computeVST(result.analytic, vstFreqs, state.alpha, state.qFactor);

            const highlights = [];
            for (let k = 1; k <= state.numHarmonics; k++) {
                highlights.push({
                    freq: k * state.harmF0,
                    color: k === 1 ? '#dc3545' : '#28a745',
                    label: k === 1 ? `f₀` : `${k}f₀`
                });
            }

            vizzes.harmonicVst.drawSpectrum(vstFreqs, vstSpec, true, '#0066cc', highlights);

            // Resolution curve
            const resFreqs = [];
            const resValues = [];
            for (let i = 0; i < 100; i++) {
                const f = 40 * Math.pow(5000 / 40, i / 99);
                resFreqs.push(f);
                resValues.push(f * Math.pow(f / 100, 1 - state.alpha) * 0.01);
            }
            
            vizzes.resolutionCurve.drawFunction(resFreqs, resValues, '#0066cc', 2);
        });

        // ============================================================================
        // EXAMPLES
        // ============================================================================
        const examples = {
            'guitar-chord': { f1: 82.4, f2: 123.5 },
            'semitone': { f1: 82.4, f2: 87.3 },
            'octave': { f1: 110, f2: 220 },
            'major-third': { f1: 130.8, f2: 164.8 },
            'tritone': { f1: 87.3, f2: 123.5 },
            'bass-notes': { f1: 41.2, f2: 43.7 }
        };

        document.querySelectorAll('.example-card').forEach(card => {
            card.addEventListener('click', () => {
                const example = card.dataset.example;
                const config = examples[example];
                
                state.f1 = config.f1;
                state.f2 = config.f2;
                
                document.getElementById('f1-slider').value = config.f1;
                document.getElementById('f2-slider').value = config.f2;
                document.getElementById('f1-value').textContent = config.f1.toFixed(1);
                document.getElementById('f2-value').textContent = config.f2.toFixed(1);
                
                updateTwoTone();
                
                // Navigate to two-tone section
                document.querySelector('[data-section="two-tone"]').click();
            });
        });

        // ============================================================================
        // INITIAL RENDER
        // ============================================================================
        updateTwoTone();
        updateScalingViz();

        // Trigger MathJax rendering
        if (window.MathJax) {
            MathJax.typesetPromise();
        }

        console.log('VST Academic Demo Initialized');
    </script>
</body>
</html>