<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Toy Diffusion Pixel SPA</title>
  <style>
    :root {
      --bg: #0b0f14;
      --fg: #d7dde6;
      --muted: #8a93a3;
      --panel: #101823;
      --border: #1f2a3a;
      --accent: #7aa2f7;
      --danger: #f7768e;
    }
    html, body { height: 100%; }
    body {
      margin: 0;
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;
      background: var(--bg);
      color: var(--fg);
      display: grid;
      grid-template-rows: auto 1fr;
    }
    header {
      border-bottom: 1px solid var(--border);
      background: linear-gradient(180deg, #0b0f14, #0b0f14cc);
      padding: 10px 12px;
      display: grid;
      gap: 10px;
    }
    .row {
      display: grid;
      grid-template-columns: 1fr;
      gap: 10px;
    }
    @media (min-width: 980px) {
      header { grid-template-columns: 1.2fr 1fr; align-items: start; }
      .row { grid-template-columns: 1fr 1fr 1fr 1fr; }
      .row.row2 { grid-template-columns: 2fr 1fr 1fr 1fr; }
    }
    .card {
      background: var(--panel);
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 10px;
    }
    label {
      display: grid;
      gap: 6px;
      font-size: 12px;
      color: var(--muted);
    }
    input[type="text"], input[type="number"], input[type="range"], select {
      background: #0c121c;
      color: var(--fg);
      border: 1px solid var(--border);
      border-radius: 10px;
      padding: 8px 10px;
      outline: none;
    }
    input[type="range"] { padding: 0; height: 26px; }
    .btnbar { display: flex; flex-wrap: wrap; gap: 8px; }
    button {
      background: #0c121c;
      color: var(--fg);
      border: 1px solid var(--border);
      border-radius: 10px;
      padding: 8px 10px;
      cursor: pointer;
    }
    button.primary { border-color: #2a3b58; box-shadow: 0 0 0 1px #1c2b45 inset; }
    button.primary:hover { border-color: #35507b; }
    button.danger { border-color: #5a2230; }
    button:disabled { opacity: 0.55; cursor: default; }
    main {
      display: grid;
      place-items: center;
      padding: 16px;
    }
    .stage {
      display: grid;
      gap: 12px;
      justify-items: center;
    }
    canvas {
      border-radius: 12px;
      border: 1px solid var(--border);
      background: #000;
      image-rendering: pixelated;
      image-rendering: crisp-edges;
    }
    .meta {
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      color: var(--muted);
      font-size: 12px;
      display: flex;
      gap: 14px;
      flex-wrap: wrap;
      justify-content: center;
    }
    .pill { padding: 2px 8px; border: 1px solid var(--border); border-radius: 999px; background: #0c121c; }
    .checkline { display: flex; gap: 10px; align-items: center; color: var(--muted); font-size: 12px; }
    .checkline input { transform: translateY(1px); }
  </style>
</head>
<body>
  <header>
    <div class="card">
      <div class="row row2">
        <label>
          Prompt (keywords: sky grass water sand sun moon mountain cloud tree)
          <input id="prompt" type="text" value="sky grass sun cloud" />
        </label>
        <label>
          Seed
          <input id="seed" type="number" min="0" step="1" value="1" />
        </label>
        <label>
          Steps T
          <input id="steps" type="number" min="8" max="256" step="1" value="64" />
        </label>
        <label>
          Guidance s
          <input id="guidance" type="range" min="0" max="8" step="0.1" value="4.0" />
        </label>
      </div>
      <div class="checkline" style="margin-top:10px;">
        <label style="display:flex;align-items:center;gap:8px;">
          <input id="showSnap" type="checkbox" checked />
          Render palette-snapped
        </label>
        <label style="display:flex;align-items:center;gap:8px;">
          <input id="showEps" type="checkbox" />
          Render |eps| heat (debug)
        </label>
      </div>
      <div class="btnbar" style="margin-top:10px;">
        <button class="primary" id="init">Init x_T</button>
        <button class="primary" id="stepBtn">Step</button>
        <button class="primary" id="runBtn">Run</button>
        <button class="danger" id="stopBtn" disabled>Stop</button>
        <button id="resetBtn">Reset</button>
      </div>
    </div>

    <div class="card">
      <div style="font-size:12px;color:var(--muted);line-height:1.4;">
        <div style="color:var(--fg);margin-bottom:6px;">Toy diffusion sampler</div>
        <div>State: x_t ∈ [-1,1]^{H×W×3}. Forward: x_t = sqrt(abar_t)x0 + sqrt(1-abar_t)ε.</div>
        <div>Reverse uses DDPM update with a hand-coded ε̂(x_t,t,c) = w_blur(x - blur(x)) + w_pal(x - snap(x)) + w_cond(x - m_c).</div>
        <div>Classifier-free guidance: ε̂ = ε̂_u + s(ε̂_c - ε̂_u).</div>
        <div style="margin-top:8px;color:var(--muted);">
          This is a simulator: no learned model, just priors (blur + palette) and a prompt-conditioned target field m_c.
        </div>
      </div>
    </div>
  </header>

  <main>
    <div class="stage">
      <canvas id="cv"></canvas>
      <div class="meta" id="meta"></div>
    </div>
  </main>

<script>
(() => {
  "use strict";

  // ---------------------------
  // Config
  // ---------------------------
  const W = 64, H = 64, C = 3;
  const N = W * H;
  const SCALE = 8;

  // 16-color palette (RGB in [0,255]) -> mapped to [-1,1] for computation.
  const PAL8 = [
    [  0,  0,  0], [255,255,255], [ 29, 43, 83], [126, 37, 83],
    [  0,135, 81], [171, 82, 54], [ 95, 87, 79], [194,195,199],
    [255,241,232], [255,  0, 77], [255,163,  0], [255,236, 39],
    [  0,228, 54], [ 41,173,255], [131,118,156], [255,119,168],
  ];
  const PALETTE = PAL8.map(([r,g,b]) => [
    (r/127.5 - 1), (g/127.5 - 1), (b/127.5 - 1)
  ]);

  // ---------------------------
  // DOM
  // ---------------------------
  const cv = document.getElementById("cv");
  const ctx = cv.getContext("2d", { alpha: false });
  cv.width = W; cv.height = H;
  cv.style.width = (W * SCALE) + "px";
  cv.style.height = (H * SCALE) + "px";

  const elPrompt = document.getElementById("prompt");
  const elSeed = document.getElementById("seed");
  const elSteps = document.getElementById("steps");
  const elGuidance = document.getElementById("guidance");
  const elShowSnap = document.getElementById("showSnap");
  const elShowEps = document.getElementById("showEps");
  const elMeta = document.getElementById("meta");

  const btnInit = document.getElementById("init");
  const btnStep = document.getElementById("stepBtn");
  const btnRun  = document.getElementById("runBtn");
  const btnStop = document.getElementById("stopBtn");
  const btnReset= document.getElementById("resetBtn");

  // ---------------------------
  // RNG (deterministic)
  // ---------------------------
  function mulberry32(seed) {
    let a = seed >>> 0;
    return () => {
      a |= 0; a = (a + 0x6D2B79F5) | 0;
      let t = Math.imul(a ^ (a >>> 15), 1 | a);
      t ^= t + Math.imul(t ^ (t >>> 7), 61 | t);
      return ((t ^ (t >>> 14)) >>> 0) / 4294967296;
    };
  }
  function randn(rng) {
    // Box-Muller
    let u = 0, v = 0;
    while (u === 0) u = rng();
    while (v === 0) v = rng();
    return Math.sqrt(-2 * Math.log(u)) * Math.cos(2 * Math.PI * v);
  }

  // ---------------------------
  // Diffusion schedule
  // ---------------------------
  function buildSchedule(T, beta0, beta1) {
    const betas = new Float32Array(T + 1);      // 1..T
    const alpha = new Float32Array(T + 1);
    const abar  = new Float32Array(T + 1);
    const sqrtAbar = new Float32Array(T + 1);
    const sqrtOneMinusAbar = new Float32Array(T + 1);
    const invSqrtAlpha = new Float32Array(T + 1);
    const coefEps = new Float32Array(T + 1);
    const sigma = new Float32Array(T + 1);

    abar[0] = 1.0;
    for (let t = 1; t <= T; t++) {
      const u = (t - 1) / (T - 1);
      const b = beta0 + (beta1 - beta0) * u;
      betas[t] = b;
      alpha[t] = 1 - b;
      abar[t] = abar[t - 1] * alpha[t];

      sqrtAbar[t] = Math.sqrt(abar[t]);
      sqrtOneMinusAbar[t] = Math.sqrt(1 - abar[t]);
      invSqrtAlpha[t] = 1 / Math.sqrt(alpha[t]);
      coefEps[t] = b / Math.sqrt(1 - abar[t]);
      sigma[t] = (t === 1) ? 0 : Math.sqrt(b);
    }

    return { T, betas, alpha, abar, sqrtAbar, sqrtOneMinusAbar, invSqrtAlpha, coefEps, sigma };
  }

  // ---------------------------
  // Operators: blur, palette snap, conditioning field
  // ---------------------------
  function clamp1(x) { return x < -1 ? -1 : (x > 1 ? 1 : x); }

  function boxBlur3x3(out, x) {
    // Separable 3-tap box blur with edge clamping.
    // out size = 3N, x size = 3N
    const tmp = new Float32Array(3 * N);

    // Horizontal
    for (let y = 0; y < H; y++) {
      const row = y * W;
      for (let x0 = 0; x0 < W; x0++) {
        const xm1 = (x0 === 0) ? 0 : -1;
        const xp1 = (x0 === W - 1) ? 0 : 1;
        const i0 = (row + x0) * 3;
        const i1 = (row + x0 + xm1) * 3;
        const i2 = (row + x0 + xp1) * 3;
        tmp[i0+0] = (x[i1+0] + x[i0+0] + x[i2+0]) / 3;
        tmp[i0+1] = (x[i1+1] + x[i0+1] + x[i2+1]) / 3;
        tmp[i0+2] = (x[i1+2] + x[i0+2] + x[i2+2]) / 3;
      }
    }

    // Vertical
    for (let y = 0; y < H; y++) {
      const ym1 = (y === 0) ? 0 : -1;
      const yp1 = (y === H - 1) ? 0 : 1;
      for (let x0 = 0; x0 < W; x0++) {
        const i0 = (y * W + x0) * 3;
        const i1 = ((y + ym1) * W + x0) * 3;
        const i2 = ((y + yp1) * W + x0) * 3;
        out[i0+0] = (tmp[i1+0] + tmp[i0+0] + tmp[i2+0]) / 3;
        out[i0+1] = (tmp[i1+1] + tmp[i0+1] + tmp[i2+1]) / 3;
        out[i0+2] = (tmp[i1+2] + tmp[i0+2] + tmp[i2+2]) / 3;
      }
    }
  }

  function nearestPaletteRGB(v0, v1, v2) {
    let best = 0;
    let bestD = Infinity;
    for (let k = 0; k < PALETTE.length; k++) {
      const p = PALETTE[k];
      const d0 = v0 - p[0], d1 = v1 - p[1], d2 = v2 - p[2];
      const d = d0*d0 + d1*d1 + d2*d2;
      if (d < bestD) { bestD = d; best = k; }
    }
    return PALETTE[best];
  }

  function buildTargetField(prompt, seed) {
    // Prompt -> per-pixel target field m_c (3N floats in [-1,1]).
    // Rules are intentionally simple: vertical bands + a few parametric masks.
    const m = new Float32Array(3 * N);
    const tokens = new Set(prompt.toLowerCase().split(/[^a-z0-9]+/g).filter(Boolean));
    const rng = mulberry32((seed ^ 0x9E3779B9) >>> 0);

    // Helper: write a palette color with strength into m (overwrite; this is a toy).
    function fillBand(y0, y1, palIdx) {
      const p = PALETTE[palIdx];
      const ya = Math.max(0, Math.min(H, y0));
      const yb = Math.max(0, Math.min(H, y1));
      for (let y = ya; y < yb; y++) {
        for (let x = 0; x < W; x++) {
          const i = (y * W + x) * 3;
          m[i+0] = p[0]; m[i+1] = p[1]; m[i+2] = p[2];
        }
      }
    }

    // Default background if no tokens: muted blue-gray.
    fillBand(0, H, 2);

    if (tokens.has("sky"))   fillBand(0, Math.floor(H*0.55), 13); // light blue
    if (tokens.has("water")) fillBand(Math.floor(H*0.55), Math.floor(H*0.8), 14); // purple-gray
    if (tokens.has("grass")) fillBand(Math.floor(H*0.6), H, 12); // green
    if (tokens.has("sand"))  fillBand(Math.floor(H*0.7), H, 11); // yellow

    if (tokens.has("mountain")) {
      const p = PALETTE[6]; // dark gray
      const baseY = Math.floor(H * (0.62 + 0.08*rng()));
      const peakX = Math.floor(W * (0.25 + 0.5*rng()));
      const peakY = Math.floor(H * (0.25 + 0.15*rng()));
      for (let y = peakY; y < baseY; y++) {
        const t = (y - peakY) / Math.max(1, (baseY - peakY));
        const half = Math.floor((t * W * 0.35) + 1);
        for (let x = Math.max(0, peakX - half); x < Math.min(W, peakX + half); x++) {
          const i = (y * W + x) * 3;
          m[i+0] = p[0]; m[i+1] = p[1]; m[i+2] = p[2];
        }
      }
    }

    if (tokens.has("cloud")) {
      const p = PALETTE[1]; // white
      const cCount = 2 + Math.floor(rng() * 4);
      for (let c = 0; c < cCount; c++) {
        const cx = Math.floor(rng() * W);
        const cy = Math.floor(rng() * Math.floor(H * 0.45));
        const rx = 6 + Math.floor(rng() * 10);
        const ry = 3 + Math.floor(rng() * 6);
        for (let y = Math.max(0, cy - ry); y < Math.min(H, cy + ry); y++) {
          for (let x = Math.max(0, cx - rx); x < Math.min(W, cx + rx); x++) {
            const dx = (x - cx) / rx, dy = (y - cy) / ry;
            if (dx*dx + dy*dy <= 1.0) {
              const i = (y * W + x) * 3;
              m[i+0] = p[0]; m[i+1] = p[1]; m[i+2] = p[2];
            }
          }
        }
      }
    }

    if (tokens.has("sun") || tokens.has("moon")) {
      const p = tokens.has("moon") ? PALETTE[9] : PALETTE[11]; // red for moon (toy), yellow for sun
      const cx = Math.floor(W * (0.15 + 0.7*rng()));
      const cy = Math.floor(H * (0.1 + 0.25*rng()));
      const r = 4 + Math.floor(rng() * 6);
      for (let y = Math.max(0, cy - r); y < Math.min(H, cy + r); y++) {
        for (let x = Math.max(0, cx - r); x < Math.min(W, cx + r); x++) {
          const dx = x - cx, dy = y - cy;
          if (dx*dx + dy*dy <= r*r) {
            const i = (y * W + x) * 3;
            m[i+0] = p[0]; m[i+1] = p[1]; m[i+2] = p[2];
          }
        }
      }
    }

    if (tokens.has("tree")) {
      const trunk = PALETTE[5]; // brown
      const leaf  = PALETTE[4]; // dark green
      const tx = Math.floor(W * (0.2 + 0.6*rng()));
      const baseY = Math.floor(H * 0.85);
      const h = 10 + Math.floor(rng() * 10);
      // trunk
      for (let y = baseY - h; y < baseY; y++) {
        for (let x = tx - 1; x <= tx + 1; x++) {
          if (x < 0 || x >= W || y < 0 || y >= H) continue;
          const i = (y * W + x) * 3;
          m[i+0] = trunk[0]; m[i+1] = trunk[1]; m[i+2] = trunk[2];
        }
      }
      // canopy
      const cy = baseY - h;
      const r = 6 + Math.floor(rng() * 6);
      for (let y = Math.max(0, cy - r); y < Math.min(H, cy + r); y++) {
        for (let x = Math.max(0, tx - r); x < Math.min(W, tx + r); x++) {
          const dx = x - tx, dy = y - cy;
          if (dx*dx + dy*dy <= r*r) {
            const i = (y * W + x) * 3;
            m[i+0] = leaf[0]; m[i+1] = leaf[1]; m[i+2] = leaf[2];
          }
        }
      }
    }

    return m;
  }

  // ---------------------------
  // Toy ε-predictor
  // ---------------------------
  const tmpBlur = new Float32Array(3 * N);
  const epsU = new Float32Array(3 * N);
  const epsC = new Float32Array(3 * N);
  const epsG = new Float32Array(3 * N);

  function predictEps(out, x, t, T, condFieldOrNull) {
    // out := w_blur*(x - blur(x)) + w_pal*(x - snap(x)) + w_cond*(x - m)
    boxBlur3x3(tmpBlur, x);

    const tau = t / T;               // tau in (0,1]
    const w_blur = 0.65;
    const w_cond = tau * tau;        // early (high t) strong conditioning
    const w_pal  = (1 - tau);        // late (low t) strong palette snapping

    for (let i = 0; i < 3 * N; i += 3) {
      const x0 = x[i+0], x1 = x[i+1], x2 = x[i+2];

      // blur residual
      const eB0 = x0 - tmpBlur[i+0];
      const eB1 = x1 - tmpBlur[i+1];
      const eB2 = x2 - tmpBlur[i+2];

      // palette residual (nearest palette color)
      const p = nearestPaletteRGB(x0, x1, x2);
      const eP0 = x0 - p[0];
      const eP1 = x1 - p[1];
      const eP2 = x2 - p[2];

      // conditional field residual
      let eC0 = x0, eC1 = x1, eC2 = x2;
      if (condFieldOrNull) {
        eC0 = x0 - condFieldOrNull[i+0];
        eC1 = x1 - condFieldOrNull[i+1];
        eC2 = x2 - condFieldOrNull[i+2];
      } else {
        // unconditional target is zero field => eC = x
      }

      out[i+0] = w_blur * eB0 + w_pal * eP0 + w_cond * eC0;
      out[i+1] = w_blur * eB1 + w_pal * eP1 + w_cond * eC1;
      out[i+2] = w_blur * eB2 + w_pal * eP2 + w_cond * eC2;
    }
  }

  // ---------------------------
  // Sampler state
  // ---------------------------
  let schedule = null;
  let x = new Float32Array(3 * N);      // current x_t
  let tCur = 0;                          // current t (0..T), we operate on tCur>=1
  let rng = mulberry32(1);
  let condField = new Float32Array(3 * N);
  let running = false;

  function initRun() {
    const seed = (Number(elSeed.value) | 0) >>> 0;
    const T = Math.max(8, Math.min(256, Number(elSteps.value) | 0));
    const prompt = elPrompt.value || "";

    // Schedule tuned for "hand-coded ε" stability (larger betas than typical SD).
    schedule = buildSchedule(T, 0.02, 0.12);

    rng = mulberry32(seed);
    condField = buildTargetField(prompt, seed);

    // Initialize x_T ~ N(0,I)
    for (let i = 0; i < 3 * N; i++) x[i] = clamp1(0.6 * randn(rng));
    tCur = T;

    render();
    updateMeta();
  }

  function resetState() {
    schedule = null;
    tCur = 0;
    running = false;
    btnStop.disabled = true;
    btnRun.disabled = false;
    render();
    updateMeta();
  }

  function stepOnce() {
    if (!schedule || tCur <= 0) return;
    if (tCur === 0) return;

    const T = schedule.T;
    const t = tCur;

    // ε̂_u and ε̂_c
    predictEps(epsU, x, t, T, null);
    predictEps(epsC, x, t, T, condField);

    // Guidance: epsG = epsU + s*(epsC - epsU)
    const s = Number(elGuidance.value);
    const a = 1 - s;
    for (let i = 0; i < 3 * N; i++) epsG[i] = a * epsU[i] + s * epsC[i];

    // DDPM reverse update:
    // x_{t-1} = invSqrtAlpha[t] * ( x_t - coefEps[t] * epsG ) + sigma[t] * z
    const invSqrtA = schedule.invSqrtAlpha[t];
    const ce = schedule.coefEps[t];
    const sig = schedule.sigma[t];

    for (let i = 0; i < 3 * N; i++) {
      const z = (sig === 0) ? 0 : randn(rng);
      const v = invSqrtA * (x[i] - ce * epsG[i]) + sig * z;
      x[i] = clamp1(v);
    }

    tCur--;
    render();
    updateMeta();
  }

  // ---------------------------
  // Rendering
  // ---------------------------
  const img = ctx.createImageData(W, H);

  function render() {
    const showSnap = elShowSnap.checked;
    const showEps = elShowEps.checked;

    for (let px = 0; px < N; px++) {
      const i = px * 3;
      let r = x[i+0], g = x[i+1], b = x[i+2];

      if (showEps && schedule && tCur > 0) {
        // Heat on |epsG| (guided) at current tCur; compute quickly using epsU/epsC already if available.
        // If not available (e.g. first render), approximate with local blur residual.
        let m = 0;
        if (tCur > 0 && schedule) {
          // conservative: compute blur residual magnitude only (fast)
          // (no allocations; reuse tmpBlur)
          // Note: this makes the debug view stable even when eps arrays are stale.
          // Compute a single blur pass per render when eps view is enabled.
        }
      }

      if (showSnap) {
        const p = nearestPaletteRGB(r, g, b);
        r = p[0]; g = p[1]; b = p[2];
      }

      const o = px * 4;
      img.data[o+0] = Math.max(0, Math.min(255, Math.round((r + 1) * 127.5)));
      img.data[o+1] = Math.max(0, Math.min(255, Math.round((g + 1) * 127.5)));
      img.data[o+2] = Math.max(0, Math.min(255, Math.round((b + 1) * 127.5)));
      img.data[o+3] = 255;
    }

    if (elShowEps.checked) {
      // Optional debug overlay: render per-pixel eps magnitude as grayscale.
      // Compute eps magnitude from blur residual for visibility (cheap).
      boxBlur3x3(tmpBlur, x);
      for (let px = 0; px < N; px++) {
        const i = px * 3;
        const e0 = x[i+0] - tmpBlur[i+0];
        const e1 = x[i+1] - tmpBlur[i+1];
        const e2 = x[i+2] - tmpBlur[i+2];
        const mag = Math.sqrt(e0*e0 + e1*e1 + e2*e2);   // ~[0,?]
        const v = Math.max(0, Math.min(255, Math.round(255 * Math.min(1, mag * 1.8))));
        const o = px * 4;
        img.data[o+0] = v; img.data[o+1] = v; img.data[o+2] = v; img.data[o+3] = 255;
      }
    }

    ctx.putImageData(img, 0, 0);
  }

  function updateMeta() {
    const T = schedule ? schedule.T : 0;
    const s = Number(elGuidance.value).toFixed(1);
    const seed = (Number(elSeed.value) | 0) >>> 0;
    const prompt = (elPrompt.value || "").trim();

    elMeta.innerHTML = "";
    const items = [
      ["W×H", `${W}×${H}`],
      ["t", schedule ? `${tCur}/${T}` : "-"],
      ["seed", `${seed}`],
      ["guidance", `${s}`],
      ["prompt", prompt ? prompt : "(empty)"],
    ];
    for (const [k,v] of items) {
      const d = document.createElement("div");
      d.className = "pill";
      d.textContent = `${k}: ${v}`;
      elMeta.appendChild(d);
    }
  }

  // ---------------------------
  // Run loop
  // ---------------------------
  function setRunning(on) {
    running = on;
    btnStop.disabled = !on;
    btnRun.disabled = on;
  }

  function tick() {
    if (!running) return;
    // Do a few steps per frame for speed; keep small to avoid blocking.
    const burst = 2;
    for (let k = 0; k < burst; k++) {
      if (!schedule || tCur <= 0) { setRunning(false); break; }
      stepOnce();
    }
    requestAnimationFrame(tick);
  }

  // ---------------------------
  // Events
  // ---------------------------
  btnInit.addEventListener("click", () => initRun());
  btnStep.addEventListener("click", () => stepOnce());
  btnRun.addEventListener("click", () => { if (!schedule) initRun(); setRunning(true); requestAnimationFrame(tick); });
  btnStop.addEventListener("click", () => setRunning(false));
  btnReset.addEventListener("click", () => resetState());

  elShowSnap.addEventListener("change", () => render());
  elShowEps.addEventListener("change", () => render());
  elGuidance.addEventListener("input", () => updateMeta());

  // Rebuild conditioning + schedule when these change (without auto-running).
  function rebuild() {
    if (!schedule) { updateMeta(); return; }
    initRun();
  }
  elSteps.addEventListener("change", rebuild);
  elSeed.addEventListener("change", rebuild);
  elPrompt.addEventListener("change", rebuild);

  // Boot
  resetState();
  updateMeta();
})();
</script>
</body>
</html>
