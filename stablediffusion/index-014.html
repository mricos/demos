<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Fractal Diffusion Diagnostic</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css">
  <script src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"></script>
  <style>
    :root { --bg: #030406; --panel: #0d1117; --border: #21262d; --accent: #a855f7; }
    body { background: var(--bg); color: #c9d1d9; font-family: 'Inter', sans-serif; height: 100vh; overflow: hidden; }
    canvas { image-rendering: pixelated; border: 1px solid var(--border); background: #000; width: 100%; }
    .stat-card { background: var(--panel); border: 1px solid var(--border); border-radius: 8px; padding: 12px; position: relative; }
    .label-text { color: #8b949e; font-size: 10px; font-weight: bold; text-transform: uppercase; letter-spacing: 0.05em; display: flex; align-items: center; gap: 6px; }
    .info-trigger { cursor: help; color: var(--accent); font-weight: bold; font-family: monospace; }
    .math-block { font-size: 0.85rem; color: #58a6ff; margin-top: 4px; min-height: 1.2em; }
    .sidebar { width: 340px; border-right: 1px solid var(--border); overflow-y: auto; }
    
    /* Help Popup Styling */
    #helpOverlay { display: none; position: fixed; inset: 0; background: rgba(0,0,0,0.85); backdrop-filter: blur(4px); z-index: 100; padding: 10%; overflow-y: auto; }
    .help-content { max-width: 800px; margin: 0 auto; background: var(--panel); border: 1px solid var(--border); padding: 2rem; border-radius: 12px; }
  </style>
</head>
<body class="flex">

  <div id="helpOverlay">
    <div class="help-content">
      <div class="flex justify-between items-center mb-6 border-b border-gray-800 pb-4">
        <h2 class="text-2xl font-bold text-purple-400">Diagnostic Technical Glossary</h2>
        <button id="closeHelp" class="text-gray-500 hover:text-white">âœ• Close</button>
      </div>
      <div id="helpBody" class="space-y-6 text-sm leading-relaxed">
        </div>
    </div>
  </div>

  <aside class="sidebar p-6 flex flex-col gap-6 bg-[#0d1117]">
    <div>
      <h1 class="text-xl font-bold text-white mb-1">Fractal Lab</h1>
      <p class="text-[10px] text-purple-400 uppercase tracking-widest font-bold">Recursive Feedback Engine</p>
    </div>

    <div class="space-y-4">
      <div>
        <span class="label-text">Source Vector <span class="info-trigger" data-topic="source">[i]</span></span>
        <select id="promptA" class="w-full bg-black border border-gray-700 p-2 rounded mt-1 text-sm">
            <option value="city">Circuit City</option>
            <option value="river">River Valley</option>
            <option value="star">Celestial Star</option>
        </select>
      </div>
      
      <div class="stat-card border-purple-900/50 bg-purple-950/10">
        <span class="label-text text-purple-400">Feedback ($\beta$) <span class="info-trigger" data-topic="feedback">[i]</span></span>
        <input id="feedback" type="range" min="0" max="0.95" step="0.01" value="0.45" class="w-full mt-2" />
      </div>

      <div>
        <span class="label-text">Rotation ($\theta$) <span class="info-trigger" data-topic="transform">[i]</span></span>
        <input id="rotation" type="range" min="0" max="360" step="1" value="10" class="w-full mt-1" />
      </div>

      <div>
        <span class="label-text">Scale ($s$) <span class="info-trigger" data-topic="transform">[i]</span></span>
        <input id="scale" type="range" min="0.8" max="1.1" step="0.01" value="0.97" class="w-full mt-1" />
      </div>
    </div>

    <div class="flex flex-col gap-2 pt-4 border-t border-gray-800">
      <button id="runBtn" class="bg-purple-600 hover:bg-purple-500 text-white font-bold py-3 rounded text-sm">SOLVE RECURSION</button>
    </div>
  </aside>

  <main class="flex-1 p-8 overflow-y-auto">
    <div class="grid grid-cols-1 lg:grid-cols-12 gap-6">
      <div class="stat-card lg:col-span-6 border-purple-500/30">
        <span class="label-text">Evolving State <span id="math-xt-inline"></span> <span class="info-trigger" data-topic="xt">[i]</span></span>
        <div id="math-xt" class="math-block"></div>
        <canvas id="cv_main" class="mt-4 aspect-square"></canvas>
      </div>

      <div class="lg:col-span-6 grid grid-cols-1 gap-4">
        <div class="stat-card">
          <span class="label-text">Recursive Target <span id="math-mf-inline"></span> <span class="info-trigger" data-topic="target">[i]</span></span>
          <div id="math-mc" class="math-block"></div>
          <canvas id="cv_target" class="h-40"></canvas>
        </div>
        <div class="stat-card">
          <span class="label-text">Phase Density <span id="math-px-inline"></span> <span class="info-trigger" data-topic="density">[i]</span></span>
          <div id="math-px" class="math-block"></div>
          <canvas id="cv_hist" class="h-32 border-0"></canvas>
        </div>
      </div>
    </div>
  </main>

<script>
(() => {
  const W = 64, H = 64, N = W * H;
  
  const HELP_DOCS = {
    source: "<b>Latent Vector Source:</b> This defines the 'initial belief' or static conditioning of the system. It acts as the anchor preventing the feedback loop from devolving into pure white noise.",
    feedback: "<b>Feedback ($\beta$):</b> The coefficient of recursion. At 0.0, the system is a standard diffusion model. As it approaches 1.0, the current output dominates the future input, creating self-similar fractal patterns.",
    transform: "<b>Affine Transformation:</b> Every step, we rotate and scale the previous image. This breaks spatial symmetry and allows the diffusion process to 'see' its own structure from different angles.",
    xt: "<b>Evolving State $x_t$:</b> This is the 'Latent Image'. It is updated using a Langevin Dynamics update rule where pixels are pushed toward the target while fighting against random thermal noise.",
    target: "<b>Recursive Target $m_f$:</b> Unlike stable diffusion where the target is a static prompt, this target is dynamic. It is a linear blend of the original prompt and the transformed version of what you see on screen.",
    density: "<b>Phase Density $P(c)$:</b> Visualizes the distribution of colors. Fractals often show 'Lyapunov Convergence', where color distributions form stable, repeating peaks as the recursion matures."
  };

  const LIBRARY = {
    city: ctx => { ctx.fillStyle = '#1e293b'; ctx.fillRect(0,0,W,H); ctx.strokeStyle = '#6366f1'; for(let i=0; i<W; i+=8) ctx.strokeRect(i, H-i, 8, i); },
    river: ctx => { ctx.fillStyle = '#064e3b'; ctx.fillRect(0,0,W,H); ctx.lineWidth=6; ctx.strokeStyle='#3b82f6'; ctx.beginPath(); ctx.moveTo(0,0); ctx.bezierCurveTo(W,0,0,H,W,H); ctx.stroke(); },
    star: ctx => { ctx.fillStyle='#000'; ctx.fillRect(0,0,W,H); ctx.fillStyle='#fff'; ctx.beginPath(); ctx.arc(W/2,H/2,4,0,Math.PI*2); ctx.fill(); }
  };

  let x = new Float32Array(N*3), staticTarget = new Float32Array(N*3), currentTarget = new Float32Array(N*3);
  let t = 0, running = false;

  const getCtx = id => { const c = document.getElementById(id); if(c){ c.width = W; c.height = H; return c.getContext('2d'); } return null; };
  const ctxs = { main: getCtx('cv_main'), target: getCtx('cv_target'), hist: getCtx('cv_hist') };

  const renderMath = () => {
    const blocks = {
        'math-xt': 'x_{t-1} = x_t + \\eta(m_{f} - x_t) + \\sigma\\epsilon',
        'math-mc': 'm_{f} = (1-\\beta)m_{static} + \\beta \\mathcal{T}(x_t)',
        'math-px': 'P(c) = \\int \\delta(c - x_t) dc'
    };
    const inlines = {
        'math-xt-inline': 'x_t',
        'math-mf-inline': 'm_f',
        'math-px-inline': 'P(c)'
    };
    Object.entries(blocks).forEach(([id, tex]) => katex.render(tex, document.getElementById(id)));
    Object.entries(inlines).forEach(([id, tex]) => katex.render(tex, document.getElementById(id)));
  };

  function step() {
    if(t <= 0) return running = false;
    const beta = parseFloat(document.getElementById('feedback').value);
    const angle = parseFloat(document.getElementById('rotation').value) * Math.PI / 180;
    const scale = parseFloat(document.getElementById('scale').value);

    // Feedback Transformation
    const off = document.createElement('canvas'); off.width = W; off.height = H; const octx = off.getContext('2d');
    const imgX = octx.createImageData(W,H);
    for(let i=0; i<N; i++) { 
      imgX.data[i*4] = (x[i*3]+1)*127.5; imgX.data[i*4+1] = (x[i*3+1]+1)*127.5; 
      imgX.data[i*4+2] = (x[i*3+2]+1)*127.5; imgX.data[i*4+3] = 255; 
    }
    octx.putImageData(imgX, 0, 0);

    const tCanvas = document.createElement('canvas'); tCanvas.width = W; tCanvas.height = H; const tctx = tCanvas.getContext('2d');
    tctx.translate(W/2, H/2); tctx.rotate(angle); tctx.scale(scale, scale); tctx.translate(-W/2, -H/2);
    tctx.drawImage(off, 0, 0);
    const tData = tctx.getImageData(0,0,W,H).data;

    for(let i=0; i<N; i++) {
        for(let c=0; c<3; c++) {
            const transformedVal = (tData[i*4+c]/127.5)-1;
            currentTarget[i*3+c] = (1-beta)*staticTarget[i*3+c] + beta*transformedVal;
        }
    }

    for(let i=0; i<N*3; i++) {
        x[i] += (currentTarget[i] - x[i]) * 0.15 + (Math.random()*2-1) * 0.05;
        x[i] = Math.max(-1, Math.min(1, x[i]));
    }

    renderViews();
    t--;
    if(running) requestAnimationFrame(step);
  }

  function renderViews() {
    const mainImg = ctxs.main.createImageData(W, H);
    const targetImg = ctxs.target.createImageData(W, H);
    for(let i=0; i<N; i++) {
      for(let c=0; c<3; c++) {
        mainImg.data[i*4+c] = (x[i*3+c]+1)*127.5;
        targetImg.data[i*4+c] = (currentTarget[i*3+c]+1)*127.5;
      }
      mainImg.data[i*4+3] = 255; targetImg.data[i*4+3] = 255;
    }
    ctxs.main.putImageData(mainImg, 0, 0);
    ctxs.target.putImageData(targetImg, 0, 0);

    const h = ctxs.hist; h.clearRect(0,0,W,H);
    const bins = [new Array(20).fill(0), new Array(20).fill(0), new Array(20).fill(0)];
    for(let i=0; i<N; i++) for(let c=0; c<3; c++) bins[c][Math.floor(((x[i*3+c]+1)/2)*19.9)]++;
    ['#ef4444', '#22c55e', '#3b82f6'].forEach((col, c) => {
        h.fillStyle = col; h.globalAlpha = 0.4;
        bins[c].forEach((v, i) => h.fillRect(i*(W/20), H, (W/20)-1, -(v/N)*H*4));
    });
  }

  // --- UI Handlers ---
  document.querySelectorAll('.info-trigger').forEach(el => {
    el.addEventListener('click', () => {
        const topic = el.getAttribute('data-topic');
        document.getElementById('helpBody').innerHTML = HELP_DOCS[topic] || "Topic not found.";
        document.getElementById('helpOverlay').style.display = 'block';
    });
  });

  document.getElementById('closeHelp').onclick = () => document.getElementById('helpOverlay').style.display = 'none';
  document.getElementById('runBtn').onclick = () => {
    const pA = document.getElementById('promptA').value;
    const off = document.createElement('canvas'); off.width = W; off.height = H; const octx = off.getContext('2d');
    LIBRARY[pA](octx);
    const data = octx.getImageData(0,0,W,H).data;
    for(let i=0; i<N; i++) {
      staticTarget[i*3] = (data[i*4]/127.5)-1; staticTarget[i*3+1] = (data[i*4+1]/127.5)-1; staticTarget[i*3+2] = (data[i*4+2]/127.5)-1;
    }
    for(let i=0; i<N*3; i++) x[i] = (Math.random()*2)-1;
    t = 256; running = true; step();
  };

  renderMath();
})();
</script>
</body>
</html>
