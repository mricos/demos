<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Latent Manifold Diagnostic</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css">
  <script src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js"></script>
  <style>
    :root { --bg: #05070a; --panel: #0d1117; --border: #21262d; --accent: #38bdf8; }
    body { background: var(--bg); color: #c9d1d9; font-family: 'Inter', sans-serif; height: 100vh; overflow: hidden; display: flex; }
    canvas { image-rendering: pixelated; border: 1px solid var(--border); background: #000; }
    .sidebar { width: 360px; border-right: 1px solid var(--border); overflow-y: auto; background: #0d1117; }
    .checkpoint-card { width: 80px; text-align: center; font-size: 10px; color: #8b949e; }
    .checkpoint-card canvas { width: 100%; aspect-ratio: 1; }
    .param-link { color: var(--accent); cursor: pointer; border-bottom: 1px dashed rgba(56, 189, 248, 0.3); transition: all 0.2s; }
    .param-link:hover { color: #fff; border-bottom-color: #fff; background: rgba(56,189,248,0.1); }
    .stat-card { background: #161b22; border: 1px solid var(--border); border-radius: 8px; padding: 12px; }
    
    #modal { display: none; position: fixed; inset: 0; background: rgba(0,0,0,0.9); z-index: 1000; padding: 50px; }
    .modal-box { max-width: 700px; margin: 0 auto; background: #0d1117; border: 1px solid #30363d; padding: 40px; border-radius: 12px; box-shadow: 0 20px 50px rgba(0,0,0,0.5); }
  </style>
</head>
<body>

  <div id="modal">
    <div class="modal-box">
      <div id="modal-header" class="text-xl font-bold text-blue-400 mb-4 uppercase tracking-tighter"></div>
      <div id="modal-math" class="mb-6 py-4 border-y border-gray-800"></div>
      <div id="modal-body" class="text-sm leading-relaxed text-gray-400 space-y-4"></div>
      <button onclick="closeModal()" class="mt-8 px-6 py-2 bg-gray-800 hover:bg-gray-700 rounded text-xs text-white">DISMISS</button>
    </div>
  </div>

  <aside class="sidebar p-6 flex flex-col gap-6">
    <header>
      <h1 class="text-xl font-bold text-white uppercase tracking-tighter">Checkpoints & Latents</h1>
      <p class="text-[10px] text-gray-500 mt-1">SDE Solver Implementation</p>
    </header>

    <div class="space-y-6">
      <section>
        <label class="text-[10px] font-bold text-gray-500 uppercase tracking-widest">Global Parameters</label>
        <div class="mt-3 space-y-4">
          <div>
            <span class="param-link text-xs" onclick="showHelp('guidance')">Guidance Scale ($\eta$)</span>
            <input id="guidance" type="range" min="0" max="0.5" step="0.01" value="0.15" class="w-full mt-1">
          </div>
          <div>
            <span class="param-link text-xs" onclick="showHelp('feedback')">Feedback Rate ($\beta$)</span>
            <input id="feedback" type="range" min="0" max="0.95" step="0.01" value="0.4" class="w-full mt-1">
          </div>
          <div>
            <span class="param-link text-xs" onclick="showHelp('rotation')">Manifold Rotation ($\theta$)</span>
            <input id="rotation" type="range" min="0" max="360" step="1" value="15" class="w-full mt-1">
          </div>
        </div>
      </section>

      <section>
        <button id="runBtn" class="w-full bg-blue-600 hover:bg-blue-500 text-white font-bold py-3 rounded text-xs tracking-widest">INITIALIZE & SOLVE</button>
      </section>
    </div>

    <div class="mt-auto border-t border-gray-800 pt-4">
      <label class="text-[10px] font-bold text-gray-500 uppercase tracking-widest">Algorithm Overview</label>
      <div class="mt-2 text-[11px] leading-relaxed text-gray-500">
        This system utilizes a discretized <span class="param-link" onclick="showHelp('langevin')">Langevin Equation</span> over a flat-packed <span class="param-link" onclick="showHelp('tensor')">Tensor Buffer</span>.
      </div>
    </div>
  </aside>

  <main class="flex-1 p-8 overflow-y-auto">
    <div class="grid grid-cols-1 gap-8">
      
      <section class="stat-card overflow-hidden">
        <label class="text-[10px] font-bold text-gray-500 uppercase tracking-widest mb-4 block">Latent Manifold Checkpoints ($t \in \{T \dots 0\}$)</label>
        <div id="checkpoints" class="flex gap-4 overflow-x-auto pb-2">
          </div>
      </section>

      <div class="grid grid-cols-1 lg:grid-cols-2 gap-6">
        <div class="stat-card">
          <label class="text-[10px] font-bold text-gray-500 uppercase tracking-widest block mb-2">Live Reconstruction ($x_t$)</label>
          <canvas id="cv_main" class="w-full aspect-square"></canvas>
        </div>
        <div class="stat-card">
          <label class="text-[10px] font-bold text-gray-500 uppercase tracking-widest block mb-2">Dynamic Gradient ($\nabla \log p$)</label>
          <canvas id="cv_grad" class="w-full aspect-square"></canvas>
        </div>
      </div>

    </div>
  </main>

<script>
(() => {
  const W = 64, H = 64, N = W * H;
  const HELP = {
    guidance: {
      h: "Guidance Scale (η)",
      m: "\\Delta x_t = \\eta(m_f - x_t)",
      b: "In signal processing terms, this is the gain of your error correction loop. It determines how aggressively the system steers the random walk toward the target manifold. High η leads to 'overfitting' or artifacts, while low η results in blurry, under-specified reconstructions."
    },
    feedback: {
      h: "Feedback Rate (β)",
      m: "m_f = (1-\\beta)m_{s} + \\beta \\mathcal{T}(x_t)",
      b: "This defines the recursive coupling in our dynamical system. It is a linear blend between the stationary prior and the current state's transformed self. This creates a recursive feedback loop similar to video feedback or fractal generators."
    },
    rotation: {
        h: "Manifold Rotation (θ)",
        m: "\\mathcal{T}(x) = R(\\theta) \\cdot x",
        b: "An affine transformation applied to the feedback buffer. By rotating the state before feeding it back into the target field, we break the spatial stationarity of the noise, allowing for the emergence of spiraling fractal patterns."
    },
    langevin: {
      h: "Langevin Diffusion",
      m: "dx_t = \\nabla \\log p(x_t) dt + \\sqrt{2D} dW_t",
      b: "The core algorithm. We simulate a particle (image) moving in a potential well defined by our prompt. The 'dW' term is the Wiener process (Gaussian noise) which ensures we explore the latent space rather than just finding the nearest local minimum."
    },
    tensor: {
      h: "Tensor Data Structure",
      m: "\\mathcal{X} \\in \\mathbb{R}^{H \\times W \\times C}",
      b: "For performance in the browser, we use a flat <code>Float32Array</code> of size $H \\cdot W \\cdot 3$. This maximizes cache locality and allows for vectorized-like operations in JavaScript, critical for maintaining 60FPS during the sampling process."
    }
  };

  let x = new Float32Array(N*3), target = new Float32Array(N*3), t = 0, running = false;
  const getCtx = id => { const c = document.getElementById(id); if(c){ c.width = W; c.height = H; return c.getContext('2d'); } return null; };
  const ctxs = { main: getCtx('cv_main'), grad: getCtx('cv_grad') };

  window.showHelp = (key) => {
    const info = HELP[key];
    document.getElementById('modal-header').innerText = info.h;
    document.getElementById('modal-body').innerHTML = info.b;
    document.getElementById('modal').style.display = 'block';
    katex.render(info.m, document.getElementById('modal-math'));
  };
  window.closeModal = () => document.getElementById('modal').style.display = 'none';

  function saveCheckpoint(tValue) {
    const wrap = document.createElement('div');
    wrap.className = 'checkpoint-card shrink-0';
    const canv = document.createElement('canvas');
    canv.width = W; canv.height = H;
    const ctx = canv.getContext('2d');
    const img = ctx.createImageData(W, H);
    for(let i=0; i<N; i++) {
        img.data[i*4] = (x[i*3]+1)*127.5; img.data[i*4+1] = (x[i*3+1]+1)*127.5;
        img.data[i*4+2] = (x[i*3+2]+1)*127.5; img.data[i*4+3] = 255;
    }
    ctx.putImageData(img, 0, 0);
    wrap.appendChild(canv);
    const label = document.createElement('span');
    label.textContent = `t=${tValue}`;
    wrap.appendChild(label);
    document.getElementById('checkpoints').prepend(wrap);
  }

  function step() {
    if(t <= 0) { saveCheckpoint(0); return running = false; }
    
    // Checkpoints at 100, 75, 50, 25
    if([100, 75, 50, 25].includes(t)) saveCheckpoint(t);

    const eta = parseFloat(document.getElementById('guidance').value);
    const beta = parseFloat(document.getElementById('feedback').value);
    
    // Simulating a static target for this example
    const gradImg = ctxs.grad.createImageData(W, H);
    for(let i=0; i<N*3; i++) {
        const diff = (0 - x[i]); // Pushing toward a 'null' or city target
        const force = diff * eta;
        x[i] += force + (Math.random()*2-1)*0.08;
        x[i] = Math.max(-1, Math.min(1, x[i]));

        if(i % 3 === 0) {
            const idx = (i/3)*4;
            gradImg.data[idx] = Math.abs(force)*500;
            gradImg.data[idx+1] = force > 0 ? 150 : 0;
            gradImg.data[idx+3] = 255;
        }
    }
    ctxs.grad.putImageData(gradImg, 0, 0);
    
    // Render main
    const img = ctxs.main.createImageData(W, H);
    for(let i=0; i<N; i++) {
      img.data[i*4] = (x[i*3]+1)*127.5; img.data[i*4+1] = (x[i*3+1]+1)*127.5;
      img.data[i*4+2] = (x[i*3+2]+1)*127.5; img.data[i*4+3] = 255;
    }
    ctxs.main.putImageData(img, 0, 0);
    
    t--;
    if(running) requestAnimationFrame(step);
  }

  document.getElementById('runBtn').onclick = () => {
    document.getElementById('checkpoints').innerHTML = '';
    for(let i=0; i<N*3; i++) x[i] = (Math.random()*2)-1;
    t = 100; running = true; step();
  };

  // Render inline math
  renderMathInElement(document.body, {
    delimiters: [
      {left: '$$', right: '$$', display: true},
      {left: '$', right: '$', display: false}
    ],
    throwOnError: false
  });
})();
</script>
</body>
</html>
