<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Stable Diffusion Deep Dive</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #0d1117;
            color: #c9d1d9;
            height: 100vh;
            overflow: hidden;
        }

        .container {
            display: flex;
            height: 100vh;
        }

        .sidebar {
            width: 380px;
            background: #161b22;
            padding: 25px;
            overflow-y: auto;
            border-right: 1px solid #30363d;
        }

        .main-content {
            flex: 1;
            padding: 25px;
            overflow-y: auto;
        }

        h1 {
            color: #58a6ff;
            margin-bottom: 8px;
            font-size: 22px;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .help-icon {
            display: inline-block;
            width: 20px;
            height: 20px;
            background: #58a6ff;
            color: #0d1117;
            border-radius: 50%;
            text-align: center;
            line-height: 20px;
            font-size: 12px;
            font-weight: bold;
            cursor: help;
            transition: all 0.3s;
        }

        .help-icon:hover {
            background: #79c0ff;
            transform: scale(1.2);
        }

        .subtitle {
            color: #8b949e;
            margin-bottom: 20px;
            font-size: 13px;
            line-height: 1.5;
        }

        .control-group {
            margin-bottom: 18px;
            background: #0d1117;
            padding: 15px;
            border-radius: 6px;
            border: 1px solid #30363d;
            position: relative;
        }

        .control-group:hover {
            border-color: #58a6ff;
        }

        label {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 10px;
            color: #58a6ff;
            font-weight: 600;
            font-size: 12px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            cursor: help;
        }

        input[type="range"] {
            width: 100%;
            height: 6px;
            border-radius: 3px;
            background: #21262d;
            outline: none;
            -webkit-appearance: none;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: #58a6ff;
            cursor: pointer;
            box-shadow: 0 0 0 4px rgba(88, 166, 255, 0.2);
        }

        input[type="range"]::-moz-range-thumb {
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: #58a6ff;
            cursor: pointer;
            border: none;
            box-shadow: 0 0 0 4px rgba(88, 166, 255, 0.2);
        }

        .value-display {
            color: #79c0ff;
            font-weight: bold;
            font-size: 13px;
            margin-top: 6px;
            font-family: 'Courier New', monospace;
        }

        select {
            width: 100%;
            padding: 10px;
            background: #0d1117;
            color: #c9d1d9;
            border: 1px solid #30363d;
            border-radius: 6px;
            font-size: 13px;
            cursor: pointer;
        }

        select:hover {
            border-color: #58a6ff;
        }

        button {
            width: 100%;
            padding: 12px;
            margin-bottom: 8px;
            border: 1px solid #30363d;
            border-radius: 6px;
            background: #21262d;
            color: #c9d1d9;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            font-size: 12px;
        }

        button:hover {
            background: #30363d;
            border-color: #58a6ff;
            color: #58a6ff;
        }

        button.primary {
            background: #238636;
            border-color: #238636;
            color: white;
        }

        button.primary:hover {
            background: #2ea043;
            border-color: #2ea043;
        }

        .tooltip {
            position: fixed;
            background: #161b22;
            border: 2px solid #58a6ff;
            border-radius: 8px;
            padding: 15px;
            max-width: 350px;
            z-index: 1000;
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.5);
            display: none;
            pointer-events: none;
        }

        .tooltip.active {
            display: block;
        }

        .tooltip-title {
            color: #58a6ff;
            font-weight: bold;
            margin-bottom: 8px;
            font-size: 14px;
        }

        .tooltip-content {
            color: #8b949e;
            font-size: 12px;
            line-height: 1.6;
        }

        .tooltip-formula {
            background: #0d1117;
            padding: 10px;
            border-radius: 4px;
            margin-top: 8px;
            font-family: 'Times New Roman', serif;
            color: #79c0ff;
            font-size: 13px;
        }

        .help-panel {
            background: #161b22;
            border: 1px solid #30363d;
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 25px;
        }

        .help-section {
            margin-bottom: 15px;
        }

        .help-section h3 {
            color: #58a6ff;
            font-size: 14px;
            margin-bottom: 8px;
        }

        .help-section p {
            color: #8b949e;
            font-size: 12px;
            line-height: 1.6;
        }

        .pipeline-viz {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 20px;
            margin-bottom: 25px;
        }

        .stage {
            background: #161b22;
            border: 1px solid #30363d;
            border-radius: 8px;
            padding: 15px;
            transition: all 0.3s;
        }

        .stage:hover {
            border-color: #58a6ff;
            box-shadow: 0 0 20px rgba(88, 166, 255, 0.2);
        }

        .stage-title {
            color: #58a6ff;
            font-weight: bold;
            margin-bottom: 10px;
            font-size: 13px;
            text-align: center;
        }

        .stage-canvas {
            width: 100%;
            border: 1px solid #30363d;
            border-radius: 4px;
            background: #0d1117;
        }

        .stage-info {
            margin-top: 10px;
            font-size: 11px;
            color: #8b949e;
            line-height: 1.4;
        }

        code {
            background: #0d1117;
            padding: 2px 6px;
            border-radius: 3px;
            color: #79c0ff;
            font-size: 11px;
        }

        .schedule-container {
            background: #161b22;
            border: 1px solid #30363d;
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 25px;
        }

        .schedule-title {
            color: #58a6ff;
            font-weight: bold;
            margin-bottom: 15px;
            font-size: 14px;
        }

        canvas {
            width: 100%;
            border-radius: 4px;
        }

        .legend {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 10px;
            margin-top: 15px;
            font-size: 11px;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .legend-color {
            width: 30px;
            height: 14px;
            border-radius: 3px;
        }

        .metrics-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 12px;
            margin-top: 15px;
        }

        .metric {
            background: #0d1117;
            padding: 12px;
            border-radius: 6px;
            border: 1px solid #30363d;
            text-align: center;
        }

        .metric-label {
            font-size: 10px;
            color: #8b949e;
            text-transform: uppercase;
            margin-bottom: 6px;
        }

        .metric-value {
            font-size: 18px;
            color: #58a6ff;
            font-weight: bold;
            font-family: 'Courier New', monospace;
        }

        .composition-panel {
            background: #161b22;
            border: 1px solid #30363d;
            border-radius: 8px;
            padding: 20px;
        }

        .composition-inputs {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
            margin-bottom: 15px;
        }

        .composition-input {
            background: #0d1117;
            padding: 12px;
            border-radius: 6px;
            border: 1px solid #30363d;
        }

        .composition-label {
            color: #58a6ff;
            font-size: 11px;
            text-transform: uppercase;
            margin-bottom: 8px;
            font-weight: 600;
        }

        .weight-slider {
            margin-top: 8px;
        }

        .unet-viz {
            background: #161b22;
            border: 1px solid #30363d;
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 25px;
        }

        .unet-layers {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-top: 15px;
        }

        .unet-layer {
            background: #0d1117;
            border: 1px solid #30363d;
            border-radius: 6px;
            padding: 10px;
            text-align: center;
            font-size: 10px;
            color: #8b949e;
            transition: all 0.3s;
        }

        .unet-layer.active {
            border-color: #58a6ff;
            color: #58a6ff;
            box-shadow: 0 0 15px rgba(88, 166, 255, 0.3);
        }

        .unet-arrow {
            color: #30363d;
            font-size: 20px;
        }

        .divider {
            height: 1px;
            background: #30363d;
            margin: 20px 0;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        .processing {
            animation: pulse 1.5s infinite;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="sidebar">
            <h1>
                ‚ö° Stable Diffusion Deep Dive
                <span class="help-icon" id="main-help">?</span>
            </h1>
            <p class="subtitle">Interactive exploration of the latent diffusion algorithm</p>

            <div class="control-group">
                <label>
                    <span>Concept A (Primary)</span>
                    <span class="help-icon" data-help="concept-a">?</span>
                </label>
                <select id="concept-a">
                    <option value="circle">Circle</option>
                    <option value="square">Square</option>
                    <option value="face">Face</option>
                    <option value="landscape">Landscape</option>
                    <option value="star">Star</option>
                </select>
                <div class="weight-slider">
                    <input type="range" id="weight-a" min="0" max="100" value="70">
                    <div class="value-display" id="weight-a-value">Weight: 0.70</div>
                </div>
            </div>

            <div class="control-group">
                <label>
                    <span>Concept B (Secondary)</span>
                    <span class="help-icon" data-help="concept-b">?</span>
                </label>
                <select id="concept-b">
                    <option value="gradient">Gradient</option>
                    <option value="circle">Circle</option>
                    <option value="square">Square</option>
                    <option value="face">Face</option>
                    <option value="landscape">Landscape</option>
                </select>
                <div class="weight-slider">
                    <input type="range" id="weight-b" min="0" max="100" value="30">
                    <div class="value-display" id="weight-b-value">Weight: 0.30</div>
                </div>
            </div>

            <div class="divider"></div>

            <div class="control-group">
                <label>
                    <span>Diffusion Timesteps (T)</span>
                    <span class="help-icon" data-help="timesteps">?</span>
                </label>
                <input type="range" id="timesteps-slider" min="10" max="100" value="50" step="5">
                <div class="value-display" id="timesteps-value">T = 50 steps</div>
            </div>

            <div class="control-group">
                <label>
                    <span>VAE Compression Ratio</span>
                    <span class="help-icon" data-help="compression">?</span>
                </label>
                <input type="range" id="compression-slider" min="1" max="4" value="3">
                <div class="value-display" id="compression-value">8x (256‚Üí32)</div>
            </div>

            <div class="control-group">
                <label>
                    <span>Noise Schedule Œ≤</span>
                    <span class="help-icon" data-help="beta">?</span>
                </label>
                <input type="range" id="beta-slider" min="1" max="10" value="5">
                <div class="value-display" id="beta-value">Œ≤ = 0.0020 (linear)</div>
            </div>

            <div class="control-group">
                <label>
                    <span>Guidance Scale (CFG)</span>
                    <span class="help-icon" data-help="cfg">?</span>
                </label>
                <input type="range" id="cfg-slider" min="1" max="20" value="75" step="5">
                <div class="value-display" id="cfg-value">w = 7.5</div>
            </div>

            <div class="divider"></div>

            <button id="full-pipeline-btn" class="primary">‚ñ∂ Run Complete Pipeline</button>
            <button id="encode-btn">Step 1: VAE Encode</button>
            <button id="forward-btn">Step 2: Add Noise (Forward)</button>
            <button id="reverse-btn">Step 3: U-Net Denoise (Reverse)</button>
            <button id="decode-btn">Step 4: VAE Decode</button>
            <button id="reset-btn">‚Üª Reset</button>
        </div>

        <div class="main-content">
            <div class="help-panel" id="help-panel">
                <div class="help-section">
                    <h3>üìö How Stable Diffusion Works</h3>
                    <p>
                        <strong>Step 1 - VAE Encoder:</strong> The input image is compressed into a lower-dimensional latent space using a Variational Autoencoder. This 8x compression reduces a 256√ó256 image to 32√ó32√ó4 channels, making the process computationally efficient.
                    </p>
                </div>
                <div class="help-section">
                    <p>
                        <strong>Step 2 - Forward Diffusion:</strong> Gaussian noise is gradually added to the latent representation over T timesteps following the equation q(x_t|x_0) = ùí©(‚àö·æ±_t x_0, (1-·æ±_t)I). This creates a noisy version at each timestep.
                    </p>
                </div>
                <div class="help-section">
                    <p>
                        <strong>Step 3 - Reverse Diffusion:</strong> A U-Net neural network learns to predict and remove noise at each timestep, starting from pure noise and gradually recovering the latent representation. This is guided by text embeddings (simulated here by concept composition).
                    </p>
                </div>
                <div class="help-section">
                    <p>
                        <strong>Step 4 - VAE Decoder:</strong> The denoised latent is upscaled back to pixel space, reconstructing the final image at 256√ó256 resolution.
                    </p>
                </div>
            </div>

            <div class="pipeline-viz">
                <div class="stage">
                    <div class="stage-title">üñºÔ∏è Image Space</div>
                    <canvas class="stage-canvas" id="original-canvas" width="200" height="200"></canvas>
                    <div class="stage-info">
                        Dimensions: <code id="original-dims">256√ó256√ó3</code><br>
                        Space: RGB pixel values [0,255]
                    </div>
                </div>

                <div class="stage">
                    <div class="stage-title">üîÆ Latent Space</div>
                    <canvas class="stage-canvas" id="latent-canvas" width="200" height="200"></canvas>
                    <div class="stage-info">
                        Compressed: <code id="latent-dims">32√ó32√ó4</code><br>
                        Space: Learned continuous features
                    </div>
                </div>

                <div class="stage">
                    <div class="stage-title">‚ú® Reconstructed</div>
                    <canvas class="stage-canvas" id="output-canvas" width="200" height="200"></canvas>
                    <div class="stage-info">
                        Decoded: <code id="output-dims">256√ó256√ó3</code><br>
                        Composition applied
                    </div>
                </div>
            </div>

            <div class="unet-viz">
                <div class="schedule-title">üß† U-Net Architecture Flow</div>
                <div class="unet-layers">
                    <div class="unet-layer" id="unet-input">Input<br>Noisy x_t</div>
                    <div class="unet-arrow">‚Üí</div>
                    <div class="unet-layer" id="unet-down">Downsample<br>Encoder</div>
                    <div class="unet-arrow">‚Üí</div>
                    <div class="unet-layer" id="unet-bottleneck">Bottleneck<br>+ Time Embed</div>
                    <div class="unet-arrow">‚Üí</div>
                    <div class="unet-layer" id="unet-up">Upsample<br>Decoder</div>
                    <div class="unet-arrow">‚Üí</div>
                    <div class="unet-layer" id="unet-output">Output<br>Noise Œµ_Œ∏</div>
                </div>
                <div class="metrics-grid">
                    <div class="metric">
                        <div class="metric-label">Timestep</div>
                        <div class="metric-value" id="current-step">0</div>
                    </div>
                    <div class="metric">
                        <div class="metric-label">Signal/Noise</div>
                        <div class="metric-value" id="snr">‚àû</div>
                    </div>
                    <div class="metric">
                        <div class="metric-label">U-Net Calls</div>
                        <div class="metric-value" id="unet-calls">0</div>
                    </div>
                    <div class="metric">
                        <div class="metric-label">Progress</div>
                        <div class="metric-value" id="progress">0%</div>
                    </div>
                </div>
            </div>

            <div class="schedule-container">
                <div class="schedule-title">üìä Diffusion Schedule Visualization</div>
                <canvas id="schedule-canvas" width="1000" height="300"></canvas>
                <div class="legend">
                    <div class="legend-item">
                        <div class="legend-color" style="background: #58a6ff;"></div>
                        <span>Forward Process: q(x_t|x_0) - Adding noise</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background: #3fb950;"></div>
                        <span>Reverse Process: p_Œ∏(x_{t-1}|x_t) - Denoising</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background: #f85149;"></div>
                        <span>Noise Level: ‚àö(1 - ·æ±_t)</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background: #d29922;"></div>
                        <span>Signal Strength: ‚àö·æ±_t</span>
                    </div>
                </div>
            </div>

            <div class="composition-panel">
                <div class="schedule-title">üé® Latent Space Composition</div>
                <p style="color: #8b949e; font-size: 12px; margin-bottom: 15px;">
                    Stable Diffusion can blend multiple concepts by linearly combining their text embeddings in latent space. 
                    This simulates classifier-free guidance where concept weights control the composition.
                </p>
                <canvas id="composition-canvas" width="1000" height="200"></canvas>
            </div>
        </div>
    </div>

    <!-- Tooltip -->
    <div class="tooltip" id="tooltip">
        <div class="tooltip-title" id="tooltip-title"></div>
        <div class="tooltip-content" id="tooltip-content"></div>
    </div>

    <script>
        // Help content database
        const helpContent = {
            'main-help': {
                title: 'Stable Diffusion Overview',
                content: 'This visualization demonstrates the core algorithm behind Stable Diffusion (Latent Diffusion Models). Unlike pixel-space diffusion, Stable Diffusion operates in a compressed latent space using a Variational Autoencoder (VAE), making it 8x more efficient. The model learns to reverse a gradual noising process to generate images from text prompts.',
                formula: 'L = ùîº_{x,Œµ,t}[||Œµ - Œµ_Œ∏(x_t, t)||¬≤]'
            },
            'concept-a': {
                title: 'Primary Concept (Text Embedding)',
                content: 'In real Stable Diffusion, this would be your main text prompt encoded by CLIP into a 77√ó768 dimensional embedding. The U-Net is conditioned on this embedding through cross-attention layers. Higher weight means stronger adherence to this concept during denoising.',
                formula: 'c_primary = CLIP_encoder("your prompt")'
            },
            'concept-b': {
                title: 'Secondary Concept (Composition)',
                content: 'Demonstrates multi-concept blending. Real Stable Diffusion can combine prompts like "cat" + "robot" by interpolating their embeddings. This is key to its creative capabilities - you can smoothly blend between different concepts in latent space.',
                formula: 'c_combined = w_A ¬∑ c_A + w_B ¬∑ c_B'
            },
            'timesteps': {
                title: 'Diffusion Timesteps (T)',
                content: 'Number of discrete steps in the diffusion process. More steps = higher quality but slower generation. Each step removes a small amount of noise. Typical values: 20-50 for speed, 50-150 for quality. DDIM samplers can reduce steps while maintaining quality.',
                formula: 't ‚àà {1, 2, ..., T} where x_T ~ ùí©(0,I)'
            },
            'compression': {
                title: 'VAE Compression Factor',
                content: 'The Variational Autoencoder compresses images into latent space. 8x compression means a 512√ó512 image becomes 64√ó64√ó4 latents. This is what makes Stable Diffusion "stable" and fast - working in compressed space reduces memory and compute by 64x compared to pixel diffusion.',
                formula: 'z = Encoder(x), z ‚àà ‚Ñù^{h/f √ó w/f √ó c}'
            },
            'beta': {
                title: 'Noise Schedule Œ≤_t',
                content: 'Controls how quickly noise is added at each timestep. Linear schedule: Œ≤ increases linearly. Cosine schedule: slower noise addition early on. The schedule defines Œ±_t = 1-Œ≤_t and cumulative ·æ±_t = ‚àèŒ±_i, which determines the signal-to-noise ratio at each step.',
                formula: 'Œ≤_t ‚àà [Œ≤_min, Œ≤_max], typically [0.0001, 0.02]'
            },
            'cfg': {
                title: 'Classifier-Free Guidance Scale',
                content: 'CFG makes the model follow prompts more closely. It works by predicting both conditional (with prompt) and unconditional (without prompt) noise, then extrapolating: Œµ = Œµ_uncond + w(Œµ_cond - Œµ_uncond). Values: 1=no guidance, 7-15=typical, 20+=very strict adherence.',
                formula: 'Œµ_guided = Œµ_‚àÖ + w(Œµ_c - Œµ_‚àÖ)'
            }
        };

        // Canvas references
        const originalCanvas = document.getElementById('original-canvas');
        const latentCanvas = document.getElementById('latent-canvas');
        const outputCanvas = document.getElementById('output-canvas');
        const scheduleCanvas = document.getElementById('schedule-canvas');
        const compositionCanvas = document.getElementById('composition-canvas');

        const originalCtx = originalCanvas.getContext('2d');
        const latentCtx = latentCanvas.getContext('2d');
        const outputCtx = outputCanvas.getContext('2d');
        const scheduleCtx = scheduleCanvas.getContext('2d');
        const compositionCtx = compositionCanvas.getContext('2d');

        // State
        let timesteps = 50;
        let compressionFactor = 8;
        let betaMin = 0.0001;
        let betaMax = 0.02;
        let cfgScale = 7.5;
        let currentTimestep = 0;
        let unetCalls = 0;
        let isProcessing = false;

        let conceptA = 'circle';
        let conceptB = 'gradient';
        let weightA = 0.7;
        let weightB = 0.3;

        let originalImageData = null;
        let latentRepresentation = null;
        let noisyLatent = null;

        let alphaBar = [];
        let beta = [];

        // Initialize noise schedule
        function computeNoiseSchedule() {
            beta = [];
            alphaBar = [];
            
            for (let t = 0; t <= timesteps; t++) {
                // Linear schedule
                const beta_t = betaMin + (t / timesteps) * (betaMax - betaMin);
                beta.push(beta_t);
                
                // Compute cumulative alpha
                let alpha_bar_t = 1;
                for (let i = 0; i <= t; i++) {
                    alpha_bar_t *= (1 - beta[i]);
                }
                alphaBar.push(alpha_bar_t);
            }
        }

        // Pattern drawing
        function drawPattern(ctx, pattern, width, height, alpha = 1) {
            ctx.globalAlpha = alpha;
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, width, height);

            const centerX = width / 2;
            const centerY = height / 2;

            switch(pattern) {
                case 'circle':
                    ctx.fillStyle = '#fff';
                    ctx.beginPath();
                    ctx.arc(centerX, centerY, 60, 0, Math.PI * 2);
                    ctx.fill();
                    break;
                
                case 'square':
                    ctx.fillStyle = '#fff';
                    ctx.fillRect(centerX - 50, centerY - 50, 100, 100);
                    break;
                
                case 'gradient':
                    const grad = ctx.createLinearGradient(0, 0, width, height);
                    grad.addColorStop(0, '#fff');
                    grad.addColorStop(1, '#000');
                    ctx.fillStyle = grad;
                    ctx.fillRect(0, 0, width, height);
                    break;
                
                case 'face':
                    ctx.fillStyle = '#fff';
                    ctx.beginPath();
                    ctx.arc(centerX, centerY, 55, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.fillStyle = '#000';
                    ctx.beginPath();
                    ctx.arc(centerX - 20, centerY - 15, 8, 0, Math.PI * 2);
                    ctx.arc(centerX + 20, centerY - 15, 8, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.strokeStyle = '#000';
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.arc(centerX, centerY + 10, 25, 0, Math.PI);
                    ctx.stroke();
                    break;
                
                case 'landscape':
                    const skyGrad = ctx.createLinearGradient(0, 0, 0, height/2);
                    skyGrad.addColorStop(0, '#4a90e2');
                    skyGrad.addColorStop(1, '#87ceeb');
                    ctx.fillStyle = skyGrad;
                    ctx.fillRect(0, 0, width, height/2);
                    ctx.fillStyle = '#2d5016';
                    ctx.fillRect(0, height/2, width, height/2);
                    ctx.fillStyle = '#5a5a5a';
                    ctx.beginPath();
                    ctx.moveTo(0, height/2);
                    ctx.lineTo(width/2, height/4);
                    ctx.lineTo(width, height/2);
                    ctx.fill();
                    break;
                
                case 'star':
                    ctx.fillStyle = '#fff';
                    ctx.beginPath();
                    for (let i = 0; i < 5; i++) {
                        const angle = (i * 4 * Math.PI) / 5 - Math.PI / 2;
                        const x = centerX + Math.cos(angle) * 60;
                        const y = centerY + Math.sin(angle) * 60;
                        if (i === 0) ctx.moveTo(x, y);
                        else ctx.lineTo(x, y);
                    }
                    ctx.closePath();
                    ctx.fill();
                    break;
            }
            ctx.globalAlpha = 1;
        }

        // Composite two patterns
        function drawCompositePattern(ctx, patternA, patternB, weightA, weightB, width, height) {
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = width;
            tempCanvas.height = height;
            const tempCtx = tempCanvas.getContext('2d');

            drawPattern(tempCtx, patternA, width, height, 1);
            const dataA = tempCtx.getImageData(0, 0, width, height);

            tempCtx.clearRect(0, 0, width, height);
            drawPattern(tempCtx, patternB, width, height, 1);
            const dataB = tempCtx.getImageData(0, 0, width, height);

            const compositeData = ctx.createImageData(width, height);
            for (let i = 0; i < dataA.data.length; i += 4) {
                compositeData.data[i] = dataA.data[i] * weightA + dataB.data[i] * weightB;
                compositeData.data[i+1] = dataA.data[i+1] * weightA + dataB.data[i+1] * weightB;
                compositeData.data[i+2] = dataA.data[i+2] * weightA + dataB.data[i+2] * weightB;
                compositeData.data[i+3] = 255;
            }

            ctx.putImageData(compositeData, 0, 0);
        }

        // VAE Encode
        async function encodeToLatent() {
            isProcessing = true;
            highlightUNetLayer('unet-input');
            
            const latentSize = Math.floor(256 / compressionFactor);
            
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = latentSize;
            tempCanvas.height = latentSize;
            const tempCtx = tempCanvas.getContext('2d');
            
            tempCtx.drawImage(originalCanvas, 0, 0, 256, 256, 0, 0, latentSize, latentSize);
            latentRepresentation = tempCtx.getImageData(0, 0, latentSize, latentSize);
            
            // Visualize latent space
            visualizeLatent(latentRepresentation);
            
            document.getElementById('latent-dims').textContent = `${latentSize}√ó${latentSize}√ó4`;
            
            await sleep(500);
            isProcessing = false;
            clearUNetHighlight();
        }

        function visualizeLatent(latentData) {
            const visualSize = 200;
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = latentData.width;
            tempCanvas.height = latentData.height;
            const tempCtx = tempCanvas.getContext('2d');
            
            // Apply a "latent space" visualization effect
            const processedData = tempCtx.createImageData(latentData.width, latentData.height);
            for (let i = 0; i < latentData.data.length; i += 4) {
                const avg = (latentData.data[i] + latentData.data[i+1] + latentData.data[i+2]) / 3;
                processedData.data[i] = avg * 0.7 + 128 * 0.3;
                processedData.data[i+1] = avg * 0.9 + 100 * 0.1;
                processedData.data[i+2] = avg * 1.1;
                processedData.data[i+3] = 255;
            }
            
            tempCtx.putImageData(processedData, 0, 0);
            latentCtx.clearRect(0, 0, visualSize, visualSize);
            latentCtx.drawImage(tempCanvas, 0, 0, latentData.width, latentData.height, 0, 0, visualSize, visualSize);
        }

        // Forward Diffusion
        async function forwardDiffusion() {
            if (!latentRepresentation) {
                await encodeToLatent();
            }
            
            isProcessing = true;
            noisyLatent = new ImageData(
                new Uint8ClampedArray(latentRepresentation.data),
                latentRepresentation.width,
                latentRepresentation.height
            );
            
            for (let t = 0; t <= timesteps; t++) {
                currentTimestep = t;
                highlightUNetLayer('unet-down');
                
                const alpha_bar_t = alphaBar[t];
                const signalCoef = Math.sqrt(alpha_bar_t);
                const noiseCoef = Math.sqrt(1 - alpha_bar_t);
                
                const data = noisyLatent.data;
                const origData = latentRepresentation.data;
                
                for (let i = 0; i < data.length; i += 4) {
                    const signal = origData[i];
                    const noise = (Math.random() - 0.5) * 255;
                    const noisy = signal * signalCoef + noise * noiseCoef;
                    
                    data[i] = noisy;
                    data[i+1] = noisy;
                    data[i+2] = noisy;
                }
                
                visualizeLatent(noisyLatent);
                updateMetrics();
                drawScheduleVisualization();
                
                if (t % 3 === 0) {
                    await sleep(40);
                }
            }
            
            isProcessing = false;
            clearUNetHighlight();
        }

        // Reverse Diffusion (U-Net denoising)
        async function reverseDiffusion() {
            if (!noisyLatent) {
                await forwardDiffusion();
            }
            
            isProcessing = true;
            const denoisedLatent = new ImageData(
                new Uint8ClampedArray(noisyLatent.data),
                noisyLatent.width,
                noisyLatent.height
            );
            
            for (let t = timesteps; t >= 0; t--) {
                currentTimestep = t;
                unetCalls++;
                
                // Animate U-Net layers
                if (unetCalls % 5 === 0) highlightUNetLayer('unet-input');
                if (unetCalls % 5 === 1) highlightUNetLayer('unet-down');
                if (unetCalls % 5 === 2) highlightUNetLayer('unet-bottleneck');
                if (unetCalls % 5 === 3) highlightUNetLayer('unet-up');
                if (unetCalls % 5 === 4) highlightUNetLayer('unet-output');
                
                const alpha_bar_t = alphaBar[t];
                const progress = 1 - (t / timesteps);
                
                // Simulate U-Net noise prediction with CFG
                const data = denoisedLatent.data;
                const origData = latentRepresentation.data;
                
                for (let i = 0; i < data.length; i += 4) {
                    const noisy = data[i];
                    const clean = origData[i];
                    
                    // Simulate CFG: unconditional + guidance * (conditional - unconditional)
                    const uncondPred = noisy;
                    const condPred = clean;
                    const guidedPred = uncondPred + (cfgScale / 10) * (condPred - uncondPred);
                    
                    const denoised = noisy * (1 - progress * 0.4) + guidedPred * progress * 0.4;
                    
                    data[i] = denoised;
                    data[i+1] = denoised;
                    data[i+2] = denoised;
                }
                
                visualizeLatent(denoisedLatent);
                updateMetrics();
                drawScheduleVisualization();
                
                if (t % 3 === 0) {
                    await sleep(40);
                }
            }
            
            noisyLatent = denoisedLatent;
            isProcessing = false;
            clearUNetHighlight();
        }

        // VAE Decode
        async function decodeFromLatent() {
            if (!noisyLatent) return;
            
            isProcessing = true;
            highlightUNetLayer('unet-output');
            
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = noisyLatent.width;
            tempCanvas.height = noisyLatent.height;
            const tempCtx = tempCanvas.getContext('2d');
            tempCtx.putImageData(noisyLatent, 0, 0);
            
            outputCtx.clearRect(0, 0, 200, 200);
            outputCtx.drawImage(tempCanvas, 0, 0, noisyLatent.width, noisyLatent.height, 0, 0, 200, 200);
            
            await sleep(500);
            isProcessing = false;
            clearUNetHighlight();
        }

        // Metrics update
        function updateMetrics() {
            document.getElementById('current-step').textContent = currentTimestep;
            
            const alpha_bar_t = alphaBar[currentTimestep] || 1;
            const snr = alpha_bar_t / (1 - alpha_bar_t);
            document.getElementById('snr').textContent = snr > 100 ? '‚àû' : snr.toFixed(1);
            
            document.getElementById('unet-calls').textContent = unetCalls;
            
            const progress = (currentTimestep / timesteps) * 100;
            document.getElementById('progress').textContent = Math.round(progress) + '%';
        }

        // Schedule visualization
        function drawScheduleVisualization() {
            const ctx = scheduleCtx;
            const width = scheduleCanvas.width;
            const height = scheduleCanvas.height;
            
            ctx.fillStyle = '#0d1117';
            ctx.fillRect(0, 0, width, height);
            
            // Grid
            ctx.strokeStyle = '#30363d';
            ctx.lineWidth = 1;
            for (let i = 0; i <= 10; i++) {
                const y = (i / 10) * height;
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(width, y);
                ctx.stroke();
            }
            
            // Noise level curve
            ctx.strokeStyle = '#f85149';
            ctx.lineWidth = 3;
            ctx.beginPath();
            for (let t = 0; t <= timesteps; t++) {
                const x = (t / timesteps) * width;
                const noiseLevel = Math.sqrt(1 - alphaBar[t]);
                const y = height - (noiseLevel * height);
                if (t === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            }
            ctx.stroke();
            
            // Signal strength curve
            ctx.strokeStyle = '#d29922';
            ctx.lineWidth = 3;
            ctx.beginPath();
            for (let t = 0; t <= timesteps; t++) {
                const x = (t / timesteps) * width;
                const signalLevel = Math.sqrt(alphaBar[t]);
                const y = height - (signalLevel * height);
                if (t === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            }
            ctx.stroke();
            
            // Forward/reverse indicators
            if (currentTimestep > 0) {
                const x = (currentTimestep / timesteps) * width;
                
                if (currentTimestep <= timesteps / 2) {
                    // Forward process
                    ctx.fillStyle = 'rgba(88, 166, 255, 0.3)';
                    ctx.fillRect(0, 0, x, height);
                } else {
                    // Reverse process
                    ctx.fillStyle = 'rgba(63, 185, 80, 0.3)';
                    ctx.fillRect(x, 0, width - x, height);
                }
                
                // Current position
                ctx.strokeStyle = '#58a6ff';
                ctx.lineWidth = 2;
                ctx.setLineDash([5, 5]);
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, height);
                ctx.stroke();
                ctx.setLineDash([]);
                
                ctx.fillStyle = '#58a6ff';
                ctx.beginPath();
                ctx.arc(x, height / 2, 6, 0, Math.PI * 2);
                ctx.fill();
            }
            
            // Labels
            ctx.fillStyle = '#8b949e';
            ctx.font = '12px Courier New';
            ctx.fillText('t=0', 10, height - 10);
            ctx.fillText(`t=${timesteps}`, width - 60, height - 10);
            ctx.fillText('Noise=0', 10, 20);
            ctx.fillText('Noise=1', 10, height / 2);
        }

        // Composition visualization
        function drawCompositionVisualization() {
            const ctx = compositionCtx;
            const width = compositionCanvas.width;
            const height = compositionCanvas.height;
            
            ctx.fillStyle = '#0d1117';
            ctx.fillRect(0, 0, width, height);
            
            const barHeight = 60;
            const barY = (height - barHeight) / 2;
            
            // Concept A bar
            const widthA = width * weightA;
            ctx.fillStyle = '#58a6ff';
            ctx.fillRect(0, barY, widthA, barHeight);
            
            // Concept B bar
            ctx.fillStyle = '#d29922';
            ctx.fillRect(widthA, barY, width * weightB, barHeight);
            
            // Labels
            ctx.fillStyle = '#fff';
            ctx.font = 'bold 14px Courier New';
            ctx.fillText(`Concept A: ${conceptA}`, 20, barY - 10);
            ctx.fillText(`${(weightA * 100).toFixed(0)}%`, 20, barY + 35);
            
            if (weightB > 0.1) {
                ctx.fillText(`Concept B: ${conceptB}`, widthA + 20, barY - 10);
                ctx.fillText(`${(weightB * 100).toFixed(0)}%`, widthA + 20, barY + 35);
            }
            
            // Interpolation visualization
            ctx.strokeStyle = '#30363d';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(0, barY + barHeight + 40);
            ctx.lineTo(width, barY + barHeight + 40);
            ctx.stroke();
            
            const interpX = widthA;
            ctx.fillStyle = '#3fb950';
            ctx.beginPath();
            ctx.arc(interpX, barY + barHeight + 40, 8, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.fillStyle = '#8b949e';
            ctx.font = '11px Courier New';
            ctx.fillText('‚Üê Pure A', 10, barY + barHeight + 65);
            ctx.fillText('Pure B ‚Üí', width - 70, barY + barHeight + 65);
            ctx.fillText('Interpolated embedding', interpX - 80, barY + barHeight + 75);
        }

        // U-Net layer highlighting
        function highlightUNetLayer(id) {
            clearUNetHighlight();
            const layer = document.getElementById(id);
            if (layer) layer.classList.add('active');
        }

        function clearUNetHighlight() {
            document.querySelectorAll('.unet-layer').forEach(l => l.classList.remove('active'));
        }

        // Full pipeline
        async function runFullPipeline() {
            if (isProcessing) return;
            reset();
            await sleep(500);
            await encodeToLatent();
            await sleep(300);
            await forwardDiffusion();
            await sleep(300);
            await reverseDiffusion();
            await sleep(300);
            await decodeFromLatent();
        }

        // Reset
        function reset() {
            currentTimestep = 0;
            unetCalls = 0;
            noisyLatent = null;
            latentRepresentation = null;
            
            drawCompositePattern(originalCtx, conceptA, conceptB, weightA, weightB, 256, 256);
            originalImageData = originalCtx.getImageData(0, 0, 256, 256);
            
            // Scale down for display
            const displayCanvas = document.createElement('canvas');
            displayCanvas.width = 200;
            displayCanvas.height = 200;
            const displayCtx = displayCanvas.getContext('2d');
            displayCtx.drawImage(originalCanvas, 0, 0, 256, 256, 0, 0, 200, 200);
            
            originalCtx.clearRect(0, 0, 256, 256);
            originalCanvas.width = 200;
            originalCanvas.height = 200;
            originalCtx.drawImage(displayCanvas, 0, 0);
            
            latentCtx.fillStyle = '#0d1117';
            latentCtx.fillRect(0, 0, 200, 200);
            
            outputCtx.fillStyle = '#0d1117';
            outputCtx.fillRect(0, 0, 200, 200);
            
            computeNoiseSchedule();
            updateMetrics();
            drawScheduleVisualization();
            drawCompositionVisualization();
        }

        // Help system
        const tooltip = document.getElementById('tooltip');
        const tooltipTitle = document.getElementById('tooltip-title');
        const tooltipContent = document.getElementById('tooltip-content');

        document.querySelectorAll('.help-icon').forEach(icon => {
            icon.addEventListener('mouseenter', (e) => {
                const helpKey = e.target.dataset.help || e.target.id;
                const content = helpContent[helpKey];
                
                if (content) {
                    tooltipTitle.textContent = content.title;
                    tooltipContent.innerHTML = content.content;
                    
                    if (content.formula) {
                        tooltipContent.innerHTML += `<div class="tooltip-formula">${content.formula}</div>`;
                    }
                    
                    tooltip.classList.add('active');
                    positionTooltip(e.target);
                }
            });
            
            icon.addEventListener('mouseleave', () => {
                tooltip.classList.remove('active');
            });
        });

        function positionTooltip(element) {
            const rect = element.getBoundingClientRect();
            tooltip.style.left = (rect.right + 10) + 'px';
            tooltip.style.top = rect.top + 'px';
        }

        // Event listeners
        document.getElementById('concept-a').addEventListener('change', (e) => {
            conceptA = e.target.value;
            reset();
        });

        document.getElementById('concept-b').addEventListener('change', (e) => {
            conceptB = e.target.value;
            reset();
        });

        document.getElementById('weight-a').addEventListener('input', (e) => {
            weightA = parseInt(e.target.value) / 100;
            weightB = 1 - weightA;
            document.getElementById('weight-a-value').textContent = `Weight: ${weightA.toFixed(2)}`;
            document.getElementById('weight-b-value').textContent = `Weight: ${weightB.toFixed(2)}`;
            document.getElementById('weight-b').value = Math.round(weightB * 100);
            reset();
        });

        document.getElementById('weight-b').addEventListener('input', (e) => {
            weightB = parseInt(e.target.value) / 100;
            weightA = 1 - weightB;
            document.getElementById('weight-b-value').textContent = `Weight: ${weightB.toFixed(2)}`;
            document.getElementById('weight-a-value').textContent = `Weight: ${weightA.toFixed(2)}`;
            document.getElementById('weight-a').value = Math.round(weightA * 100);
            reset();
        });

        document.getElementById('timesteps-slider').addEventListener('input', (e) => {
            timesteps = parseInt(e.target.value);
            document.getElementById('timesteps-value').textContent = `T = ${timesteps} steps`;
            computeNoiseSchedule();
            drawScheduleVisualization();
        });

        document.getElementById('compression-slider').addEventListener('input', (e) => {
            const factor = parseInt(e.target.value);
            compressionFactor = Math.pow(2, factor);
            const latentDim = Math.floor(256 / compressionFactor);
            document.getElementById('compression-value').textContent = `${compressionFactor}x (256‚Üí${latentDim})`;
        });

        document.getElementById('beta-slider').addEventListener('input', (e) => {
            const val = parseInt(e.target.value);
            betaMin = val * 0.00002;
            betaMax = val * 0.004;
            document.getElementById('beta-value').textContent = `Œ≤ = ${betaMax.toFixed(4)} (linear)`;
            computeNoiseSchedule();
            drawScheduleVisualization();
        });

        document.getElementById('cfg-slider').addEventListener('input', (e) => {
            cfgScale = parseInt(e.target.value) / 10;
            document.getElementById('cfg-value').textContent = `w = ${cfgScale.toFixed(1)}`;
        });

        document.getElementById('full-pipeline-btn').addEventListener('click', runFullPipeline);
        document.getElementById('encode-btn').addEventListener('click', encodeToLatent);
        document.getElementById('forward-btn').addEventListener('click', forwardDiffusion);
        document.getElementById('reverse-btn').addEventListener('click', reverseDiffusion);
        document.getElementById('decode-btn').addEventListener('click', decodeFromLatent);
        document.getElementById('reset-btn').addEventListener('click', reset);

        function sleep(ms) {
            return new Promise(resolve => setTimeout(resolve, ms));
        }

        // Initialize
        reset();
    </script>
</body>
</html>
