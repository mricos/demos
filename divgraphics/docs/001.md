Excellent question. Let's diagnose why this slipped through:

  Root Cause Analysis

  The bug: State was persisted (midi.device) but nothing restored it on
  reload.

  Why it happened:
  1. Incomplete state - We stored device: "name" but needed device: { id, 
  name } to reconnect
  2. No restore phase - Modules subscribe to changes but don't hydrate from
  existing state
  3. Scattered UI updates - Connection status is set imperatively in
  multiple places, not derived from state

  The Pattern Gap

  Current pattern:
  APP.Module = {
      init() {
          APP.PState.subscribe('foo.*', handleChange);  // â† Only handles 
  FUTURE changes
          // Initial state? Ignored.
      }
  }

  Missing: Modules don't reconcile with existing state on init.

  Proposed Fix: Module Lifecycle

  Each module should follow:

  APP.Module = {
      init() {
          // 1. RESTORE from current state
          this._restoreFromState();

          // 2. SUBSCRIBE to future changes
          APP.PState.subscribe('foo.*', () => this._onStateChange());
      },

      _restoreFromState() {
          const state = APP.PState.select('foo');
          // Restore runtime from persisted state
      }
  }

  Deeper Issue: Dual State

  The MIDI module has two sources of truth:
  - APP.MIDI.activeInput (runtime - lost on reload)
  - APP.PState.state.midi.device (persisted - survives reload)

  These diverge on reload. The fix we just made reconnects them, but the
  architecture allowed them to diverge.

  Better pattern: Runtime state should be derived from, or synced with,
  persisted state:

  // Instead of checking APP.MIDI.activeInput
  // Derive connection status from state
  get isConnected() {
      return APP.PState.select('midi.device') !== null && this.activeInput
  !== null;
  }

  Should I refactor the modules to have explicit _restoreFromState() methods
   in their init() calls? This would make the pattern consistent and prevent
   similar bugs in future modules.
