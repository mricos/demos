<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DivGraphics - 3D Tube</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            min-height: 100vh;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #0f3460 100%);
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            color: #fff;
            overflow: hidden;
        }

        .app-container {
            display: flex;
            flex-direction: column;
            height: 100vh;
        }

        header {
            padding: 20px 40px;
            background: rgba(0, 0, 0, 0.3);
            backdrop-filter: blur(10px);
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        header h1 {
            font-size: 1.8rem;
            font-weight: 300;
            letter-spacing: 2px;
        }

        header h1 span {
            color: #00d4ff;
            font-weight: 600;
        }

        .main-content {
            flex: 1;
            display: flex;
        }

        .viewport {
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            perspective: 1200px;
            perspective-origin: center center;
        }

        .scene {
            position: relative;
            transform-style: preserve-3d;
            transition: transform 0.05s linear;
        }

        .controls {
            width: 320px;
            padding: 30px;
            background: rgba(0, 0, 0, 0.4);
            backdrop-filter: blur(10px);
            border-left: 1px solid rgba(255, 255, 255, 0.1);
            overflow-y: auto;
        }

        .control-group {
            margin-bottom: 25px;
        }

        .control-group label {
            display: block;
            margin-bottom: 8px;
            font-size: 0.85rem;
            color: rgba(255, 255, 255, 0.7);
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .control-group input[type="range"] {
            width: 100%;
            height: 6px;
            -webkit-appearance: none;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 3px;
            outline: none;
        }

        .control-group input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 18px;
            height: 18px;
            background: #00d4ff;
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 0 10px rgba(0, 212, 255, 0.5);
        }

        .control-group input[type="color"] {
            width: 100%;
            height: 40px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            background: transparent;
        }

        .control-value {
            text-align: right;
            font-size: 0.9rem;
            color: #00d4ff;
            margin-top: 5px;
        }

        .checkbox-group {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .checkbox-group input[type="checkbox"] {
            width: 20px;
            height: 20px;
            accent-color: #00d4ff;
        }

        .btn {
            width: 100%;
            padding: 12px 20px;
            background: linear-gradient(135deg, #00d4ff, #0099cc);
            border: none;
            border-radius: 6px;
            color: #fff;
            font-size: 0.9rem;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 1px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 20px rgba(0, 212, 255, 0.4);
        }

        .stats {
            margin-top: 30px;
            padding: 15px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 8px;
        }

        .stats h3 {
            font-size: 0.8rem;
            color: rgba(255, 255, 255, 0.5);
            margin-bottom: 10px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .stat-item {
            display: flex;
            justify-content: space-between;
            padding: 5px 0;
            font-size: 0.9rem;
        }

        .stat-item span:last-child {
            color: #00d4ff;
        }

        /* Tube segment styling */
        .tube-segment {
            position: absolute;
            transform-style: preserve-3d;
            backface-visibility: visible;
        }

        .tube-ring {
            position: absolute;
            transform-style: preserve-3d;
        }

        .tube-face {
            position: absolute;
            transform-origin: center center;
            backface-visibility: visible;
        }

        .instructions {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.5);
            padding: 10px 20px;
            border-radius: 20px;
            font-size: 0.85rem;
            color: rgba(255, 255, 255, 0.7);
        }
    </style>
</head>
<body>
    <div class="app-container">
        <header>
            <h1><span>Div</span>Graphics</h1>
        </header>

        <div class="main-content">
            <div class="viewport" id="viewport">
                <div class="scene" id="scene"></div>
            </div>

            <div class="controls">
                <div class="control-group">
                    <label>Radius</label>
                    <input type="range" id="radius" min="30" max="150" value="80">
                    <div class="control-value" id="radiusValue">80</div>
                </div>

                <div class="control-group">
                    <label>Height</label>
                    <input type="range" id="height" min="50" max="400" value="200">
                    <div class="control-value" id="heightValue">200</div>
                </div>

                <div class="control-group">
                    <label>Segments (Radial)</label>
                    <input type="range" id="radialSegments" min="6" max="48" value="24">
                    <div class="control-value" id="radialSegmentsValue">24</div>
                </div>

                <div class="control-group">
                    <label>Segments (Height)</label>
                    <input type="range" id="heightSegments" min="1" max="20" value="8">
                    <div class="control-value" id="heightSegmentsValue">8</div>
                </div>

                <div class="control-group">
                    <label>Inner Radius (Hollow)</label>
                    <input type="range" id="innerRadius" min="0" max="140" value="50">
                    <div class="control-value" id="innerRadiusValue">50</div>
                </div>

                <div class="control-group">
                    <label>Primary Color</label>
                    <input type="color" id="color" value="#00d4ff">
                </div>

                <div class="control-group">
                    <label>Secondary Color</label>
                    <input type="color" id="colorSecondary" value="#ff00aa">
                </div>

                <div class="control-group checkbox-group">
                    <input type="checkbox" id="wireframe">
                    <label style="margin: 0;">Wireframe Mode</label>
                </div>

                <div class="control-group checkbox-group">
                    <input type="checkbox" id="autoRotate" checked>
                    <label style="margin: 0;">Auto Rotate</label>
                </div>

                <div class="control-group checkbox-group">
                    <input type="checkbox" id="showCaps" checked>
                    <label style="margin: 0;">Show End Caps</label>
                </div>

                <button class="btn" id="resetBtn">Reset View</button>

                <div class="stats">
                    <h3>Statistics</h3>
                    <div class="stat-item">
                        <span>Total Divs:</span>
                        <span id="statDivs">0</span>
                    </div>
                    <div class="stat-item">
                        <span>Faces:</span>
                        <span id="statFaces">0</span>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div class="instructions">
        Click and drag to rotate â€¢ Scroll to zoom
    </div>

    <script>
        /**
         * DivGraphics Library
         * A 3D rendering library using CSS transforms and div elements
         */
        const DivGraphics = (function() {
            
            // Utility functions
            const utils = {
                degToRad: (deg) => deg * Math.PI / 180,
                radToDeg: (rad) => rad * 180 / Math.PI,
                
                parseColor: (color) => {
                    // Handle hex format
                    const hexResult = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(color);
                    if (hexResult) {
                        return {
                            r: parseInt(hexResult[1], 16),
                            g: parseInt(hexResult[2], 16),
                            b: parseInt(hexResult[3], 16)
                        };
                    }
                    
                    // Handle rgb format
                    const rgbResult = /^rgb\((\d+),\s*(\d+),\s*(\d+)\)$/i.exec(color);
                    if (rgbResult) {
                        return {
                            r: parseInt(rgbResult[1], 10),
                            g: parseInt(rgbResult[2], 10),
                            b: parseInt(rgbResult[3], 10)
                        };
                    }
                    
                    // Fallback to white
                    return { r: 255, g: 255, b: 255 };
                },

                lerpColor: (color1, color2, t) => {
                    const c1 = utils.parseColor(color1);
                    const c2 = utils.parseColor(color2);
                    return `rgb(${Math.round(c1.r + (c2.r - c1.r) * t)}, ${Math.round(c1.g + (c2.g - c1.g) * t)}, ${Math.round(c1.b + (c2.b - c1.b) * t)})`;
                }
            };

            /**
             * Tube Geometry Class
             * Creates a cylindrical tube using div elements
             */
            class Tube {
                constructor(options = {}) {
                    this.radius = options.radius || 80;
                    this.innerRadius = options.innerRadius || 0;
                    this.height = options.height || 200;
                    this.radialSegments = options.radialSegments || 24;
                    this.heightSegments = options.heightSegments || 8;
                    this.color = options.color || '#00d4ff';
                    this.colorSecondary = options.colorSecondary || '#ff00aa';
                    this.wireframe = options.wireframe || false;
                    this.showCaps = options.showCaps !== undefined ? options.showCaps : true;
                    
                    this.container = null;
                    this.faces = [];
                    this.divCount = 0;
                }

                /**
                 * Generate the tube geometry and return a DOM element
                 */
                generate() {
                    this.container = document.createElement('div');
                    this.container.className = 'tube-geometry';
                    this.container.style.cssText = `
                        position: relative;
                        transform-style: preserve-3d;
                    `;

                    this.faces = [];
                    this.divCount = 0;

                    // Generate outer surface
                    this._generateCylinderSurface(this.radius, false);

                    // Generate inner surface if hollow
                    if (this.innerRadius > 0 && this.innerRadius < this.radius) {
                        this._generateCylinderSurface(this.innerRadius, true);
                    }

                    // Generate end caps
                    if (this.showCaps) {
                        this._generateCaps();
                    }

                    return this.container;
                }

                /**
                 * Generate cylindrical surface
                 */
                _generateCylinderSurface(radius, isInner) {
                    const segmentAngle = (2 * Math.PI) / this.radialSegments;
                    const segmentHeight = this.height / this.heightSegments;
                    
                    // Calculate face width using chord length
                    const faceWidth = 2 * radius * Math.sin(segmentAngle / 2);

                    for (let h = 0; h < this.heightSegments; h++) {
                        const ring = document.createElement('div');
                        ring.className = 'tube-ring';
                        ring.style.cssText = `
                            position: absolute;
                            transform-style: preserve-3d;
                            transform: translateY(${h * segmentHeight - this.height / 2}px);
                        `;

                        for (let r = 0; r < this.radialSegments; r++) {
                            const angle = r * segmentAngle;
                            
                            // Position at center of segment
                            const x = radius * Math.cos(angle + segmentAngle / 2);
                            const z = radius * Math.sin(angle + segmentAngle / 2);
                            
                            // Rotation to face outward (or inward for inner surface)
                            const rotationY = utils.radToDeg(angle + segmentAngle / 2) + (isInner ? 180 : 0);

                            // Color gradient based on height and angle
                            const heightT = h / this.heightSegments;
                            const angleT = r / this.radialSegments;
                            
                            const face = this._createFace({
                                width: faceWidth + 0.5, // Slight overlap to prevent gaps
                                height: segmentHeight + 0.5,
                                x: x,
                                y: segmentHeight / 2,
                                z: z,
                                rotationY: rotationY,
                                color: utils.lerpColor(this.color, this.colorSecondary, (heightT + angleT) / 2),
                                opacity: isInner ? 0.7 : 0.85
                            });

                            ring.appendChild(face);
                            this.faces.push(face);
                            this.divCount++;
                        }

                        this.container.appendChild(ring);
                        this.divCount++;
                    }
                }

                /**
                 * Generate end caps (top and bottom)
                 */
                _generateCaps() {
                    const segmentAngle = (2 * Math.PI) / this.radialSegments;
                    
                    ['top', 'bottom'].forEach((position) => {
                        const isTop = position === 'top';
                        const yOffset = isTop ? this.height / 2 : -this.height / 2;
                        
                        const cap = document.createElement('div');
                        cap.className = 'tube-cap';
                        cap.style.cssText = `
                            position: absolute;
                            transform-style: preserve-3d;
                            transform: translateY(${yOffset}px) rotateX(${isTop ? 0 : 180}deg);
                        `;

                        if (this.innerRadius > 0) {
                            // Ring cap (donut shape)
                            for (let r = 0; r < this.radialSegments; r++) {
                                const angle1 = r * segmentAngle;
                                const angle2 = (r + 1) * segmentAngle;
                                
                                // Create trapezoid-like segment
                                const segment = this._createCapSegment(
                                    this.innerRadius, 
                                    this.radius, 
                                    angle1, 
                                    angle2,
                                    isTop
                                );
                                
                                cap.appendChild(segment);
                                this.divCount++;
                            }
                        } else {
                            // Solid cap (pie slices)
                            for (let r = 0; r < this.radialSegments; r++) {
                                const angle = r * segmentAngle;
                                const midAngle = angle + segmentAngle / 2;
                                
                                const sliceWidth = 2 * this.radius * Math.sin(segmentAngle / 2);
                                const sliceHeight = this.radius;
                                
                                const slice = document.createElement('div');
                                slice.className = 'tube-face cap-slice';
                                
                                const gradientT = r / this.radialSegments;
                                
                                slice.style.cssText = `
                                    position: absolute;
                                    width: ${sliceWidth}px;
                                    height: ${sliceHeight}px;
                                    transform-origin: center bottom;
                                    transform: rotateZ(${utils.radToDeg(midAngle) - 90}deg) translateY(${-sliceHeight / 2}px);
                                    ${this.wireframe 
                                        ? `border: 1px solid ${this.color}; background: transparent;`
                                        : `background: linear-gradient(to top, ${utils.lerpColor(this.color, this.colorSecondary, gradientT)}, ${utils.lerpColor(this.colorSecondary, this.color, gradientT)});`
                                    }
                                    opacity: 0.7;
                                    clip-path: polygon(50% 100%, 0% 0%, 100% 0%);
                                `;
                                
                                cap.appendChild(slice);
                                this.divCount++;
                            }
                        }

                        this.container.appendChild(cap);
                        this.divCount++;
                    });
                }

                /**
                 * Create a cap segment (for hollow tubes)
                 */
                _createCapSegment(innerR, outerR, angle1, angle2, isTop) {
                    const segment = document.createElement('div');
                    segment.className = 'tube-face cap-segment';
                    
                    const midAngle = (angle1 + angle2) / 2;
                    const avgR = (innerR + outerR) / 2;
                    
                    const width = 2 * outerR * Math.sin((angle2 - angle1) / 2);
                    const depth = outerR - innerR;
                    
                    const x = avgR * Math.cos(midAngle);
                    const z = avgR * Math.sin(midAngle);
                    
                    const gradientT = midAngle / (2 * Math.PI);
                    
                    segment.style.cssText = `
                        position: absolute;
                        width: ${width + 1}px;
                        height: ${depth + 1}px;
                        transform-origin: center center;
                        transform: translate3d(${x - width/2}px, ${-depth/2}px, ${z}px) rotateX(-90deg) rotateZ(${utils.radToDeg(midAngle) + 90}deg);
                        ${this.wireframe 
                            ? `border: 1px solid ${this.color}; background: transparent;`
                            : `background: ${utils.lerpColor(this.color, this.colorSecondary, gradientT)};`
                        }
                        opacity: 0.6;
                    `;
                    
                    return segment;
                }

                /**
                 * Create a single face element
                 */
                _createFace(options) {
                    const face = document.createElement('div');
                    face.className = 'tube-face';
                    
                    face.style.cssText = `
                        position: absolute;
                        width: ${options.width}px;
                        height: ${options.height}px;
                        transform: translate3d(${options.x - options.width/2}px, ${options.y - options.height/2}px, ${options.z}px) rotateY(${options.rotationY}deg);
                        ${this.wireframe 
                            ? `border: 1px solid ${options.color}; background: transparent;`
                            : `background: linear-gradient(180deg, ${options.color}, ${utils.lerpColor(options.color, '#000', 0.3)});`
                        }
                        opacity: ${options.opacity || 0.85};
                        box-shadow: ${this.wireframe ? 'none' : `inset 0 0 20px rgba(255,255,255,0.1)`};
                    `;
                    
                    return face;
                }

                /**
                 * Update tube with new options
                 */
                update(options) {
                    Object.assign(this, options);
                    if (this.container && this.container.parentNode) {
                        const parent = this.container.parentNode;
                        parent.removeChild(this.container);
                        parent.appendChild(this.generate());
                    }
                }

                /**
                 * Get stats about the geometry
                 */
                getStats() {
                    return {
                        divCount: this.divCount,
                        faceCount: this.faces.length
                    };
                }
            }

            /**
             * Scene Class
             * Manages the 3D scene and interactions
             */
            class Scene {
                constructor(containerEl, viewportEl) {
                    this.container = containerEl;
                    this.viewport = viewportEl;
                    this.objects = [];
                    
                    this.rotation = { x: -20, y: 0 };
                    this.targetRotation = { x: -20, y: 0 };
                    this.zoom = 1;
                    
                    this.isDragging = false;
                    this.lastMouse = { x: 0, y: 0 };
                    this.autoRotate = true;
                    
                    this._initInteraction();
                    this._animate();
                }

                add(object) {
                    const element = object.generate();
                    this.container.appendChild(element);
                    this.objects.push(object);
                    return object;
                }

                clear() {
                    this.container.innerHTML = '';
                    this.objects = [];
                }

                _initInteraction() {
                    // Mouse drag rotation
                    this.viewport.addEventListener('mousedown', (e) => {
                        this.isDragging = true;
                        this.lastMouse = { x: e.clientX, y: e.clientY };
                    });

                    window.addEventListener('mousemove', (e) => {
                        if (!this.isDragging) return;
                        
                        const dx = e.clientX - this.lastMouse.x;
                        const dy = e.clientY - this.lastMouse.y;
                        
                        this.targetRotation.y += dx * 0.5;
                        this.targetRotation.x += dy * 0.5;
                        this.targetRotation.x = Math.max(-90, Math.min(90, this.targetRotation.x));
                        
                        this.lastMouse = { x: e.clientX, y: e.clientY };
                    });

                    window.addEventListener('mouseup', () => {
                        this.isDragging = false;
                    });

                    // Touch support
                    this.viewport.addEventListener('touchstart', (e) => {
                        this.isDragging = true;
                        this.lastMouse = { x: e.touches[0].clientX, y: e.touches[0].clientY };
                    });

                    this.viewport.addEventListener('touchmove', (e) => {
                        if (!this.isDragging) return;
                        
                        const dx = e.touches[0].clientX - this.lastMouse.x;
                        const dy = e.touches[0].clientY - this.lastMouse.y;
                        
                        this.targetRotation.y += dx * 0.5;
                        this.targetRotation.x += dy * 0.5;
                        this.targetRotation.x = Math.max(-90, Math.min(90, this.targetRotation.x));
                        
                        this.lastMouse = { x: e.touches[0].clientX, y: e.touches[0].clientY };
                    });

                    this.viewport.addEventListener('touchend', () => {
                        this.isDragging = false;
                    });

                    // Scroll zoom
                    this.viewport.addEventListener('wheel', (e) => {
                        e.preventDefault();
                        this.zoom += e.deltaY * -0.001;
                        this.zoom = Math.max(0.3, Math.min(2.5, this.zoom));
                    });
                }

                _animate() {
                    // Auto rotation
                    if (this.autoRotate && !this.isDragging) {
                        this.targetRotation.y += 0.3;
                    }

                    // Smooth interpolation
                    this.rotation.x += (this.targetRotation.x - this.rotation.x) * 0.1;
                    this.rotation.y += (this.targetRotation.y - this.rotation.y) * 0.1;

                    // Apply transform
                    this.container.style.transform = `
                        scale(${this.zoom})
                        rotateX(${this.rotation.x}deg)
                        rotateY(${this.rotation.y}deg)
                    `;

                    requestAnimationFrame(() => this._animate());
                }

                resetView() {
                    this.targetRotation = { x: -20, y: 0 };
                    this.zoom = 1;
                }
            }

            // Public API
            return {
                Tube,
                Scene,
                utils
            };
        })();

        // Application
        (function() {
            const scene = new DivGraphics.Scene(
                document.getElementById('scene'),
                document.getElementById('viewport')
            );

            let tube = new DivGraphics.Tube({
                radius: 80,
                innerRadius: 50,
                height: 200,
                radialSegments: 24,
                heightSegments: 8,
                color: '#00d4ff',
                colorSecondary: '#ff00aa',
                wireframe: false,
                showCaps: true
            });

            scene.add(tube);
            updateStats();

            // Control bindings
            const controls = {
                radius: document.getElementById('radius'),
                height: document.getElementById('height'),
                radialSegments: document.getElementById('radialSegments'),
                heightSegments: document.getElementById('heightSegments'),
                innerRadius: document.getElementById('innerRadius'),
                color: document.getElementById('color'),
                colorSecondary: document.getElementById('colorSecondary'),
                wireframe: document.getElementById('wireframe'),
                autoRotate: document.getElementById('autoRotate'),
                showCaps: document.getElementById('showCaps'),
                resetBtn: document.getElementById('resetBtn')
            };

            function rebuildTube() {
                scene.clear();
                tube = new DivGraphics.Tube({
                    radius: parseInt(controls.radius.value),
                    innerRadius: parseInt(controls.innerRadius.value),
                    height: parseInt(controls.height.value),
                    radialSegments: parseInt(controls.radialSegments.value),
                    heightSegments: parseInt(controls.heightSegments.value),
                    color: controls.color.value,
                    colorSecondary: controls.colorSecondary.value,
                    wireframe: controls.wireframe.checked,
                    showCaps: controls.showCaps.checked
                });
                scene.add(tube);
                updateStats();
            }

            function updateStats() {
                const stats = tube.getStats();
                document.getElementById('statDivs').textContent = stats.divCount;
                document.getElementById('statFaces').textContent = stats.faceCount;
            }

            // Slider controls
            ['radius', 'height', 'radialSegments', 'heightSegments', 'innerRadius'].forEach(id => {
                controls[id].addEventListener('input', function() {
                    document.getElementById(id + 'Value').textContent = this.value;
                    rebuildTube();
                });
            });

            // Color controls
            controls.color.addEventListener('input', rebuildTube);
            controls.colorSecondary.addEventListener('input', rebuildTube);

            // Checkbox controls
            controls.wireframe.addEventListener('change', rebuildTube);
            controls.showCaps.addEventListener('change', rebuildTube);
            controls.autoRotate.addEventListener('change', function() {
                scene.autoRotate = this.checked;
            });

            // Reset button
            controls.resetBtn.addEventListener('click', () => {
                scene.resetView();
            });
        })();
    </script>
</body>
</html>
