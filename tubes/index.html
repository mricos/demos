<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cylinder - 3D Stroke Drawing</title>
    <style>
        /* Design Tokens */
        :root {
            --font-family-sans: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            --font-family-mono: 'SF Mono', 'Monaco', 'Fira Code', 'Consolas', monospace;
            --font-size-xs: 0.8rem;
            --font-size-sm: 0.85rem;
            --font-size-base: 1rem;
            --font-size-md: 1.1rem;
            --font-size-lg: 1.25rem;
            --font-weight-normal: 400;
            --font-weight-medium: 500;
            --font-weight-semibold: 600;
            --font-weight-bold: 700;
            --line-height-tight: 1.25;
            --line-height-normal: 1.5;
            --line-height-relaxed: 1.625;
            --space-1: 0.25rem;
            --space-2: 0.5rem;
            --space-3: 0.75rem;
            --space-4: 1rem;
            --space-5: 1.25rem;
            --space-6: 1.5rem;
            --space-8: 2rem;
            --radius-sm: 0.125rem;
            --radius-base: 0.25rem;
            --radius-md: 0.375rem;
            --radius-lg: 0.5rem;
            --shadow-sm: 0 2px 4px rgba(0, 0, 0, 0.2);
            --shadow-md: 0 4px 8px rgba(0, 0, 0, 0.25);
            --duration-fast: 100ms;
            --duration-normal: 200ms;
            --duration-slow: 300ms;
            --ease-out: cubic-bezier(0, 0, 0.2, 1);
            --bg-primary: #1a1a2e;
            --bg-secondary: #16213e;
            --bg-tertiary: #0d1b2a;
            --bg-hover: rgba(233, 69, 96, 0.05);
            --bg-active: rgba(233, 69, 96, 0.10);
            --text-title: #eaeaea;
            --text-primary: #c0c0d0;
            --text-secondary: #8a8aa0;
            --text-code: #ff6b6b;
            --accent-primary: #e94560;
            --accent-secondary: #3b82c4;
            --success: #4ade80;
            --warning: #fbbf24;
            --error: #f87171;
            --border: #2a2a4a;
            --border-subtle: #1e2a4a;
            --highlight: rgba(233, 69, 96, 0.15);
        }
        
        *, *::before, *::after {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: var(--font-family-sans);
            font-size: var(--font-size-base);
            line-height: var(--line-height-relaxed);
            overflow: hidden;
            background: var(--bg-primary);
            color: var(--text-primary);
        }
        
        /* Scrollbar Styling */
        ::-webkit-scrollbar {
            width: 10px;
            height: 10px;
        }
        
        ::-webkit-scrollbar-track {
            background: var(--bg-secondary);
            border-radius: 5px;
        }
        
        ::-webkit-scrollbar-thumb {
            background: #3a3a5a;
            border-radius: 5px;
            border: 2px solid var(--bg-secondary);
        }
        
        ::-webkit-scrollbar-thumb:hover {
            background: #5a5a7a;
        }
        
        * {
            scrollbar-width: thin;
            scrollbar-color: #3a3a5a var(--bg-secondary);
        }
        
        /* Layout */
        #app {
            width: 100vw;
            height: 100vh;
            position: relative;
        }
        
        #canvas-container {
            width: 100%;
            height: 100%;
            position: relative;
        }
        
        #drawing-canvas {
            position: absolute;
            top: 0;
            left: 0;
            z-index: 10;
            cursor: crosshair;
        }
        
        #renderer-canvas {
            position: absolute;
            top: 0;
            left: 0;
            z-index: 1;
        }
        
        /* Side Panel */
        #side-panel {
            position: absolute;
            right: 0;
            top: 0;
            width: 340px;
            height: 100%;
            background: var(--bg-secondary);
            transform: translateX(0);
            transition: transform var(--duration-slow) var(--ease-out);
            z-index: 100;
            overflow-y: auto;
            border-left: 1px solid var(--border);
            display: flex;
            flex-direction: column;
        }
        
        #side-panel.hidden {
            transform: translateX(340px);
        }
        
        /* Side Panel Menu */
        .panel-menu {
            background: var(--bg-tertiary);
            border-bottom: 1px solid var(--border);
            padding: var(--space-2) var(--space-3);
            display: flex;
            gap: var(--space-2);
            flex-wrap: wrap;
        }
        
        .menu-button {
            padding: var(--space-2) var(--space-3);
            background: var(--bg-secondary);
            border: 1px solid var(--border);
            border-radius: var(--radius-md);
            color: var(--text-primary);
            font-size: var(--font-size-xs);
            font-weight: var(--font-weight-medium);
            cursor: pointer;
            transition: all var(--duration-normal);
            font-family: var(--font-family-sans);
            display: flex;
            align-items: center;
            gap: var(--space-1);
        }
        
        .menu-button:hover {
            background: var(--bg-hover);
            border-color: var(--accent-primary);
            color: var(--text-title);
        }
        
        .menu-button:active {
            transform: scale(0.95);
        }
        
        .menu-button.active {
            background: var(--accent-primary);
            border-color: var(--accent-primary);
            color: var(--text-title);
        }
        
        .menu-icon {
            font-size: var(--font-size-sm);
        }
        
        #panel-toggle {
            position: absolute;
            left: -40px;
            top: var(--space-5);
            width: 40px;
            height: 40px;
            background: var(--bg-secondary);
            border: 1px solid var(--border);
            border-right: none;
            border-radius: var(--radius-lg) 0 0 var(--radius-lg);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 20px;
            color: var(--text-title);
            transition: background var(--duration-normal);
        }
        
        #panel-toggle:hover {
            background: var(--bg-hover);
        }
        
        /* Panel Container */
        .panels-container {
            flex: 1;
            padding: var(--space-4);
            display: flex;
            flex-direction: column;
            gap: var(--space-3);
        }
        
        /* Panel */
        .panel {
            background: var(--bg-tertiary);
            border: 1px solid var(--border);
            border-radius: var(--radius-lg);
            overflow: hidden;
            transition: box-shadow var(--duration-normal);
        }
        
        .panel.dragging {
            opacity: 0.5;
            box-shadow: var(--shadow-md);
        }
        
        .panel.drag-over {
            border-color: var(--accent-primary);
            box-shadow: 0 0 0 2px var(--highlight);
        }
        
        /* Panel Header */
        .panel-header {
            padding: var(--space-3) var(--space-4);
            background: var(--bg-secondary);
            border-bottom: 1px solid var(--border);
            display: flex;
            align-items: center;
            gap: var(--space-2);
            user-select: none;
            cursor: grab;
            transition: background var(--duration-fast);
        }
        
        .panel-header:hover {
            background: var(--bg-hover);
        }
        
        .panel-header:active {
            cursor: grabbing;
        }
        
        .panel-title {
            flex: 1;
            font-size: var(--font-size-sm);
            font-weight: var(--font-weight-semibold);
            text-transform: uppercase;
            letter-spacing: 0.5px;
            color: var(--text-title);
        }
        
        .panel-collapse-btn {
            background: none;
            border: none;
            color: var(--text-secondary);
            cursor: pointer;
            padding: var(--space-1);
            display: flex;
            align-items: center;
            justify-content: center;
            transition: color var(--duration-fast), transform var(--duration-normal);
            font-size: var(--font-size-md);
            flex-shrink: 0;
        }
        
        .panel-collapse-btn:hover {
            color: var(--text-title);
        }
        
        .panel-collapse-btn.collapsed {
            transform: rotate(-90deg);
        }
        
        /* Panel Body */
        .panel-body {
            padding: var(--space-4);
            display: flex;
            flex-direction: column;
            gap: var(--space-4);
            max-height: 500px;
            overflow-y: auto;
            transition: max-height var(--duration-slow) var(--ease-out);
        }
        
        .panel-body.collapsed {
            max-height: 0;
            padding: 0;
            overflow: hidden;
        }
        
        /* Sub Panel */
        .sub-panel {
            background: var(--bg-secondary);
            border: 1px solid var(--border-subtle);
            border-radius: var(--radius-md);
            overflow: hidden;
        }
        
        .sub-panel.dragging {
            opacity: 0.5;
        }
        
        .sub-panel.drag-over {
            border-color: var(--accent-secondary);
            box-shadow: 0 0 0 1px var(--accent-secondary);
        }
        
        .sub-panel-header {
            padding: var(--space-2) var(--space-3);
            background: rgba(0, 0, 0, 0.2);
            display: flex;
            align-items: center;
            gap: var(--space-2);
            user-select: none;
            cursor: grab;
            transition: background var(--duration-fast);
        }
        
        .sub-panel-header:hover {
            background: rgba(0, 0, 0, 0.3);
        }
        
        .sub-panel-header:active {
            cursor: grabbing;
        }
        
        .sub-panel-title {
            flex: 1;
            font-size: var(--font-size-xs);
            font-weight: var(--font-weight-medium);
            color: var(--text-secondary);
        }
        
        .sub-panel-collapse-btn {
            background: none;
            border: none;
            color: var(--text-secondary);
            cursor: pointer;
            padding: var(--space-1);
            display: flex;
            align-items: center;
            justify-content: center;
            transition: color var(--duration-fast), transform var(--duration-normal);
            font-size: var(--font-size-sm);
            flex-shrink: 0;
        }
        
        .sub-panel-collapse-btn:hover {
            color: var(--text-title);
        }
        
        .sub-panel-collapse-btn.collapsed {
            transform: rotate(-90deg);
        }
        
        .sub-panel-body {
            padding: var(--space-3);
            display: flex;
            flex-direction: column;
            gap: var(--space-3);
            transition: max-height var(--duration-slow) var(--ease-out);
        }
        
        .sub-panel-body.collapsed {
            max-height: 0;
            padding: 0;
            overflow: hidden;
        }
        
        /* Control Group */
        .control-group {
            display: flex;
            flex-direction: column;
            gap: var(--space-2);
        }
        
        .control-group.compact {
            gap: var(--space-1);
        }
        
        .control-label {
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: var(--font-size-xs);
            color: var(--text-secondary);
        }
        
        .control-label.compact {
            font-size: 10px;
            line-height: 1.2;
        }
        
        .control-value {
            font-size: var(--font-size-xs);
            color: var(--accent-primary);
            font-weight: var(--font-weight-semibold);
            font-family: var(--font-family-mono);
        }
        
        .control-value.compact {
            font-size: 9px;
        }
        
        /* Compact Range Input */
        input[type="range"].compact {
            height: 3px;
        }
        
        input[type="range"].compact::-webkit-slider-thumb {
            width: 12px;
            height: 12px;
        }
        
        input[type="range"].compact::-moz-range-thumb {
            width: 12px;
            height: 12px;
        }
        
        /* Group Manager */
        .group-list {
            display: flex;
            flex-direction: column;
            gap: var(--space-2);
            max-height: 200px;
            overflow-y: auto;
        }
        
        .group-item {
            padding: var(--space-2) var(--space-3);
            background: var(--bg-primary);
            border: 1px solid var(--border);
            border-radius: var(--radius-md);
            display: flex;
            align-items: center;
            gap: var(--space-2);
            cursor: pointer;
            transition: all var(--duration-normal);
        }
        
        .group-item:hover {
            background: var(--bg-hover);
            border-color: var(--accent-primary);
        }
        
        .group-item.selected {
            background: var(--highlight);
            border-color: var(--accent-primary);
        }
        
        .group-item.nested {
            margin-left: var(--space-4);
        }
        
        .group-icon {
            color: var(--text-secondary);
            font-size: var(--font-size-sm);
        }
        
        .group-name {
            flex: 1;
            font-size: var(--font-size-xs);
            color: var(--text-primary);
        }
        
        .group-count {
            font-size: 10px;
            color: var(--text-secondary);
            font-family: var(--font-family-mono);
        }
        
        .group-actions {
            display: flex;
            gap: var(--space-1);
        }
        
        .group-action-btn {
            padding: var(--space-1);
            background: none;
            border: none;
            color: var(--text-secondary);
            cursor: pointer;
            font-size: 11px;
            transition: color var(--duration-fast);
        }
        
        .group-action-btn:hover {
            color: var(--accent-primary);
        }
        
        /* Input group for inline controls */
        .input-row {
            display: flex;
            gap: var(--space-2);
            align-items: center;
        }
        
        .input-row input[type="text"] {
            flex: 1;
            padding: var(--space-2) var(--space-3);
            background: var(--bg-secondary);
            border: 1px solid var(--border);
            border-radius: var(--radius-md);
            color: var(--text-primary);
            font-size: var(--font-size-xs);
            font-family: var(--font-family-sans);
        }
        
        .input-row input[type="text"]:focus {
            outline: none;
            border-color: var(--accent-primary);
        }
        
        .input-row .button {
            padding: var(--space-2) var(--space-3);
            font-size: var(--font-size-xs);
        }
        
        /* Range Input */
        input[type="range"] {
            width: 100%;
            height: 4px;
            background: var(--border);
            border-radius: var(--radius-sm);
            outline: none;
            -webkit-appearance: none;
            cursor: pointer;
        }
        
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 16px;
            height: 16px;
            background: var(--accent-primary);
            border-radius: 50%;
            cursor: pointer;
            transition: transform var(--duration-fast);
        }
        
        input[type="range"]::-webkit-slider-thumb:hover {
            transform: scale(1.2);
        }
        
        input[type="range"]::-moz-range-thumb {
            width: 16px;
            height: 16px;
            background: var(--accent-primary);
            border-radius: 50%;
            cursor: pointer;
            border: none;
            transition: transform var(--duration-fast);
        }
        
        input[type="range"]::-moz-range-thumb:hover {
            transform: scale(1.2);
        }
        
        /* Select Input */
        select {
            width: 100%;
            padding: var(--space-2) var(--space-3);
            background: var(--bg-secondary);
            border: 1px solid var(--border);
            border-radius: var(--radius-md);
            color: var(--text-primary);
            font-size: var(--font-size-xs);
            cursor: pointer;
            font-family: var(--font-family-sans);
            transition: border-color var(--duration-normal);
        }
        
        select:hover {
            border-color: var(--accent-primary);
        }
        
        select:focus {
            outline: none;
            border-color: var(--accent-primary);
            box-shadow: 0 0 0 2px var(--highlight);
        }
        
        /* Color Input */
        input[type="color"] {
            width: 100%;
            height: 40px;
            padding: var(--space-1);
            background: var(--bg-secondary);
            border: 1px solid var(--border);
            border-radius: var(--radius-md);
            cursor: pointer;
        }
        
        input[type="color"]::-webkit-color-swatch-wrapper {
            padding: 0;
        }
        
        input[type="color"]::-webkit-color-swatch {
            border: none;
            border-radius: var(--radius-base);
        }
        
        /* Checkbox */
        .checkbox-group {
            display: flex;
            align-items: center;
            gap: var(--space-2);
        }
        
        input[type="checkbox"] {
            width: 18px;
            height: 18px;
            cursor: pointer;
            accent-color: var(--accent-primary);
        }
        
        .checkbox-label {
            font-size: var(--font-size-xs);
            color: var(--text-primary);
            cursor: pointer;
            user-select: none;
        }
        
        /* Button */
        .button {
            width: 100%;
            padding: var(--space-3);
            background: var(--accent-primary);
            border: none;
            border-radius: var(--radius-md);
            color: var(--text-title);
            font-size: var(--font-size-sm);
            font-weight: var(--font-weight-semibold);
            cursor: pointer;
            transition: background var(--duration-normal), transform var(--duration-fast);
            font-family: var(--font-family-sans);
        }
        
        .button:hover {
            background: var(--accent-secondary);
            transform: translateY(-1px);
        }
        
        .button:active {
            transform: translateY(0);
        }
        
        .button.secondary {
            background: var(--bg-tertiary);
            border: 1px solid var(--border);
        }
        
        .button.secondary:hover {
            background: var(--bg-hover);
            border-color: var(--accent-primary);
        }
        
        /* S-Curve Visualization */
        .curve-visualization {
            width: 100%;
            height: 120px;
            background: var(--bg-primary);
            border: 1px solid var(--border);
            border-radius: var(--radius-md);
            margin-top: var(--space-2);
            position: relative;
        }
        
        .curve-canvas {
            width: 100%;
            height: 100%;
            border-radius: var(--radius-md);
        }
        
        /* Multi-selection indicator */
        .selection-badge {
            display: inline-flex;
            align-items: center;
            gap: var(--space-1);
            padding: var(--space-1) var(--space-2);
            background: var(--accent-primary);
            color: var(--text-title);
            border-radius: var(--radius-base);
            font-size: 10px;
            font-weight: var(--font-weight-semibold);
            font-family: var(--font-family-mono);
        }
        
        /* Key mapper */
        .key-mapping-item {
            display: flex;
            align-items: center;
            gap: var(--space-2);
            padding: var(--space-2);
            background: var(--bg-primary);
            border: 1px solid var(--border);
            border-radius: var(--radius-md);
            margin-bottom: var(--space-2);
        }
        
        .key-combo {
            flex: 1;
            font-size: var(--font-size-xs);
            font-weight: var(--font-weight-medium);
            color: var(--text-title);
            font-family: var(--font-family-mono);
        }
        
        .key-mapping-item select {
            flex: 2;
            padding: var(--space-1) var(--space-2);
            font-size: var(--font-size-xs);
        }
        
        .kbd {
            display: inline-block;
            padding: 2px 6px;
            background: var(--bg-tertiary);
            border: 1px solid var(--border);
            border-radius: 3px;
            font-size: 10px;
            font-family: var(--font-family-mono);
            color: var(--text-secondary);
        }
        
        /* Instructions */
        #instructions {
            position: absolute;
            bottom: var(--space-5);
            left: var(--space-5);
            background: var(--bg-secondary);
            padding: var(--space-4) var(--space-5);
            border-radius: var(--radius-lg);
            font-size: var(--font-size-xs);
            color: var(--text-secondary);
            z-index: 50;
            border: 1px solid var(--border);
            box-shadow: var(--shadow-md);
        }
        
        #instructions strong {
            color: var(--accent-primary);
            font-weight: var(--font-weight-semibold);
        }
        
        #instructions kbd {
            display: inline-block;
            padding: 1px 4px;
            background: var(--bg-tertiary);
            border: 1px solid var(--border);
            border-radius: 2px;
            font-size: 11px;
            font-family: var(--font-family-mono);
        }
        
        /* HUD (Heads-Up Display) */
        #hud-container {
            position: absolute;
            top: var(--space-5);
            left: var(--space-5);
            z-index: 200;
            pointer-events: none;
        }
        
        #hud-container * {
            pointer-events: auto;
        }
        
        .hud-panel {
            background: var(--bg-secondary);
            border: 1px solid var(--border);
            border-radius: var(--radius-lg);
            padding: var(--space-3);
            min-width: 220px;
            box-shadow: var(--shadow-md);
            transition: transform var(--duration-slow) var(--ease-out);
        }
        
        .hud-section {
            margin-bottom: var(--space-3);
        }
        
        .hud-section:last-child {
            margin-bottom: 0;
        }
        
        .hud-title {
            font-size: var(--font-size-xs);
            font-weight: var(--font-weight-semibold);
            text-transform: uppercase;
            letter-spacing: 0.5px;
            color: var(--text-title);
            margin-bottom: var(--space-2);
            padding-bottom: var(--space-1);
            border-bottom: 1px solid var(--border-subtle);
        }
        
        .hud-content {
            display: flex;
            flex-direction: column;
            gap: var(--space-1);
        }
        
        .hud-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 10px;
        }
        
        .hud-label {
            color: var(--text-secondary);
        }
        
        .hud-value {
            color: var(--accent-primary);
            font-family: var(--font-family-mono);
            font-weight: var(--font-weight-medium);
        }
        
        #hud-z-viz {
            width: 100%;
            height: 80px;
            background: #0d1b2a;
            border: 1px solid var(--border);
            border-radius: var(--radius-md);
        }
        
        .hud-toggle {
            position: absolute;
            right: -32px;
            top: 0;
            width: 32px;
            height: 32px;
            background: var(--bg-secondary);
            border: 1px solid var(--border);
            border-left: none;
            border-radius: 0 var(--radius-md) var(--radius-md) 0;
            color: var(--text-title);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
            transition: background var(--duration-normal);
        }
        
        .hud-toggle:hover {
            background: var(--bg-hover);
        }
        
        /* Notification Animations */
        @keyframes slideIn {
            from {
                transform: translateX(400px);
                opacity: 0;
            }
            to {
                transform: translateX(0);
                opacity: 1;
            }
        }
        
        @keyframes slideOut {
            from {
                transform: translateX(0);
                opacity: 1;
            }
            to {
                transform: translateX(400px);
                opacity: 0;
            }
        }
    </style>
</head>
<body>
    <div id="app">
        <div id="canvas-container">
            <canvas id="drawing-canvas"></canvas>
            <canvas id="renderer-canvas"></canvas>
        </div>
        
        <div id="side-panel">
            <div id="panel-toggle">â—€</div>
            <div class="panel-menu" id="panel-menu">
                <!-- Menu buttons will be dynamically generated -->
            </div>
            <div class="panels-container" id="panels-container">
                <!-- Panels will be dynamically generated by window.PANELS -->
            </div>
        </div>
        
        <div id="instructions">
            <strong>Draw:</strong> Click and drag to draw<br>
            <strong>Select:</strong> Click cylinder | <kbd>Shift+Click</kbd> toggle | <kbd>Ctrl+Shift+Click</kbd> multi-select<br>
            <strong>Camera:</strong> Right-click + drag to rotate, Scroll to zoom
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    
    <script>
        // Module Loader System
        window.LOADER = {
            modules: {},
            boot: function() {
                console.log('ðŸš€ Booting Cylinder Application...');
                
                // Initialize modules in order
                window.PUBSUB.init();
                window.CONFIG.init();
                window.STORAGE.init();
                window.REGISTRATION.init();
                window.GROUP_MANAGER.init();
                window.KEY_MAPPER.init();
                window.RENDERER.init();
                window.CAMERA.init();
                window.SCENE.init();
                window.STROKE.init();
                window.CYLINDER_MANAGER.init();
                window.CYLINDER.init();
                window.PANELS.init();
                window.HUD.init();
                window.APP.init();
                
                console.log('âœ… Application ready');
            }
        };

        // PubSub Module - Custom messaging system for decoupled communication
        window.PUBSUB = {
            subscribers: {},
            
            init: function() {
                console.log('ðŸ“¡ PubSub initialized');
            },
            
            subscribe: function(event, callback, context = null) {
                if (!this.subscribers[event]) {
                    this.subscribers[event] = [];
                }
                
                const subscription = {
                    callback: callback,
                    context: context,
                    id: Math.random().toString(36).substr(2, 9)
                };
                
                this.subscribers[event].push(subscription);
                
                return subscription.id;
            },
            
            unsubscribe: function(event, subscriptionId) {
                if (!this.subscribers[event]) return;
                
                this.subscribers[event] = this.subscribers[event].filter(
                    sub => sub.id !== subscriptionId
                );
            },
            
            publish: function(event, data = null) {
                if (!this.subscribers[event]) return;
                
                this.subscribers[event].forEach(subscription => {
                    if (subscription.context) {
                        subscription.callback.call(subscription.context, data);
                    } else {
                        subscription.callback(data);
                    }
                });
                
                // Log for debugging
                if (window.CONFIG && window.CONFIG.debug) {
                    console.log(`ðŸ“¡ ${event}`, data);
                }
            },
            
            // Clear all subscriptions for an event
            clear: function(event) {
                if (event) {
                    delete this.subscribers[event];
                } else {
                    this.subscribers = {};
                }
            }
        };

        // Configuration Module
        window.CONFIG = {
            canvas: {
                drawing: null,
                renderer: null
            },
            settings: {
                radius: 0.5,
                depth: 1.0,
                segments: 16,
                curvePoints: 100,
                smoothing: 0.5,
                interpolation: 'catmull-rom',
                color: '#e94560',
                metalness: 0.3,
                roughness: 0.4,
                singleWidthMode: true
            },
            init: function() {
                this.canvas.drawing = document.getElementById('drawing-canvas');
                this.canvas.renderer = document.getElementById('renderer-canvas');
                console.log('ðŸ“‹ Config initialized');
            }
        };

        // Storage Module - Manages localStorage persistence
        window.STORAGE = {
            STORAGE_KEY: 'cylinder_app_state',
            
            init: function() {
                this.load();
                console.log('ðŸ’¾ Storage initialized');
            },
            
            save: function() {
                const state = {
                    settings: window.CONFIG.settings,
                    panels: this.getPanelsState(),
                    groups: {
                        groups: window.GROUP_MANAGER.groups,
                        nextGroupId: window.GROUP_MANAGER.nextGroupId
                    }
                };
                
                try {
                    localStorage.setItem(this.STORAGE_KEY, JSON.stringify(state));
                    console.log('âœ… State saved to localStorage');
                    return true;
                } catch (error) {
                    console.error('âŒ Failed to save state:', error);
                    return false;
                }
            },
            
            load: function() {
                try {
                    const stored = localStorage.getItem(this.STORAGE_KEY);
                    if (stored) {
                        const state = JSON.parse(stored);
                        
                        // Restore settings
                        if (state.settings) {
                            Object.assign(window.CONFIG.settings, state.settings);
                        }
                        
                        // Store panels state for later restoration
                        this.storedPanelsState = state.panels;
                        
                        // Restore groups
                        if (state.groups && window.GROUP_MANAGER) {
                            window.GROUP_MANAGER.groups = state.groups.groups || [];
                            window.GROUP_MANAGER.nextGroupId = state.groups.nextGroupId || 0;
                        }
                        
                        console.log('âœ… State loaded from localStorage');
                        return state;
                    }
                } catch (error) {
                    console.error('âŒ Failed to load state:', error);
                }
                return null;
            },
            
            getPanelsState: function() {
                if (!window.PANELS || !window.PANELS.panelDefinitions) return null;
                
                const panelsState = {
                    order: window.PANELS.panelOrder,
                    collapsed: {}
                };
                
                window.PANELS.panelDefinitions.forEach(panel => {
                    panelsState.collapsed[panel.id] = panel.collapsed || false;
                    
                    if (panel.subPanels) {
                        panel.subPanels.forEach(subPanel => {
                            panelsState.collapsed[`${panel.id}_${subPanel.id}`] = subPanel.collapsed || false;
                        });
                    }
                });
                
                return panelsState;
            },
            
            clear: function() {
                try {
                    localStorage.removeItem(this.STORAGE_KEY);
                    console.log('ðŸ—‘ï¸ Storage cleared');
                    return true;
                } catch (error) {
                    console.error('âŒ Failed to clear storage:', error);
                    return false;
                }
            },
            
            export: function() {
                const state = {
                    settings: window.CONFIG.settings,
                    panels: this.getPanelsState(),
                    timestamp: new Date().toISOString()
                };
                
                const json = JSON.stringify(state, null, 2);
                const blob = new Blob([json], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                
                const a = document.createElement('a');
                a.href = url;
                a.download = `cylinder_config_${Date.now()}.json`;
                a.click();
                
                URL.revokeObjectURL(url);
                console.log('ðŸ“¥ Configuration exported');
            },
            
            import: function(file) {
                return new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    
                    reader.onload = (e) => {
                        try {
                            const state = JSON.parse(e.target.result);
                            
                            if (state.settings) {
                                Object.assign(window.CONFIG.settings, state.settings);
                            }
                            
                            if (state.panels) {
                                this.storedPanelsState = state.panels;
                            }
                            
                            // Rebuild UI
                            if (window.PANELS) {
                                window.PANELS.rebuild();
                            }
                            
                            console.log('ðŸ“¤ Configuration imported');
                            resolve(state);
                        } catch (error) {
                            console.error('âŒ Failed to import configuration:', error);
                            reject(error);
                        }
                    };
                    
                    reader.onerror = reject;
                    reader.readAsText(file);
                });
            }
        };

        // Registration Module - Parameterizes 2D-to-3D mapping with neural network hooks
        window.REGISTRATION = {
            parameters: {
                // Screen-to-world scale factors
                screenScale: 0.02,
                depthScale: 1.0,
                
                // Z-mapping parameters (first-class citizen)
                zIndex: {
                    mode: 'linear', // 'linear', 'exponential', 'sigmoid', 'neural'
                    min: -10,
                    max: 10,
                    bias: 0,
                    scale: 3,
                    curvature: 1.0  // For exponential/sigmoid modes
                },
                
                // Orientation parameters
                horizontalBias: 0, // -1 to 1: negative = left-to-right, positive = right-to-left
                verticalBias: 0,   // -1 to 1: negative = top-to-bottom, positive = bottom-to-top
                
                // Stroke direction influence
                directionWeight: 1.0, // How much stroke direction affects 3D orientation
                
                // Viewport mapping
                viewportCenter: { x: 0.5, y: 0.5 }, // Normalized 0-1
                
                // Neural network influence (0-1)
                nnWeight: 0.0 // 0 = pure parametric, 1 = full neural override
            },
            
            history: [], // Track all registrations for learning
            maxHistory: 1000,
            
            // Neural network hook structure (not implemented yet)
            neuralHooks: {
                enabled: false,
                model: null, // Will hold neural network model
                
                // Input feature extraction
                extractFeatures: function(stroke2D, strokeMetrics) {
                    // Hook for extracting features from stroke data
                    return {
                        pointCount: stroke2D.length,
                        boundingBox: strokeMetrics.boundingBox,
                        direction: strokeMetrics.primaryDirection,
                        curvature: strokeMetrics.averageCurvature,
                        pressure: strokeMetrics.averagePressure,
                        velocity: strokeMetrics.averageVelocity,
                        aspect: strokeMetrics.aspectRatio
                    };
                },
                
                // Prediction hook
                predict: function(features) {
                    // Hook for neural network prediction
                    // Returns: { zMapping, orientationBias, confidence }
                    if (!this.enabled || !this.model) {
                        return null;
                    }
                    // TODO: Implement neural network inference
                    return null;
                },
                
                // Training data collection
                collectTrainingData: function(input, output, userCorrection) {
                    // Hook for collecting training data
                    // input: features, output: actual 3D mapping, userCorrection: any manual adjustments
                    return {
                        timestamp: Date.now(),
                        features: input,
                        mapping: output,
                        correction: userCorrection
                    };
                }
            },
            
            init: function() {
                this.load();
                
                // Subscribe to camera changes to update z-index mapping
                window.PUBSUB.subscribe('camera:moved', () => this.updateZMapping());
                
                console.log('ðŸŽ¯ Registration initialized');
            },
            
            // Calculate stroke metrics for analysis
            calculateStrokeMetrics: function(points) {
                if (points.length < 2) return null;
                
                // Bounding box
                let minX = Infinity, maxX = -Infinity;
                let minY = Infinity, maxY = -Infinity;
                
                points.forEach(p => {
                    minX = Math.min(minX, p.x);
                    maxX = Math.max(maxX, p.x);
                    minY = Math.min(minY, p.y);
                    maxY = Math.max(maxY, p.y);
                });
                
                const width = maxX - minX;
                const height = maxY - minY;
                const aspectRatio = width / height;
                
                // Primary direction
                const dx = points[points.length - 1].x - points[0].x;
                const dy = points[points.length - 1].y - points[0].y;
                const angle = Math.atan2(dy, dx);
                const isHorizontal = Math.abs(dx) > Math.abs(dy);
                
                // Curvature (simplified - sum of angle changes)
                let totalCurvature = 0;
                for (let i = 1; i < points.length - 1; i++) {
                    const v1x = points[i].x - points[i-1].x;
                    const v1y = points[i].y - points[i-1].y;
                    const v2x = points[i+1].x - points[i].x;
                    const v2y = points[i+1].y - points[i].y;
                    
                    const angle1 = Math.atan2(v1y, v1x);
                    const angle2 = Math.atan2(v2y, v2x);
                    totalCurvature += Math.abs(angle2 - angle1);
                }
                const averageCurvature = totalCurvature / (points.length - 2);
                
                // Average pressure
                const averagePressure = points.reduce((sum, p) => sum + (p.pressure || 0.5), 0) / points.length;
                
                // Velocity (approximation)
                let totalDistance = 0;
                for (let i = 1; i < points.length; i++) {
                    const dx = points[i].x - points[i-1].x;
                    const dy = points[i].y - points[i-1].y;
                    totalDistance += Math.sqrt(dx * dx + dy * dy);
                }
                const averageVelocity = totalDistance / points.length;
                
                return {
                    boundingBox: { minX, maxX, minY, maxY, width, height },
                    aspectRatio,
                    primaryDirection: { angle, dx, dy, isHorizontal },
                    averageCurvature,
                    averagePressure,
                    averageVelocity,
                    pointCount: points.length
                };
            },
            
            // Map 2D stroke to 3D with parameterized registration
            mapStrokeTo3D: function(points2D, strokeMetrics) {
                const params = this.parameters;
                const centerX = window.innerWidth * params.viewportCenter.x;
                const centerY = window.innerHeight * params.viewportCenter.y;
                
                // Check for neural network prediction
                let nnPrediction = null;
                if (params.nnWeight > 0 && this.neuralHooks.enabled) {
                    const features = this.neuralHooks.extractFeatures(points2D, strokeMetrics);
                    nnPrediction = this.neuralHooks.predict(features);
                }
                
                const points3D = [];
                const mappingData = {
                    method: nnPrediction ? 'hybrid' : 'parametric',
                    nnConfidence: nnPrediction ? nnPrediction.confidence : 0,
                    parameters: { ...params }
                };
                
                for (let i = 0; i < points2D.length; i++) {
                    const p = points2D[i];
                    const t = i / (points2D.length - 1); // Normalized progress 0-1
                    
                    // X mapping (horizontal)
                    let x = (p.x - centerX) * params.screenScale;
                    x += params.horizontalBias * params.screenScale * 5;
                    
                    // Y mapping (vertical) - inverted for 3D space
                    let y = -(p.y - centerY) * params.screenScale;
                    y += params.verticalBias * params.screenScale * 5;
                    
                    // Z mapping (FIRST CLASS CITIZEN)
                    let z = this.calculateZMapping(t, p, strokeMetrics, nnPrediction);
                    
                    points3D.push(new THREE.Vector3(x, y, z));
                }
                
                // Record this registration for learning
                this.recordRegistration(points2D, points3D, strokeMetrics, mappingData);
                
                return {
                    points3D,
                    mappingData,
                    metrics: strokeMetrics
                };
            },
            
            // Calculate Z-index mapping (first-class)
            calculateZMapping: function(t, point2D, strokeMetrics, nnPrediction) {
                const params = this.parameters;
                const zParams = params.zIndex;
                
                // Neural network override
                if (nnPrediction && params.nnWeight > 0) {
                    const nnZ = nnPrediction.zMapping(t);
                    const parametricZ = this.calculateParametricZ(t, point2D, strokeMetrics);
                    return parametricZ * (1 - params.nnWeight) + nnZ * params.nnWeight;
                }
                
                return this.calculateParametricZ(t, point2D, strokeMetrics);
            },
            
            calculateParametricZ: function(t, point2D, strokeMetrics) {
                const params = this.parameters;
                const zParams = params.zIndex;
                
                let z;
                
                switch (zParams.mode) {
                    case 'linear':
                        z = (t - 0.5) * zParams.scale;
                        break;
                        
                    case 'exponential':
                        const exp = Math.pow(t, zParams.curvature);
                        z = (exp - 0.5) * zParams.scale;
                        break;
                        
                    case 'sigmoid':
                        const sig = 1 / (1 + Math.exp(-zParams.curvature * (t - 0.5) * 10));
                        z = (sig - 0.5) * zParams.scale;
                        break;
                        
                    default:
                        z = (t - 0.5) * zParams.scale;
                }
                
                // Apply bias and bounds
                z += zParams.bias;
                z = Math.max(zParams.min, Math.min(zParams.max, z));
                
                // Apply direction weight
                if (strokeMetrics.primaryDirection.isHorizontal) {
                    z *= params.directionWeight;
                }
                
                return z;
            },
            
            // Record registration for history and potential training
            recordRegistration: function(points2D, points3D, metrics, mappingData) {
                const record = {
                    timestamp: Date.now(),
                    points2D: points2D.map(p => ({ x: p.x, y: p.y, pressure: p.pressure })),
                    points3D: points3D.map(p => ({ x: p.x, y: p.y, z: p.z })),
                    metrics,
                    mappingData,
                    cameraState: this.getCameraState()
                };
                
                this.history.push(record);
                
                // Maintain max history
                if (this.history.length > this.maxHistory) {
                    this.history.shift();
                }
                
                window.PUBSUB.publish('registration:recorded', record);
            },
            
            getCameraState: function() {
                if (!window.CAMERA) return null;
                
                return {
                    position: {
                        x: window.CAMERA.camera.position.x,
                        y: window.CAMERA.camera.position.y,
                        z: window.CAMERA.camera.position.z
                    },
                    rotation: {
                        x: window.CAMERA.controls.rotationX,
                        y: window.CAMERA.controls.rotationY
                    },
                    distance: window.CAMERA.controls.distance
                };
            },
            
            updateZMapping: function() {
                window.PUBSUB.publish('zmapping:updated', {
                    zRange: [this.parameters.zIndex.min, this.parameters.zIndex.max],
                    mode: this.parameters.zIndex.mode,
                    cameraState: this.getCameraState()
                });
            },
            
            // Get world Z-range visible in current view
            getVisibleZRange: function() {
                const camera = window.CAMERA.camera;
                const frustum = new THREE.Frustum();
                const projScreenMatrix = new THREE.Matrix4();
                
                projScreenMatrix.multiplyMatrices(
                    camera.projectionMatrix,
                    camera.matrixWorldInverse
                );
                frustum.setFromProjectionMatrix(projScreenMatrix);
                
                // Calculate near and far Z in world space
                const nearZ = camera.near;
                const farZ = camera.far;
                
                return {
                    near: nearZ,
                    far: farZ,
                    configured: {
                        min: this.parameters.zIndex.min,
                        max: this.parameters.zIndex.max
                    }
                };
            },
            
            save: function() {
                try {
                    const data = {
                        parameters: this.parameters,
                        history: this.history.slice(-100) // Save last 100
                    };
                    localStorage.setItem('cylinder_registration', JSON.stringify(data));
                } catch (error) {
                    console.error('Failed to save registration:', error);
                }
            },
            
            load: function() {
                try {
                    const stored = localStorage.getItem('cylinder_registration');
                    if (stored) {
                        const data = JSON.parse(stored);
                        if (data.parameters) {
                            Object.assign(this.parameters, data.parameters);
                        }
                        if (data.history) {
                            this.history = data.history;
                        }
                    }
                } catch (error) {
                    console.error('Failed to load registration:', error);
                }
            },
            
            exportTrainingData: function() {
                // Export history as training data for neural network
                const trainingData = this.history.map(record => ({
                    input: this.neuralHooks.extractFeatures(record.points2D, record.metrics),
                    output: {
                        zMapping: record.points3D.map(p => p.z),
                        params: record.mappingData.parameters
                    },
                    metadata: {
                        timestamp: record.timestamp,
                        cameraState: record.cameraState
                    }
                }));
                
                const json = JSON.stringify(trainingData, null, 2);
                const blob = new Blob([json], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                
                const a = document.createElement('a');
                a.href = url;
                a.download = `registration_training_data_${Date.now()}.json`;
                a.click();
                
                URL.revokeObjectURL(url);
                console.log('ðŸ“Š Training data exported');
            }
        };

        // Group Manager Module - Manages cylinder groups and hierarchies
        window.GROUP_MANAGER = {
            groups: [],
            nextGroupId: 0,
            selectedGroup: null,
            
            init: function() {
                this.load();
                console.log('ðŸ“ Group Manager initialized');
            },
            
            createGroup: function(name, parentGroupId = null) {
                const group = {
                    id: this.nextGroupId++,
                    name: name || `Group ${this.nextGroupId}`,
                    cylinderIds: [],
                    childGroupIds: [],
                    parentGroupId: parentGroupId,
                    properties: null // Shared properties for the group
                };
                
                this.groups.push(group);
                
                // Add to parent if specified
                if (parentGroupId !== null) {
                    const parent = this.groups.find(g => g.id === parentGroupId);
                    if (parent) {
                        parent.childGroupIds.push(group.id);
                    }
                }
                
                this.save();
                return group;
            },
            
            deleteGroup: function(groupId) {
                const group = this.groups.find(g => g.id === groupId);
                if (!group) return;
                
                // Remove from parent
                if (group.parentGroupId !== null) {
                    const parent = this.groups.find(g => g.id === group.parentGroupId);
                    if (parent) {
                        parent.childGroupIds = parent.childGroupIds.filter(id => id !== groupId);
                    }
                }
                
                // Recursively delete child groups
                group.childGroupIds.forEach(childId => this.deleteGroup(childId));
                
                // Remove group
                this.groups = this.groups.filter(g => g.id !== groupId);
                
                this.save();
            },
            
            addCylinderToGroup: function(cylinderId, groupId) {
                const group = this.groups.find(g => g.id === groupId);
                if (!group) return;
                
                if (!group.cylinderIds.includes(cylinderId)) {
                    group.cylinderIds.push(cylinderId);
                    
                    // Update cylinder metadata
                    const cylinder = window.CYLINDER_MANAGER.cylinders.find(c => c.id === cylinderId);
                    if (cylinder && cylinder.metadata.groupIds) {
                        if (!cylinder.metadata.groupIds.includes(groupId)) {
                            cylinder.metadata.groupIds.push(groupId);
                        }
                    }
                    
                    this.save();
                }
            },
            
            removeCylinderFromGroup: function(cylinderId, groupId) {
                const group = this.groups.find(g => g.id === groupId);
                if (!group) return;
                
                group.cylinderIds = group.cylinderIds.filter(id => id !== cylinderId);
                
                // Update cylinder metadata
                const cylinder = window.CYLINDER_MANAGER.cylinders.find(c => c.id === cylinderId);
                if (cylinder && cylinder.metadata.groupIds) {
                    cylinder.metadata.groupIds = cylinder.metadata.groupIds.filter(id => id !== groupId);
                }
                
                this.save();
            },
            
            getCylinderGroups: function(cylinderId) {
                return this.groups.filter(g => g.cylinderIds.includes(cylinderId));
            },
            
            getGroupCylinders: function(groupId, recursive = false) {
                const group = this.groups.find(g => g.id === groupId);
                if (!group) return [];
                
                let cylinderIds = [...group.cylinderIds];
                
                if (recursive) {
                    group.childGroupIds.forEach(childId => {
                        cylinderIds = cylinderIds.concat(this.getGroupCylinders(childId, true));
                    });
                }
                
                return [...new Set(cylinderIds)]; // Remove duplicates
            },
            
            applyPropertiesToGroup: function(groupId, properties, recursive = false) {
                const cylinderIds = this.getGroupCylinders(groupId, recursive);
                
                cylinderIds.forEach(cylinderId => {
                    const cylinder = window.CYLINDER_MANAGER.cylinders.find(c => c.id === cylinderId);
                    if (cylinder) {
                        Object.assign(cylinder.metadata.parameters, properties);
                        window.CYLINDER_MANAGER.rebuildCylinder(cylinderId);
                    }
                });
            },
            
            applyPropertiesToMultiple: function(cylinderIds, properties) {
                cylinderIds.forEach(cylinderId => {
                    const cylinder = window.CYLINDER_MANAGER.cylinders.find(c => c.id === cylinderId);
                    if (cylinder) {
                        Object.assign(cylinder.metadata.parameters, properties);
                        window.CYLINDER_MANAGER.rebuildCylinder(cylinderId);
                    }
                });
            },
            
            renameGroup: function(groupId, newName) {
                const group = this.groups.find(g => g.id === groupId);
                if (group) {
                    group.name = newName;
                    this.save();
                }
            },
            
            save: function() {
                // Delegate to main storage system
                if (window.STORAGE) {
                    window.STORAGE.save();
                }
            },
            
            load: function() {
                // Groups are loaded by STORAGE.load() during init
                // This method is kept for API consistency
            },
            
            clear: function() {
                this.groups = [];
                this.nextGroupId = 0;
                this.selectedGroup = null;
                if (window.STORAGE) {
                    window.STORAGE.save();
                }
            }
        };

        // Key Mapper Module - Manages keyboard and mouse interaction mappings
        window.KEY_MAPPER = {
            mappings: {
                'click': 'select',
                'shift+click': 'toggle-selection',
                'ctrl+shift+click': 'multi-select'
            },
            actions: {
                'select': 'Select single cylinder (clears others)',
                'toggle-selection': 'Toggle cylinder in selection',
                'multi-select': 'Add cylinder to multi-selection',
                'deselect': 'Deselect all',
                'none': 'No action'
            },
            currentKeys: {
                shift: false,
                ctrl: false,
                alt: false
            },
            
            init: function() {
                this.setupKeyListeners();
                this.load();
                console.log('âŒ¨ï¸ Key Mapper initialized');
            },
            
            setupKeyListeners: function() {
                // Track modifier keys
                window.addEventListener('keydown', (e) => {
                    this.currentKeys.shift = e.shiftKey;
                    this.currentKeys.ctrl = e.ctrlKey || e.metaKey;
                    this.currentKeys.alt = e.altKey;
                });
                
                window.addEventListener('keyup', (e) => {
                    this.currentKeys.shift = e.shiftKey;
                    this.currentKeys.ctrl = e.ctrlKey || e.metaKey;
                    this.currentKeys.alt = e.altKey;
                });
                
                // Reset on blur
                window.addEventListener('blur', () => {
                    this.currentKeys.shift = false;
                    this.currentKeys.ctrl = false;
                    this.currentKeys.alt = false;
                });
            },
            
            getClickType: function(event) {
                const shift = event.shiftKey;
                const ctrl = event.ctrlKey || event.metaKey;
                const alt = event.altKey;
                
                if (ctrl && shift) return 'ctrl+shift+click';
                if (shift) return 'shift+click';
                if (ctrl) return 'ctrl+click';
                if (alt) return 'alt+click';
                return 'click';
            },
            
            getAction: function(clickType) {
                return this.mappings[clickType] || 'select';
            },
            
            setMapping: function(clickType, action) {
                this.mappings[clickType] = action;
                this.save();
                window.PUBSUB.publish('keymapper:changed', { clickType, action });
            },
            
            handleCylinderClick: function(cylinder, event) {
                const clickType = this.getClickType(event);
                const action = this.getAction(clickType);
                
                switch(action) {
                    case 'select':
                        window.CYLINDER_MANAGER.selectSingle(cylinder.id);
                        break;
                    case 'toggle-selection':
                        window.CYLINDER_MANAGER.toggleSelection(cylinder.id);
                        break;
                    case 'multi-select':
                        window.CYLINDER_MANAGER.addToSelection(cylinder.id);
                        break;
                    case 'deselect':
                        window.CYLINDER_MANAGER.deselectAll();
                        break;
                    case 'none':
                        // Do nothing
                        break;
                }
            },
            
            save: function() {
                try {
                    localStorage.setItem('cylinder_keymappings', JSON.stringify(this.mappings));
                } catch (error) {
                    console.error('Failed to save key mappings:', error);
                }
            },
            
            load: function() {
                try {
                    const stored = localStorage.getItem('cylinder_keymappings');
                    if (stored) {
                        this.mappings = JSON.parse(stored);
                    }
                } catch (error) {
                    console.error('Failed to load key mappings:', error);
                }
            },
            
            reset: function() {
                this.mappings = {
                    'click': 'select',
                    'shift+click': 'toggle-selection',
                    'ctrl+shift+click': 'multi-select'
                };
                this.save();
                window.PUBSUB.publish('keymapper:changed', null);
            }
        };

        // Renderer Module
        window.RENDERER = {
            renderer: null,
            width: 0,
            height: 0,
            
            init: function() {
                this.width = window.innerWidth;
                this.height = window.innerHeight;
                
                this.renderer = new THREE.WebGLRenderer({
                    canvas: window.CONFIG.canvas.renderer,
                    antialias: true,
                    alpha: true
                });
                
                this.renderer.setSize(this.width, this.height);
                this.renderer.setPixelRatio(window.devicePixelRatio);
                this.renderer.shadowMap.enabled = true;
                this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
                this.renderer.outputEncoding = THREE.sRGBEncoding;
                this.renderer.toneMapping = THREE.ACESFilmicToneMapping;
                
                window.addEventListener('resize', () => this.resize());
                
                console.log('ðŸŽ¨ Renderer initialized');
            },
            
            resize: function() {
                this.width = window.innerWidth;
                this.height = window.innerHeight;
                this.renderer.setSize(this.width, this.height);
                window.CAMERA.camera.aspect = this.width / this.height;
                window.CAMERA.camera.updateProjectionMatrix();
                
                window.CONFIG.canvas.drawing.width = this.width;
                window.CONFIG.canvas.drawing.height = this.height;
            },
            
            render: function() {
                this.renderer.render(window.SCENE.scene, window.CAMERA.camera);
            }
        };

        // Camera Module
        window.CAMERA = {
            camera: null,
            controls: {
                isRotating: false,
                lastX: 0,
                lastY: 0,
                rotationX: 0,
                rotationY: 0,
                distance: 15,
                target: new THREE.Vector3(0, 0, 0)
            },
            
            init: function() {
                this.camera = new THREE.PerspectiveCamera(
                    75,
                    window.innerWidth / window.innerHeight,
                    0.1,
                    1000
                );
                
                this.updatePosition();
                this.setupControls();
                
                console.log('ðŸ“· Camera initialized');
            },
            
            setupControls: function() {
                const canvas = window.CONFIG.canvas.drawing;
                
                canvas.addEventListener('mousedown', (e) => {
                    if (e.button === 2) { // Right click
                        this.controls.isRotating = true;
                        this.controls.lastX = e.clientX;
                        this.controls.lastY = e.clientY;
                        e.preventDefault();
                    }
                });
                
                canvas.addEventListener('mousemove', (e) => {
                    if (this.controls.isRotating) {
                        const deltaX = e.clientX - this.controls.lastX;
                        const deltaY = e.clientY - this.controls.lastY;
                        
                        this.controls.rotationY += deltaX * 0.005;
                        this.controls.rotationX += deltaY * 0.005;
                        
                        this.controls.rotationX = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, this.controls.rotationX));
                        
                        this.controls.lastX = e.clientX;
                        this.controls.lastY = e.clientY;
                        
                        this.updatePosition();
                    }
                });
                
                canvas.addEventListener('mouseup', (e) => {
                    if (e.button === 2) {
                        this.controls.isRotating = false;
                    }
                });
                
                canvas.addEventListener('wheel', (e) => {
                    e.preventDefault();
                    this.controls.distance += e.deltaY * 0.01;
                    this.controls.distance = Math.max(5, Math.min(50, this.controls.distance));
                    this.updatePosition();
                });
                
                canvas.addEventListener('contextmenu', (e) => e.preventDefault());
            },
            
            updatePosition: function() {
                const x = this.controls.distance * Math.sin(this.controls.rotationY) * Math.cos(this.controls.rotationX);
                const y = this.controls.distance * Math.sin(this.controls.rotationX);
                const z = this.controls.distance * Math.cos(this.controls.rotationY) * Math.cos(this.controls.rotationX);
                
                this.camera.position.set(
                    this.controls.target.x + x,
                    this.controls.target.y + y,
                    this.controls.target.z + z
                );
                
                this.camera.lookAt(this.controls.target);
                
                // Publish camera movement event
                window.PUBSUB.publish('camera:moved', {
                    position: this.camera.position,
                    rotation: { x: this.controls.rotationX, y: this.controls.rotationY },
                    distance: this.controls.distance
                });
            }
        };

        // Scene Module
        window.SCENE = {
            scene: null,
            
            init: function() {
                this.scene = new THREE.Scene();
                this.scene.background = new THREE.Color(0x1a1a2e); // bg-primary
                
                // Lighting
                const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
                this.scene.add(ambientLight);
                
                const directionalLight1 = new THREE.DirectionalLight(0xffffff, 0.8);
                directionalLight1.position.set(5, 10, 5);
                directionalLight1.castShadow = true;
                this.scene.add(directionalLight1);
                
                const directionalLight2 = new THREE.DirectionalLight(0xe94560, 0.3); // accent-primary
                directionalLight2.position.set(-5, 5, -5);
                this.scene.add(directionalLight2);
                
                // Grid helper
                const gridHelper = new THREE.GridHelper(20, 20, 0x444444, 0x222222);
                this.scene.add(gridHelper);
                
                console.log('ðŸŒ Scene initialized');
            },
            
            clear: function() {
                window.CYLINDER_MANAGER.clear();
            }
        };

        // Stroke Module
        window.STROKE = {
            ctx: null,
            isDrawing: false,
            points: [],
            
            init: function() {
                const canvas = window.CONFIG.canvas.drawing;
                canvas.width = window.innerWidth;
                canvas.height = window.innerHeight;
                this.ctx = canvas.getContext('2d');
                
                this.setupDrawing();
                
                console.log('âœï¸ Stroke initialized');
            },
            
            setupDrawing: function() {
                const canvas = window.CONFIG.canvas.drawing;
                
                canvas.addEventListener('mousedown', (e) => {
                    if (e.button === 0 && !window.CAMERA.controls.isRotating) {
                        this.startStroke(e);
                    }
                });
                
                canvas.addEventListener('mousemove', (e) => {
                    if (this.isDrawing) {
                        this.addPoint(e);
                    }
                });
                
                canvas.addEventListener('mouseup', () => {
                    if (this.isDrawing) {
                        this.endStroke();
                    }
                });
                
                canvas.addEventListener('mouseleave', () => {
                    if (this.isDrawing) {
                        this.endStroke();
                    }
                });
            },
            
            startStroke: function(e) {
                this.isDrawing = true;
                this.points = [];
                this.ctx.clearRect(0, 0, window.CONFIG.canvas.drawing.width, window.CONFIG.canvas.drawing.height);
                
                this.addPoint(e);
            },
            
            addPoint: function(e) {
                const rect = window.CONFIG.canvas.drawing.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                const pressure = e.pressure || 0.5;
                
                this.points.push({ x, y, pressure });
                this.draw();
            },
            
            draw: function() {
                if (this.points.length < 2) return;
                
                this.ctx.clearRect(0, 0, window.CONFIG.canvas.drawing.width, window.CONFIG.canvas.drawing.height);
                
                this.ctx.strokeStyle = '#e94560'; // accent-primary
                this.ctx.lineCap = 'round';
                this.ctx.lineJoin = 'round';
                
                for (let i = 1; i < this.points.length; i++) {
                    const p1 = this.points[i - 1];
                    const p2 = this.points[i];
                    
                    this.ctx.beginPath();
                    this.ctx.lineWidth = window.CONFIG.settings.singleWidthMode ? 3 : (p1.pressure * 6);
                    this.ctx.moveTo(p1.x, p1.y);
                    this.ctx.lineTo(p2.x, p2.y);
                    this.ctx.stroke();
                }
            },
            
            endStroke: function() {
                this.isDrawing = false;
                
                if (this.points.length > 2) {
                    window.CYLINDER.createFromStroke(this.points);
                }
                
                // Clear canvas after a brief delay
                setTimeout(() => {
                    this.ctx.clearRect(0, 0, window.CONFIG.canvas.drawing.width, window.CONFIG.canvas.drawing.height);
                }, 100);
            }
        };

        // Cylinder Manager Module - Scene graph and cylinder lifecycle management
        window.CYLINDER_MANAGER = {
            cylinders: [],
            selectedCylinders: [], // Changed from selectedCylinder to array
            nextId: 0,
            
            init: function() {
                this.setupSelection();
                
                // Subscribe to key mapper changes
                window.PUBSUB.subscribe('keymapper:changed', () => {
                    console.log('Key mappings updated');
                });
                
                console.log('ðŸ“Š Cylinder Manager initialized');
            },
            
            setupSelection: function() {
                const canvas = window.CONFIG.canvas.drawing;
                const raycaster = new THREE.Raycaster();
                const mouse = new THREE.Vector2();
                
                canvas.addEventListener('click', (e) => {
                    // Only handle selection if not drawing and not rotating camera
                    if (window.STROKE.isDrawing || window.CAMERA.controls.isRotating) return;
                    
                    // Calculate mouse position in normalized device coordinates
                    const rect = canvas.getBoundingClientRect();
                    mouse.x = ((e.clientX - rect.left) / rect.width) * 2 - 1;
                    mouse.y = -((e.clientY - rect.top) / rect.height) * 2 + 1;
                    
                    // Update the picking ray
                    raycaster.setFromCamera(mouse, window.CAMERA.camera);
                    
                    // Get all cylinder meshes
                    const meshes = this.cylinders.map(c => c.mesh);
                    const intersects = raycaster.intersectObjects(meshes);
                    
                    if (intersects.length > 0) {
                        const mesh = intersects[0].object;
                        const cylinder = this.cylinders.find(c => c.mesh === mesh);
                        if (cylinder) {
                            window.KEY_MAPPER.handleCylinderClick(cylinder, e);
                        }
                    } else {
                        // Clicked empty space
                        if (!e.shiftKey && !e.ctrlKey) {
                            this.deselectAll();
                        }
                    }
                });
            },
            
            createCylinder: function(strokePoints) {
                const id = this.nextId++;
                
                // Calculate stroke metrics
                const strokeMetrics = window.REGISTRATION.calculateStrokeMetrics(strokePoints);
                
                // Use REGISTRATION module for 2D-to-3D mapping
                const registration = window.REGISTRATION.mapStrokeTo3D(strokePoints, strokeMetrics);
                
                // Create metadata with full registration tracking
                const metadata = {
                    originalStroke: strokePoints.map(p => ({...p})),
                    strokeMetrics: strokeMetrics,
                    curve3D: registration.points3D,
                    registration: registration.mappingData,
                    groupIds: [],
                    parameters: {
                        radius: window.CONFIG.settings.radius,
                        segments: window.CONFIG.settings.segments,
                        curvePoints: window.CONFIG.settings.curvePoints,
                        interpolation: window.CONFIG.settings.interpolation,
                        smoothing: window.CONFIG.settings.smoothing,
                        depth: window.CONFIG.settings.depth,
                        singleWidthMode: window.CONFIG.settings.singleWidthMode,
                        color: window.CONFIG.settings.color,
                        metalness: window.CONFIG.settings.metalness,
                        roughness: window.CONFIG.settings.roughness,
                        widthFunction: 'normal',
                        sCurveParams: {
                            steepness: 5,
                            midpoint: 0.5
                        }
                    }
                };
                
                // Build the mesh
                const mesh = this.buildCylinderMesh(metadata);
                
                if (!mesh) return null;
                
                // Create cylinder object
                const cylinder = {
                    id: id,
                    mesh: mesh,
                    metadata: metadata
                };
                
                this.cylinders.push(cylinder);
                window.SCENE.scene.add(mesh);
                
                window.PUBSUB.publish('cylinder:created', { cylinderId: id, registration: metadata.registration });
                
                return cylinder;
            },
            
            buildCylinderMesh: function(metadata) {
                // Use precomputed 3D curve from registration
                const curve3D = metadata.curve3D;
                
                if (!curve3D || curve3D.length < 2) return null;
                
                // Create path from curve
                const path = this.createPath(curve3D, metadata.parameters);
                
                // Apply width function
                const radiusFunction = this.getRadiusFunction(metadata.parameters);
                
                // Generate cylinder geometry
                const geometry = this.createCylinderGeometry(path, metadata.parameters, radiusFunction);
                
                // Create material
                const material = new THREE.MeshStandardMaterial({
                    color: new THREE.Color(metadata.parameters.color),
                    metalness: metadata.parameters.metalness,
                    roughness: metadata.parameters.roughness,
                    side: THREE.DoubleSide
                });
                
                const mesh = new THREE.Mesh(geometry, material);
                mesh.castShadow = true;
                mesh.receiveShadow = true;
                mesh.userData.isCylinder = true;
                mesh.userData.cylinderId = null; // Will be set when added to scene graph
                
                return mesh;
            },
            
            convertTo3DCurve: function(points, depthScale, singleWidthMode) {
                const curve3D = [];
                const centerX = window.innerWidth / 2;
                const centerY = window.innerHeight / 2;
                const scale = 0.02;
                
                // Calculate stroke bounding box and direction
                let minX = Infinity, maxX = -Infinity;
                let minY = Infinity, maxY = -Infinity;
                
                points.forEach(p => {
                    minX = Math.min(minX, p.x);
                    maxX = Math.max(maxX, p.x);
                    minY = Math.min(minY, p.y);
                    maxY = Math.max(maxY, p.y);
                });
                
                const width = maxX - minX;
                const height = maxY - minY;
                const isHorizontal = width > height;
                
                // For horizontal strokes, we want the cylinder to extend left-right in front of camera
                // For vertical strokes, extend up-down
                
                for (let i = 0; i < points.length; i++) {
                    const p = points[i];
                    const t = i / (points.length - 1); // normalized progress 0-1
                    
                    // Screen space to 3D conversion
                    let x, y, z;
                    
                    if (isHorizontal) {
                        // Horizontal stroke: main axis is X, depth is Z
                        x = (p.x - centerX) * scale;
                        y = -(p.y - centerY) * scale;
                        
                        if (singleWidthMode) {
                            // Use normalized progress for depth variation
                            z = (t - 0.5) * depthScale * 3;
                        } else {
                            z = (p.pressure - 0.5) * depthScale * 3;
                        }
                    } else {
                        // Vertical stroke: main axis is Y, depth is Z
                        x = (p.x - centerX) * scale;
                        y = -(p.y - centerY) * scale;
                        
                        if (singleWidthMode) {
                            z = (t - 0.5) * depthScale * 3;
                        } else {
                            z = (p.pressure - 0.5) * depthScale * 3;
                        }
                    }
                    
                    curve3D.push(new THREE.Vector3(x, y, z));
                }
                
                return curve3D;
            },
            
            createPath: function(points, parameters) {
                const interpolation = parameters.interpolation;
                
                if (interpolation === 'linear') {
                    return new THREE.CatmullRomCurve3(points, false, 'centripetal', 0);
                } else if (interpolation === 'catmull-rom') {
                    const tension = 1 - parameters.smoothing;
                    return new THREE.CatmullRomCurve3(points, false, 'centripetal', tension);
                } else if (interpolation === 'bezier') {
                    return new THREE.CatmullRomCurve3(points, false, 'catmullrom', 0.5);
                }
                
                return new THREE.CatmullRomCurve3(points);
            },
            
            getRadiusFunction: function(parameters) {
                const baseRadius = parameters.radius;
                const widthFunc = parameters.widthFunction;
                const sCurve = parameters.sCurveParams;
                
                if (widthFunc === 'normal') {
                    return (t) => baseRadius;
                }
                else if (widthFunc === 'inverted') {
                    return (t) => baseRadius * (1 - this.sCurveMap(t, sCurve.steepness, sCurve.midpoint) * 0.8);
                }
                else if (widthFunc === 'growing') {
                    return (t) => baseRadius * (0.2 + this.sCurveMap(t, sCurve.steepness, sCurve.midpoint) * 0.8);
                }
                else if (widthFunc === 'shrinking') {
                    return (t) => baseRadius * (1 - this.sCurveMap(t, sCurve.steepness, sCurve.midpoint) * 0.8);
                }
                
                return (t) => baseRadius;
            },
            
            // S-curve mapping using double exponential (sigmoid-like)
            sCurveMap: function(t, steepness, midpoint) {
                // Map t from [0,1] using an S-curve
                // steepness: how steep the transition (higher = steeper)
                // midpoint: where the inflection point is
                const x = (t - midpoint) * steepness;
                return 1 / (1 + Math.exp(-x));
            },
            
            createCylinderGeometry: function(path, parameters, radiusFunction) {
                const curvePoints = parameters.curvePoints;
                const segments = parameters.segments;
                
                // Create custom tube geometry with variable radius
                const frames = path.computeFrenetFrames(curvePoints, false);
                const tangents = frames.tangents;
                const normals = frames.normals;
                const binormals = frames.binormals;
                
                const vertices = [];
                const indices = [];
                const uvs = [];
                
                for (let i = 0; i <= curvePoints; i++) {
                    const t = i / curvePoints;
                    const point = path.getPointAt(t);
                    const radius = radiusFunction(t);
                    
                    const normal = normals[i];
                    const binormal = binormals[i];
                    
                    for (let j = 0; j <= segments; j++) {
                        const theta = (j / segments) * Math.PI * 2;
                        const cosTheta = Math.cos(theta);
                        const sinTheta = Math.sin(theta);
                        
                        const vertex = new THREE.Vector3();
                        vertex.x = point.x + radius * (cosTheta * normal.x + sinTheta * binormal.x);
                        vertex.y = point.y + radius * (cosTheta * normal.y + sinTheta * binormal.y);
                        vertex.z = point.z + radius * (cosTheta * normal.z + sinTheta * binormal.z);
                        
                        vertices.push(vertex.x, vertex.y, vertex.z);
                        uvs.push(j / segments, i / curvePoints);
                    }
                }
                
                // Generate indices
                for (let i = 0; i < curvePoints; i++) {
                    for (let j = 0; j < segments; j++) {
                        const a = i * (segments + 1) + j;
                        const b = a + segments + 1;
                        const c = a + 1;
                        const d = b + 1;
                        
                        indices.push(a, b, c);
                        indices.push(b, d, c);
                    }
                }
                
                const geometry = new THREE.BufferGeometry();
                geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
                geometry.setAttribute('uv', new THREE.Float32BufferAttribute(uvs, 2));
                geometry.setIndex(indices);
                geometry.computeVertexNormals();
                
                return geometry;
            },
            
            rebuildCylinder: function(cylinderId) {
                const cylinder = this.cylinders.find(c => c.id === cylinderId);
                if (!cylinder) return;
                
                // Remove old mesh
                window.SCENE.scene.remove(cylinder.mesh);
                if (cylinder.mesh.geometry) cylinder.mesh.geometry.dispose();
                if (cylinder.mesh.material) cylinder.mesh.material.dispose();
                
                // Build new mesh
                const newMesh = this.buildCylinderMesh(cylinder.metadata);
                if (newMesh) {
                    cylinder.mesh = newMesh;
                    newMesh.userData.cylinderId = cylinderId;
                    window.SCENE.scene.add(newMesh);
                    
                    // Reselect if this was selected
                    if (this.selectedCylinder && this.selectedCylinder.id === cylinderId) {
                        this.highlightCylinder(newMesh);
                    }
                }
            },
            
            selectSingle: function(cylinderId) {
                // Deselect all and select one
                this.selectedCylinders.forEach(id => {
                    const cylinder = this.cylinders.find(c => c.id === id);
                    if (cylinder) {
                        this.unhighlightCylinder(cylinder.mesh);
                    }
                });
                
                this.selectedCylinders = [cylinderId];
                
                const cylinder = this.cylinders.find(c => c.id === cylinderId);
                if (cylinder) {
                    this.highlightCylinder(cylinder.mesh);
                }
                
                window.PUBSUB.publish('cylinder:selected', { 
                    cylinderId, 
                    selectedCount: this.selectedCylinders.length 
                });
                
                // Update UI
                if (window.PANELS) {
                    window.PANELS.updateSelectedCylinderPanel(cylinder);
                }
                
                console.log('Selected cylinder:', cylinderId);
            },
            
            toggleSelection: function(cylinderId) {
                const index = this.selectedCylinders.indexOf(cylinderId);
                const cylinder = this.cylinders.find(c => c.id === cylinderId);
                
                if (!cylinder) return;
                
                if (index > -1) {
                    // Deselect
                    this.selectedCylinders.splice(index, 1);
                    this.unhighlightCylinder(cylinder.mesh);
                    
                    window.PUBSUB.publish('cylinder:deselected', { 
                        cylinderId, 
                        selectedCount: this.selectedCylinders.length 
                    });
                } else {
                    // Select
                    this.selectedCylinders.push(cylinderId);
                    this.highlightCylinder(cylinder.mesh);
                    
                    window.PUBSUB.publish('cylinder:selected', { 
                        cylinderId, 
                        selectedCount: this.selectedCylinders.length 
                    });
                }
                
                // Update UI
                this.updateSelectionUI();
            },
            
            addToSelection: function(cylinderId) {
                if (this.selectedCylinders.includes(cylinderId)) return;
                
                this.selectedCylinders.push(cylinderId);
                
                const cylinder = this.cylinders.find(c => c.id === cylinderId);
                if (cylinder) {
                    this.highlightCylinder(cylinder.mesh);
                }
                
                window.PUBSUB.publish('cylinder:selected', { 
                    cylinderId, 
                    selectedCount: this.selectedCylinders.length 
                });
                
                this.updateSelectionUI();
            },
            
            deselectAll: function() {
                this.selectedCylinders.forEach(id => {
                    const cylinder = this.cylinders.find(c => c.id === id);
                    if (cylinder) {
                        this.unhighlightCylinder(cylinder.mesh);
                    }
                });
                
                this.selectedCylinders = [];
                
                window.PUBSUB.publish('selection:cleared', null);
                
                // Update UI
                if (window.PANELS) {
                    window.PANELS.updateSelectedCylinderPanel(null);
                }
            },
            
            updateSelectionUI: function() {
                if (window.PANELS) {
                    if (this.selectedCylinders.length === 1) {
                        const cylinder = this.cylinders.find(c => c.id === this.selectedCylinders[0]);
                        window.PANELS.updateSelectedCylinderPanel(cylinder);
                    } else if (this.selectedCylinders.length > 1) {
                        window.PANELS.updateSelectedCylinderPanel({ 
                            isMultiSelection: true, 
                            count: this.selectedCylinders.length 
                        });
                    } else {
                        window.PANELS.updateSelectedCylinderPanel(null);
                    }
                }
            },
            
            getSelectedCylinders: function() {
                return this.selectedCylinders.map(id => 
                    this.cylinders.find(c => c.id === id)
                ).filter(c => c !== undefined);
            },
            
            highlightCylinder: function(mesh) {
                if (mesh && mesh.material) {
                    mesh.material.emissive = new THREE.Color(0xe94560);
                    mesh.material.emissiveIntensity = 0.3;
                }
            },
            
            unhighlightCylinder: function(mesh) {
                if (mesh && mesh.material) {
                    mesh.material.emissive = new THREE.Color(0x000000);
                    mesh.material.emissiveIntensity = 0;
                }
            },
            
            deleteCylinder: function(cylinderId) {
                const index = this.cylinders.findIndex(c => c.id === cylinderId);
                if (index === -1) return;
                
                const cylinder = this.cylinders[index];
                
                // Remove from all groups
                if (cylinder.metadata.groupIds) {
                    cylinder.metadata.groupIds.forEach(groupId => {
                        window.GROUP_MANAGER.removeCylinderFromGroup(cylinderId, groupId);
                    });
                }
                
                // Remove from scene
                window.SCENE.scene.remove(cylinder.mesh);
                if (cylinder.mesh.geometry) cylinder.mesh.geometry.dispose();
                if (cylinder.mesh.material) cylinder.mesh.material.dispose();
                
                // Remove from array
                this.cylinders.splice(index, 1);
                
                // Remove from selection if selected
                const selIndex = this.selectedCylinders.indexOf(cylinderId);
                if (selIndex > -1) {
                    this.selectedCylinders.splice(selIndex, 1);
                    window.PUBSUB.publish('cylinder:deleted', { cylinderId });
                    this.updateSelectionUI();
                }
            },
            
            deleteSelected: function() {
                if (this.selectedCylinders.length === 0) return;
                
                const count = this.selectedCylinders.length;
                const ids = [...this.selectedCylinders]; // Copy array
                
                ids.forEach(id => this.deleteCylinder(id));
                
                window.PUBSUB.publish('cylinders:deleted', { count });
            },
            
            clear: function() {
                this.cylinders.forEach(cylinder => {
                    window.SCENE.scene.remove(cylinder.mesh);
                    if (cylinder.mesh.geometry) cylinder.mesh.geometry.dispose();
                    if (cylinder.mesh.material) cylinder.mesh.material.dispose();
                });
                
                this.cylinders = [];
                this.selectedCylinders = [];
                this.nextId = 0;
                
                window.PUBSUB.publish('scene:cleared', null);
                
                if (window.PANELS) {
                    window.PANELS.updateSelectedCylinderPanel(null);
                }
            }
        };

        // Cylinder Module
        window.CYLINDER = {
            init: function() {
                console.log('ðŸ”µ Cylinder initialized');
            },
            
            createFromStroke: function(points) {
                window.CYLINDER_MANAGER.createCylinder(points);
            }
        };

        // Panels Module - Manages collapsible, drag-reorderable panels
        window.PANELS = {
            container: null,
            menu: null,
            panelToggle: null,
            isPanelVisible: true,
            panelDefinitions: [],
            panelOrder: [],
            draggedElement: null,
            draggedIndex: null,
            allExpanded: true,
            editorTarget: 'selected',
            
            init: function() {
                this.container = document.getElementById('panels-container');
                this.menu = document.getElementById('panel-menu');
                this.panelToggle = document.getElementById('panel-toggle');
                
                this.definePanels();
                this.setupPanelToggle();
                this.setupMenu();
                this.render();
                
                console.log('ðŸŽ›ï¸ Panels initialized');
            },
            
            definePanels: function() {
                this.panelDefinitions = [
                    {
                        id: 'selected',
                        title: 'Selected Cylinder',
                        collapsed: false,
                        hidden: true, // Hidden by default until something is selected
                        subPanels: [
                            {
                                id: 'width-function',
                                title: 'Width Function',
                                collapsed: false,
                                controls: [
                                    {
                                        type: 'select',
                                        id: 'selected-width-function',
                                        label: 'Width Profile',
                                        value: 'normal',
                                        options: [
                                            { value: 'normal', label: 'Constant Width' },
                                            { value: 'growing', label: 'Growing (Narrow â†’ Wide)' },
                                            { value: 'shrinking', label: 'Shrinking (Wide â†’ Narrow)' },
                                            { value: 'inverted', label: 'Inverted (Wide â†’ Narrow â†’ Wide)' }
                                        ],
                                        onChange: (value) => {
                                            const selected = window.CYLINDER_MANAGER.getSelectedCylinders();
                                            selected.forEach(cylinder => {
                                                cylinder.metadata.parameters.widthFunction = value;
                                                window.CYLINDER_MANAGER.rebuildCylinder(cylinder.id);
                                            });
                                            this.updateCurveVisualization();
                                        }
                                    },
                                    {
                                        type: 'range',
                                        id: 'selected-steepness',
                                        label: 'S-Curve Steepness',
                                        min: 1,
                                        max: 20,
                                        step: 0.5,
                                        value: 5,
                                        onChange: (value) => {
                                            const selected = window.CYLINDER_MANAGER.getSelectedCylinders();
                                            selected.forEach(cylinder => {
                                                cylinder.metadata.parameters.sCurveParams.steepness = parseFloat(value);
                                                window.CYLINDER_MANAGER.rebuildCylinder(cylinder.id);
                                            });
                                            this.updateCurveVisualization();
                                        }
                                    },
                                    {
                                        type: 'range',
                                        id: 'selected-midpoint',
                                        label: 'S-Curve Midpoint',
                                        min: 0,
                                        max: 1,
                                        step: 0.05,
                                        value: 0.5,
                                        onChange: (value) => {
                                            const selected = window.CYLINDER_MANAGER.getSelectedCylinders();
                                            selected.forEach(cylinder => {
                                                cylinder.metadata.parameters.sCurveParams.midpoint = parseFloat(value);
                                                window.CYLINDER_MANAGER.rebuildCylinder(cylinder.id);
                                            });
                                            this.updateCurveVisualization();
                                        }
                                    },
                                    {
                                        type: 'canvas',
                                        id: 'curve-visualization',
                                        label: 'Width Profile Preview'
                                    }
                                ]
                            },
                            {
                                id: 'cylinder-props',
                                title: 'Cylinder Properties',
                                collapsed: false,
                                controls: [
                                    {
                                        type: 'range',
                                        id: 'selected-radius',
                                        label: 'Radius',
                                        min: 0.1,
                                        max: 2,
                                        step: 0.1,
                                        value: 0.5,
                                        onChange: (value) => {
                                            const selected = window.CYLINDER_MANAGER.getSelectedCylinders();
                                            selected.forEach(cylinder => {
                                                cylinder.metadata.parameters.radius = parseFloat(value);
                                                window.CYLINDER_MANAGER.rebuildCylinder(cylinder.id);
                                            });
                                            this.updateCurveVisualization();
                                        }
                                    },
                                    {
                                        type: 'color',
                                        id: 'selected-color',
                                        label: 'Color',
                                        value: '#e94560',
                                        onChange: (value) => {
                                            const selected = window.CYLINDER_MANAGER.getSelectedCylinders();
                                            selected.forEach(cylinder => {
                                                cylinder.metadata.parameters.color = value;
                                                window.CYLINDER_MANAGER.rebuildCylinder(cylinder.id);
                                            });
                                        }
                                    },
                                    {
                                        type: 'button',
                                        id: 'delete-cylinder',
                                        label: 'Delete Selected',
                                        secondary: true,
                                        onClick: () => {
                                            const count = window.CYLINDER_MANAGER.selectedCylinders.length;
                                            if (count === 0) return;
                                            
                                            const confirmMsg = count === 1 ? 
                                                'Delete this cylinder?' : 
                                                `Delete ${count} cylinders?`;
                                            
                                            if (confirm(confirmMsg)) {
                                                window.CYLINDER_MANAGER.deleteSelected();
                                            }
                                        }
                                    }
                                ]
                            }
                        ]
                    },
                    {
                        id: 'groups',
                        title: 'Groups',
                        collapsed: false,
                        controls: [
                            {
                                type: 'custom',
                                id: 'group-manager',
                                render: (container) => {
                                    // Create group button
                                    const createRow = document.createElement('div');
                                    createRow.className = 'input-row';
                                    createRow.style.marginBottom = 'var(--space-3)';
                                    
                                    const input = document.createElement('input');
                                    input.type = 'text';
                                    input.placeholder = 'New group name...';
                                    input.id = 'new-group-name';
                                    
                                    const btn = document.createElement('button');
                                    btn.className = 'button';
                                    btn.textContent = '+ Create';
                                    btn.style.width = 'auto';
                                    btn.onclick = () => {
                                        const name = input.value.trim();
                                        if (name) {
                                            window.GROUP_MANAGER.createGroup(name);
                                            input.value = '';
                                            this.updateGroupsList();
                                        }
                                    };
                                    
                                    createRow.appendChild(input);
                                    createRow.appendChild(btn);
                                    container.appendChild(createRow);
                                    
                                    // Groups list
                                    const listContainer = document.createElement('div');
                                    listContainer.id = 'groups-list-container';
                                    listContainer.className = 'group-list';
                                    container.appendChild(listContainer);
                                    
                                    this.updateGroupsList();
                                }
                            }
                        ]
                    },
                    {
                        id: 'keymapper',
                        title: 'Key Mapper',
                        collapsed: false,
                        controls: [
                            {
                                type: 'custom',
                                id: 'key-mappings',
                                render: (container) => {
                                    // Render key mappings
                                    Object.keys(window.KEY_MAPPER.mappings).forEach(clickType => {
                                        const item = document.createElement('div');
                                        item.className = 'key-mapping-item';
                                        
                                        const keyCombo = document.createElement('div');
                                        keyCombo.className = 'key-combo';
                                        
                                        // Format key combo with kbd tags
                                        const parts = clickType.split('+');
                                        keyCombo.innerHTML = parts.map(part => {
                                            const display = part === 'click' ? 'Click' : part.charAt(0).toUpperCase() + part.slice(1);
                                            return `<span class="kbd">${display}</span>`;
                                        }).join(' + ');
                                        
                                        const select = document.createElement('select');
                                        Object.keys(window.KEY_MAPPER.actions).forEach(actionKey => {
                                            const option = document.createElement('option');
                                            option.value = actionKey;
                                            option.textContent = window.KEY_MAPPER.actions[actionKey];
                                            option.selected = window.KEY_MAPPER.mappings[clickType] === actionKey;
                                            select.appendChild(option);
                                        });
                                        
                                        select.addEventListener('change', (e) => {
                                            window.KEY_MAPPER.setMapping(clickType, e.target.value);
                                        });
                                        
                                        item.appendChild(keyCombo);
                                        item.appendChild(select);
                                        container.appendChild(item);
                                    });
                                    
                                    // Reset button
                                    const resetBtn = document.createElement('button');
                                    resetBtn.className = 'button secondary';
                                    resetBtn.textContent = 'Reset to Defaults';
                                    resetBtn.style.marginTop = 'var(--space-2)';
                                    resetBtn.onclick = () => {
                                        window.KEY_MAPPER.reset();
                                        this.render();
                                    };
                                    container.appendChild(resetBtn);
                                }
                            }
                        ]
                    },
                    {
                        id: 'registration',
                        title: 'Registration',
                        collapsed: true,
                        subPanels: [
                            {
                                id: 'z-mapping',
                                title: 'Z-Index Mapping',
                                collapsed: false,
                                controls: [
                                    {
                                        type: 'select',
                                        id: 'z-mode',
                                        label: 'Mode',
                                        value: 'linear',
                                        options: [
                                            { value: 'linear', label: 'Linear' },
                                            { value: 'exponential', label: 'Exponential' },
                                            { value: 'sigmoid', label: 'Sigmoid' }
                                        ],
                                        onChange: (value) => {
                                            window.REGISTRATION.parameters.zIndex.mode = value;
                                            window.REGISTRATION.save();
                                            window.REGISTRATION.updateZMapping();
                                        }
                                    },
                                    {
                                        type: 'range-compact',
                                        id: 'z-min',
                                        label: 'Min Z',
                                        min: -50,
                                        max: 0,
                                        step: 1,
                                        value: -10,
                                        onChange: (value) => {
                                            window.REGISTRATION.parameters.zIndex.min = parseFloat(value);
                                            window.REGISTRATION.save();
                                            window.REGISTRATION.updateZMapping();
                                        }
                                    },
                                    {
                                        type: 'range-compact',
                                        id: 'z-max',
                                        label: 'Max Z',
                                        min: 0,
                                        max: 50,
                                        step: 1,
                                        value: 10,
                                        onChange: (value) => {
                                            window.REGISTRATION.parameters.zIndex.max = parseFloat(value);
                                            window.REGISTRATION.save();
                                            window.REGISTRATION.updateZMapping();
                                        }
                                    },
                                    {
                                        type: 'range-compact',
                                        id: 'z-scale',
                                        label: 'Scale',
                                        min: 0.1,
                                        max: 10,
                                        step: 0.1,
                                        value: 3,
                                        onChange: (value) => {
                                            window.REGISTRATION.parameters.zIndex.scale = parseFloat(value);
                                            window.REGISTRATION.save();
                                            window.REGISTRATION.updateZMapping();
                                        }
                                    }
                                ]
                            },
                            {
                                id: 'mapping-params',
                                title: 'Mapping Parameters',
                                collapsed: false,
                                controls: [
                                    {
                                        type: 'range-compact',
                                        id: 'screen-scale',
                                        label: 'Screen Scale',
                                        min: 0.001,
                                        max: 0.1,
                                        step: 0.001,
                                        value: 0.02,
                                        onChange: (value) => {
                                            window.REGISTRATION.parameters.screenScale = parseFloat(value);
                                            window.REGISTRATION.save();
                                        }
                                    },
                                    {
                                        type: 'range-compact',
                                        id: 'direction-weight',
                                        label: 'Direction Weight',
                                        min: 0,
                                        max: 2,
                                        step: 0.1,
                                        value: 1,
                                        onChange: (value) => {
                                            window.REGISTRATION.parameters.directionWeight = parseFloat(value);
                                            window.REGISTRATION.save();
                                        }
                                    }
                                ]
                            },
                            {
                                id: 'neural-network',
                                title: 'Neural Network (Hooks)',
                                collapsed: false,
                                controls: [
                                    {
                                        type: 'checkbox',
                                        id: 'nn-enabled',
                                        label: 'Enable NN Hooks',
                                        value: false,
                                        onChange: (value) => {
                                            window.REGISTRATION.neuralHooks.enabled = value;
                                            window.REGISTRATION.save();
                                        }
                                    },
                                    {
                                        type: 'range-compact',
                                        id: 'nn-weight',
                                        label: 'NN Weight',
                                        min: 0,
                                        max: 1,
                                        step: 0.1,
                                        value: 0,
                                        onChange: (value) => {
                                            window.REGISTRATION.parameters.nnWeight = parseFloat(value);
                                            window.REGISTRATION.save();
                                        }
                                    },
                                    {
                                        type: 'button',
                                        id: 'export-training-data',
                                        label: 'Export Training Data',
                                        secondary: true,
                                        onClick: () => {
                                            window.REGISTRATION.exportTrainingData();
                                            this.showNotification('Training data exported!');
                                        }
                                    }
                                ]
                            }
                        ]
                    },
                    {
                        id: 'editor',
                        title: 'Cylinder Editor',
                        collapsed: false,
                        subPanels: [
                            {
                                id: 'apply-to',
                                title: 'Apply To',
                                collapsed: false,
                                controls: [
                                    {
                                        type: 'select',
                                        id: 'apply-target',
                                        label: 'Target',
                                        value: 'selected',
                                        options: [
                                            { value: 'selected', label: 'Selected Only' },
                                            { value: 'all', label: 'All Cylinders' },
                                            { value: 'group', label: 'Selected Group' },
                                            { value: 'group-recursive', label: 'Group + Nested' }
                                        ],
                                        onChange: (value) => {
                                            // Store selection
                                            this.editorTarget = value;
                                        }
                                    }
                                ]
                            },
                            {
                                id: 'compact-controls',
                                title: 'Properties',
                                collapsed: false,
                                controls: [
                                    {
                                        type: 'range-compact',
                                        id: 'editor-radius',
                                        label: 'Radius',
                                        min: 0.1,
                                        max: 2,
                                        step: 0.1,
                                        value: 0.5
                                    },
                                    {
                                        type: 'range-compact',
                                        id: 'editor-segments',
                                        label: 'Segments',
                                        min: 3,
                                        max: 32,
                                        step: 1,
                                        value: 16
                                    },
                                    {
                                        type: 'range-compact',
                                        id: 'editor-metalness',
                                        label: 'Metalness',
                                        min: 0,
                                        max: 1,
                                        step: 0.1,
                                        value: 0.3
                                    },
                                    {
                                        type: 'range-compact',
                                        id: 'editor-roughness',
                                        label: 'Roughness',
                                        min: 0,
                                        max: 1,
                                        step: 0.1,
                                        value: 0.4
                                    },
                                    {
                                        type: 'button',
                                        id: 'apply-properties',
                                        label: 'Apply Properties',
                                        onClick: () => {
                                            this.applyEditorProperties();
                                        }
                                    }
                                ]
                            }
                        ]
                    },
                    {
                        id: 'drawing',
                        title: 'Drawing Mode',
                        collapsed: false,
                        controls: [
                            {
                                type: 'checkbox',
                                id: 'single-width-mode',
                                label: 'Single Width Mode',
                                value: window.CONFIG.settings.singleWidthMode,
                                onChange: (value) => {
                                    window.CONFIG.settings.singleWidthMode = value;
                                    window.STORAGE.save();
                                }
                            }
                        ]
                    },
                    {
                        id: 'cylinder',
                        title: 'Cylinder Properties',
                        collapsed: false,
                        subPanels: [
                            {
                                id: 'dimensions',
                                title: 'Dimensions',
                                collapsed: false,
                                controls: [
                                    {
                                        type: 'range',
                                        id: 'radius',
                                        label: 'Radius',
                                        min: 0.1,
                                        max: 2,
                                        step: 0.1,
                                        value: window.CONFIG.settings.radius,
                                        onChange: (value) => {
                                            window.CONFIG.settings.radius = parseFloat(value);
                                            window.STORAGE.save();
                                        }
                                    },
                                    {
                                        type: 'range',
                                        id: 'depth',
                                        label: 'Depth Scale',
                                        min: 0.1,
                                        max: 3,
                                        step: 0.1,
                                        value: window.CONFIG.settings.depth,
                                        onChange: (value) => {
                                            window.CONFIG.settings.depth = parseFloat(value);
                                            window.STORAGE.save();
                                        }
                                    }
                                ]
                            },
                            {
                                id: 'geometry',
                                title: 'Geometry',
                                collapsed: false,
                                controls: [
                                    {
                                        type: 'range',
                                        id: 'segments',
                                        label: 'Radial Segments',
                                        min: 3,
                                        max: 32,
                                        step: 1,
                                        value: window.CONFIG.settings.segments,
                                        onChange: (value) => {
                                            window.CONFIG.settings.segments = parseInt(value);
                                            window.STORAGE.save();
                                        }
                                    }
                                ]
                            }
                        ]
                    },
                    {
                        id: 'curve',
                        title: 'Curve Approximation',
                        collapsed: false,
                        controls: [
                            {
                                type: 'select',
                                id: 'interpolation',
                                label: 'Interpolation Method',
                                value: window.CONFIG.settings.interpolation,
                                options: [
                                    { value: 'catmull-rom', label: 'Catmull-Rom Spline' },
                                    { value: 'linear', label: 'Linear' },
                                    { value: 'bezier', label: 'Bezier Curve' }
                                ],
                                onChange: (value) => {
                                    window.CONFIG.settings.interpolation = value;
                                    window.STORAGE.save();
                                }
                            },
                            {
                                type: 'range',
                                id: 'curve-points',
                                label: 'Curve Points',
                                min: 20,
                                max: 300,
                                step: 10,
                                value: window.CONFIG.settings.curvePoints,
                                onChange: (value) => {
                                    window.CONFIG.settings.curvePoints = parseInt(value);
                                    window.STORAGE.save();
                                }
                            },
                            {
                                type: 'range',
                                id: 'smoothing',
                                label: 'Smoothing',
                                min: 0,
                                max: 1,
                                step: 0.1,
                                value: window.CONFIG.settings.smoothing,
                                onChange: (value) => {
                                    window.CONFIG.settings.smoothing = parseFloat(value);
                                    window.STORAGE.save();
                                }
                            }
                        ]
                    },
                    {
                        id: 'material',
                        title: 'Material',
                        collapsed: false,
                        subPanels: [
                            {
                                id: 'color',
                                title: 'Color',
                                collapsed: false,
                                controls: [
                                    {
                                        type: 'color',
                                        id: 'color',
                                        label: 'Base Color',
                                        value: window.CONFIG.settings.color,
                                        onChange: (value) => {
                                            window.CONFIG.settings.color = value;
                                            window.STORAGE.save();
                                        }
                                    }
                                ]
                            },
                            {
                                id: 'properties',
                                title: 'Properties',
                                collapsed: false,
                                controls: [
                                    {
                                        type: 'range',
                                        id: 'metalness',
                                        label: 'Metalness',
                                        min: 0,
                                        max: 1,
                                        step: 0.1,
                                        value: window.CONFIG.settings.metalness,
                                        onChange: (value) => {
                                            window.CONFIG.settings.metalness = parseFloat(value);
                                            window.STORAGE.save();
                                        }
                                    },
                                    {
                                        type: 'range',
                                        id: 'roughness',
                                        label: 'Roughness',
                                        min: 0,
                                        max: 1,
                                        step: 0.1,
                                        value: window.CONFIG.settings.roughness,
                                        onChange: (value) => {
                                            window.CONFIG.settings.roughness = parseFloat(value);
                                            window.STORAGE.save();
                                        }
                                    }
                                ]
                            }
                        ]
                    },
                    {
                        id: 'storage',
                        title: 'Storage & Settings',
                        collapsed: false,
                        controls: [
                            {
                                type: 'button',
                                id: 'save-settings',
                                label: 'Save Settings',
                                onClick: () => {
                                    window.STORAGE.save();
                                    this.showNotification('Settings saved!');
                                }
                            },
                            {
                                type: 'button',
                                id: 'export-settings',
                                label: 'Export Configuration',
                                secondary: true,
                                onClick: () => {
                                    window.STORAGE.export();
                                }
                            },
                            {
                                type: 'button',
                                id: 'import-settings',
                                label: 'Import Configuration',
                                secondary: true,
                                onClick: () => {
                                    const input = document.createElement('input');
                                    input.type = 'file';
                                    input.accept = '.json';
                                    input.onchange = (e) => {
                                        const file = e.target.files[0];
                                        if (file) {
                                            window.STORAGE.import(file).then(() => {
                                                this.showNotification('Configuration imported!');
                                            });
                                        }
                                    };
                                    input.click();
                                }
                            },
                            {
                                type: 'button',
                                id: 'clear-storage',
                                label: 'Clear Storage',
                                secondary: true,
                                onClick: () => {
                                    if (confirm('Are you sure you want to clear all saved settings?')) {
                                        window.STORAGE.clear();
                                        this.showNotification('Storage cleared!');
                                    }
                                }
                            }
                        ]
                    },
                    {
                        id: 'actions',
                        title: 'Actions',
                        collapsed: false,
                        controls: [
                            {
                                type: 'button',
                                id: 'clear-scene',
                                label: 'Clear Scene',
                                onClick: () => {
                                    window.SCENE.clear();
                                }
                            }
                        ]
                    }
                ];
                
                // Initialize panel order (including 'selected' even though it's hidden initially)
                this.panelOrder = this.panelDefinitions.map(p => p.id);
                
                // Restore collapsed states and order from storage
                if (window.STORAGE.storedPanelsState) {
                    const stored = window.STORAGE.storedPanelsState;
                    
                    if (stored.order) {
                        this.panelOrder = stored.order;
                    }
                    
                    if (stored.collapsed) {
                        this.panelDefinitions.forEach(panel => {
                            if (stored.collapsed[panel.id] !== undefined) {
                                panel.collapsed = stored.collapsed[panel.id];
                            }
                            
                            if (panel.subPanels) {
                                panel.subPanels.forEach(subPanel => {
                                    const key = `${panel.id}_${subPanel.id}`;
                                    if (stored.collapsed[key] !== undefined) {
                                        subPanel.collapsed = stored.collapsed[key];
                                    }
                                });
                            }
                        });
                    }
                }
            },
            
            setupPanelToggle: function() {
                this.panelToggle.addEventListener('click', () => {
                    this.isPanelVisible = !this.isPanelVisible;
                    document.getElementById('side-panel').classList.toggle('hidden');
                    this.panelToggle.textContent = this.isPanelVisible ? 'â—€' : 'â–¶';
                });
            },
            
            setupMenu: function() {
                // Create expand/collapse all button
                const expandCollapseBtn = document.createElement('button');
                expandCollapseBtn.className = 'menu-button';
                expandCollapseBtn.id = 'expand-collapse-all';
                expandCollapseBtn.innerHTML = '<span class="menu-icon">â–¼</span> Collapse All';
                expandCollapseBtn.addEventListener('click', () => this.toggleExpandCollapseAll());
                
                this.menu.appendChild(expandCollapseBtn);
            },
            
            toggleExpandCollapseAll: function() {
                this.allExpanded = !this.allExpanded;
                const btn = document.getElementById('expand-collapse-all');
                
                if (this.allExpanded) {
                    // Expand all
                    btn.innerHTML = '<span class="menu-icon">â–¼</span> Collapse All';
                    this.expandAll();
                } else {
                    // Collapse all
                    btn.innerHTML = '<span class="menu-icon">â–¶</span> Expand All';
                    this.collapseAll();
                }
                
                window.STORAGE.save();
            },
            
            expandAll: function() {
                // Expand all panels
                this.panelDefinitions.forEach(panel => {
                    panel.collapsed = false;
                    
                    // Expand all sub-panels
                    if (panel.subPanels) {
                        panel.subPanels.forEach(subPanel => {
                            subPanel.collapsed = false;
                        });
                    }
                });
                
                this.render();
            },
            
            collapseAll: function() {
                // Collapse all panels
                this.panelDefinitions.forEach(panel => {
                    panel.collapsed = true;
                    
                    // Collapse all sub-panels
                    if (panel.subPanels) {
                        panel.subPanels.forEach(subPanel => {
                            subPanel.collapsed = true;
                        });
                    }
                });
                
                this.render();
            },
            
            render: function() {
                this.container.innerHTML = '';
                
                // Render panels in order
                this.panelOrder.forEach(panelId => {
                    const panelDef = this.panelDefinitions.find(p => p.id === panelId);
                    if (panelDef && !panelDef.hidden) {
                        const panelEl = this.createPanel(panelDef);
                        this.container.appendChild(panelEl);
                    }
                });
                
                // Update expand/collapse all button state
                this.updateExpandCollapseButton();
                
                // Update curve visualization if selected cylinders exist
                if (window.CYLINDER_MANAGER && window.CYLINDER_MANAGER.selectedCylinders.length > 0) {
                    setTimeout(() => this.updateCurveVisualization(), 0);
                }
                
                // Update groups list if groups panel exists
                setTimeout(() => {
                    const groupsList = document.getElementById('groups-list-container');
                    if (groupsList) {
                        this.updateGroupsList();
                    }
                    
                    // Load registration parameters if panel exists
                    if (window.REGISTRATION) {
                        this.loadRegistrationValues();
                    }
                }, 0);
            },
            
            loadRegistrationValues: function() {
                const reg = window.REGISTRATION;
                if (!reg) return;
                
                // Z-Index parameters
                const zModeEl = document.getElementById('z-mode');
                if (zModeEl) zModeEl.value = reg.parameters.zIndex.mode;
                
                const zMinEl = document.getElementById('z-min');
                const zMinVal = document.getElementById('z-min-value');
                if (zMinEl) {
                    zMinEl.value = reg.parameters.zIndex.min;
                    if (zMinVal) zMinVal.textContent = reg.parameters.zIndex.min;
                }
                
                const zMaxEl = document.getElementById('z-max');
                const zMaxVal = document.getElementById('z-max-value');
                if (zMaxEl) {
                    zMaxEl.value = reg.parameters.zIndex.max;
                    if (zMaxVal) zMaxVal.textContent = reg.parameters.zIndex.max;
                }
                
                const zScaleEl = document.getElementById('z-scale');
                const zScaleVal = document.getElementById('z-scale-value');
                if (zScaleEl) {
                    zScaleEl.value = reg.parameters.zIndex.scale;
                    if (zScaleVal) zScaleVal.textContent = reg.parameters.zIndex.scale;
                }
                
                // Mapping parameters
                const screenScaleEl = document.getElementById('screen-scale');
                const screenScaleVal = document.getElementById('screen-scale-value');
                if (screenScaleEl) {
                    screenScaleEl.value = reg.parameters.screenScale;
                    if (screenScaleVal) screenScaleVal.textContent = reg.parameters.screenScale.toFixed(3);
                }
                
                const dirWeightEl = document.getElementById('direction-weight');
                const dirWeightVal = document.getElementById('direction-weight-value');
                if (dirWeightEl) {
                    dirWeightEl.value = reg.parameters.directionWeight;
                    if (dirWeightVal) dirWeightVal.textContent = reg.parameters.directionWeight;
                }
                
                // Neural network
                const nnEnabledEl = document.getElementById('nn-enabled');
                if (nnEnabledEl) nnEnabledEl.checked = reg.neuralHooks.enabled;
                
                const nnWeightEl = document.getElementById('nn-weight');
                const nnWeightVal = document.getElementById('nn-weight-value');
                if (nnWeightEl) {
                    nnWeightEl.value = reg.parameters.nnWeight;
                    if (nnWeightVal) nnWeightVal.textContent = reg.parameters.nnWeight;
                }
            },
            
            updateExpandCollapseButton: function() {
                const btn = document.getElementById('expand-collapse-all');
                if (!btn) return;
                
                // Check if any panels or sub-panels are collapsed
                let anyCollapsed = false;
                for (const panel of this.panelDefinitions) {
                    if (panel.collapsed) {
                        anyCollapsed = true;
                        break;
                    }
                    if (panel.subPanels) {
                        for (const subPanel of panel.subPanels) {
                            if (subPanel.collapsed) {
                                anyCollapsed = true;
                                break;
                            }
                        }
                        if (anyCollapsed) break;
                    }
                }
                
                this.allExpanded = !anyCollapsed;
                
                if (this.allExpanded) {
                    btn.innerHTML = '<span class="menu-icon">â–¼</span> Collapse All';
                } else {
                    btn.innerHTML = '<span class="menu-icon">â–¶</span> Expand All';
                }
            },
            
            rebuild: function() {
                this.definePanels();
                this.setupMenu();
                this.render();
            },
            
            createPanel: function(panelDef) {
                const panel = document.createElement('div');
                panel.className = 'panel';
                panel.dataset.panelId = panelDef.id;
                
                // Header
                const header = document.createElement('div');
                header.className = 'panel-header';
                header.draggable = true; // Entire header is draggable
                
                const title = document.createElement('div');
                title.className = 'panel-title';
                title.textContent = panelDef.title;
                
                const collapseBtn = document.createElement('button');
                collapseBtn.className = 'panel-collapse-btn' + (panelDef.collapsed ? ' collapsed' : '');
                collapseBtn.innerHTML = 'â–¼';
                collapseBtn.addEventListener('click', (e) => {
                    e.stopPropagation(); // Prevent drag when clicking collapse button
                    this.togglePanel(panelDef.id);
                });
                
                header.appendChild(title);
                header.appendChild(collapseBtn);
                
                // Body
                const body = document.createElement('div');
                body.className = 'panel-body' + (panelDef.collapsed ? ' collapsed' : '');
                
                // Add controls
                if (panelDef.controls) {
                    panelDef.controls.forEach(control => {
                        body.appendChild(this.createControl(control));
                    });
                }
                
                // Add sub-panels
                if (panelDef.subPanels) {
                    panelDef.subPanels.forEach(subPanelDef => {
                        body.appendChild(this.createSubPanel(panelDef.id, subPanelDef));
                    });
                }
                
                panel.appendChild(header);
                panel.appendChild(body);
                
                // Drag events for panel headers only
                this.setupPanelDragEvents(panel, header);
                
                return panel;
            },
            
            createSubPanel: function(parentId, subPanelDef) {
                const subPanel = document.createElement('div');
                subPanel.className = 'sub-panel';
                subPanel.dataset.subPanelId = subPanelDef.id;
                subPanel.dataset.parentId = parentId;
                
                // Header
                const header = document.createElement('div');
                header.className = 'sub-panel-header';
                header.draggable = true; // Entire header is draggable
                
                const title = document.createElement('div');
                title.className = 'sub-panel-title';
                title.textContent = subPanelDef.title;
                
                const collapseBtn = document.createElement('button');
                collapseBtn.className = 'sub-panel-collapse-btn' + (subPanelDef.collapsed ? ' collapsed' : '');
                collapseBtn.innerHTML = 'â–¼';
                collapseBtn.addEventListener('click', (e) => {
                    e.stopPropagation(); // Prevent drag when clicking collapse button
                    this.toggleSubPanel(parentId, subPanelDef.id);
                });
                
                header.appendChild(title);
                header.appendChild(collapseBtn);
                
                // Body
                const body = document.createElement('div');
                body.className = 'sub-panel-body' + (subPanelDef.collapsed ? ' collapsed' : '');
                
                // Add controls
                if (subPanelDef.controls) {
                    subPanelDef.controls.forEach(control => {
                        body.appendChild(this.createControl(control));
                    });
                }
                
                subPanel.appendChild(header);
                subPanel.appendChild(body);
                
                // Drag events for sub-panel headers only
                this.setupSubPanelDragEvents(subPanel, header);
                
                return subPanel;
            },
            
            createControl: function(control) {
                const group = document.createElement('div');
                group.className = 'control-group';
                
                if (control.type === 'range') {
                    const label = document.createElement('div');
                    label.className = 'control-label';
                    label.innerHTML = `
                        <span>${control.label}</span>
                        <span class="control-value" id="${control.id}-value">${control.value}</span>
                    `;
                    
                    const input = document.createElement('input');
                    input.type = 'range';
                    input.id = control.id;
                    input.min = control.min;
                    input.max = control.max;
                    input.step = control.step;
                    input.value = control.value;
                    input.addEventListener('input', (e) => {
                        document.getElementById(`${control.id}-value`).textContent = e.target.value;
                        control.onChange(e.target.value);
                    });
                    
                    group.appendChild(label);
                    group.appendChild(input);
                }
                else if (control.type === 'range-compact') {
                    group.className = 'control-group compact';
                    
                    const label = document.createElement('div');
                    label.className = 'control-label compact';
                    label.innerHTML = `
                        <span>${control.label}</span>
                        <span class="control-value compact" id="${control.id}-value">${control.value}</span>
                    `;
                    
                    const input = document.createElement('input');
                    input.type = 'range';
                    input.className = 'compact';
                    input.id = control.id;
                    input.min = control.min;
                    input.max = control.max;
                    input.step = control.step;
                    input.value = control.value;
                    input.addEventListener('input', (e) => {
                        document.getElementById(`${control.id}-value`).textContent = e.target.value;
                        if (control.onChange) {
                            control.onChange(e.target.value);
                        }
                    });
                    
                    group.appendChild(label);
                    group.appendChild(input);
                }
                else if (control.type === 'select') {
                    const label = document.createElement('div');
                    label.className = 'control-label';
                    label.innerHTML = `<span>${control.label}</span>`;
                    
                    const select = document.createElement('select');
                    select.id = control.id;
                    control.options.forEach(opt => {
                        const option = document.createElement('option');
                        option.value = opt.value;
                        option.textContent = opt.label;
                        option.selected = opt.value === control.value;
                        select.appendChild(option);
                    });
                    select.addEventListener('change', (e) => control.onChange(e.target.value));
                    
                    group.appendChild(label);
                    group.appendChild(select);
                }
                else if (control.type === 'color') {
                    const label = document.createElement('div');
                    label.className = 'control-label';
                    label.innerHTML = `<span>${control.label}</span>`;
                    
                    const input = document.createElement('input');
                    input.type = 'color';
                    input.id = control.id;
                    input.value = control.value;
                    input.addEventListener('input', (e) => control.onChange(e.target.value));
                    
                    group.appendChild(label);
                    group.appendChild(input);
                }
                else if (control.type === 'checkbox') {
                    const checkboxGroup = document.createElement('div');
                    checkboxGroup.className = 'checkbox-group';
                    
                    const input = document.createElement('input');
                    input.type = 'checkbox';
                    input.id = control.id;
                    input.checked = control.value;
                    input.addEventListener('change', (e) => control.onChange(e.target.checked));
                    
                    const label = document.createElement('label');
                    label.className = 'checkbox-label';
                    label.htmlFor = control.id;
                    label.textContent = control.label;
                    
                    checkboxGroup.appendChild(input);
                    checkboxGroup.appendChild(label);
                    group.appendChild(checkboxGroup);
                }
                else if (control.type === 'button') {
                    const button = document.createElement('button');
                    button.className = 'button' + (control.secondary ? ' secondary' : '');
                    button.id = control.id;
                    button.textContent = control.label;
                    button.addEventListener('click', control.onClick);
                    group.appendChild(button);
                }
                else if (control.type === 'canvas') {
                    const label = document.createElement('div');
                    label.className = 'control-label';
                    label.innerHTML = `<span>${control.label}</span>`;
                    
                    const vizContainer = document.createElement('div');
                    vizContainer.className = 'curve-visualization';
                    
                    const canvas = document.createElement('canvas');
                    canvas.className = 'curve-canvas';
                    canvas.id = control.id;
                    canvas.width = 280;
                    canvas.height = 120;
                    
                    vizContainer.appendChild(canvas);
                    
                    group.appendChild(label);
                    group.appendChild(vizContainer);
                }
                else if (control.type === 'custom') {
                    // Custom control with render function
                    if (control.render) {
                        control.render(group);
                    }
                }
                
                return group;
            },
            
            togglePanel: function(panelId) {
                const panelDef = this.panelDefinitions.find(p => p.id === panelId);
                if (!panelDef) return;
                
                panelDef.collapsed = !panelDef.collapsed;
                
                const panelEl = this.container.querySelector(`[data-panel-id="${panelId}"]`);
                const collapseBtn = panelEl.querySelector('.panel-collapse-btn');
                const body = panelEl.querySelector('.panel-body');
                
                collapseBtn.classList.toggle('collapsed');
                body.classList.toggle('collapsed');
                
                this.updateExpandCollapseButton();
                window.STORAGE.save();
            },
            
            toggleSubPanel: function(parentId, subPanelId) {
                const panelDef = this.panelDefinitions.find(p => p.id === parentId);
                if (!panelDef || !panelDef.subPanels) return;
                
                const subPanelDef = panelDef.subPanels.find(sp => sp.id === subPanelId);
                if (!subPanelDef) return;
                
                subPanelDef.collapsed = !subPanelDef.collapsed;
                
                const subPanelEl = this.container.querySelector(`[data-sub-panel-id="${subPanelId}"][data-parent-id="${parentId}"]`);
                const collapseBtn = subPanelEl.querySelector('.sub-panel-collapse-btn');
                const body = subPanelEl.querySelector('.sub-panel-body');
                
                collapseBtn.classList.toggle('collapsed');
                body.classList.toggle('collapsed');
                
                this.updateExpandCollapseButton();
                window.STORAGE.save();
            },
            
            setupPanelDragEvents: function(panel, header) {
                header.addEventListener('dragstart', (e) => {
                    this.draggedElement = panel;
                    this.draggedIndex = Array.from(this.container.children).indexOf(panel);
                    panel.classList.add('dragging');
                    e.dataTransfer.effectAllowed = 'move';
                    e.dataTransfer.setData('text/html', panel.innerHTML);
                });
                
                header.addEventListener('dragend', (e) => {
                    panel.classList.remove('dragging');
                    this.draggedElement = null;
                    this.draggedIndex = null;
                    
                    // Remove all drag-over classes
                    this.container.querySelectorAll('.drag-over').forEach(el => {
                        el.classList.remove('drag-over');
                    });
                });
                
                panel.addEventListener('dragover', (e) => {
                    e.preventDefault();
                    e.dataTransfer.dropEffect = 'move';
                    
                    if (this.draggedElement && this.draggedElement !== panel && this.draggedElement.classList.contains('panel')) {
                        panel.classList.add('drag-over');
                    }
                });
                
                panel.addEventListener('dragleave', (e) => {
                    // Only remove if we're actually leaving the panel
                    if (e.target === panel) {
                        panel.classList.remove('drag-over');
                    }
                });
                
                panel.addEventListener('drop', (e) => {
                    e.preventDefault();
                    panel.classList.remove('drag-over');
                    
                    if (this.draggedElement && this.draggedElement !== panel && this.draggedElement.classList.contains('panel')) {
                        const dropIndex = Array.from(this.container.children).indexOf(panel);
                        
                        // Reorder panel definitions
                        const draggedId = this.draggedElement.dataset.panelId;
                        const dropId = panel.dataset.panelId;
                        
                        const draggedOrderIndex = this.panelOrder.indexOf(draggedId);
                        const dropOrderIndex = this.panelOrder.indexOf(dropId);
                        
                        this.panelOrder.splice(draggedOrderIndex, 1);
                        this.panelOrder.splice(dropOrderIndex, 0, draggedId);
                        
                        this.render();
                        window.STORAGE.save();
                    }
                });
            },
            
            setupSubPanelDragEvents: function(subPanel, header) {
                header.addEventListener('dragstart', (e) => {
                    this.draggedElement = subPanel;
                    subPanel.classList.add('dragging');
                    e.dataTransfer.effectAllowed = 'move';
                    e.dataTransfer.setData('text/html', subPanel.innerHTML);
                    e.stopPropagation();
                });
                
                header.addEventListener('dragend', (e) => {
                    subPanel.classList.remove('dragging');
                    this.draggedElement = null;
                    
                    this.container.querySelectorAll('.drag-over').forEach(el => {
                        el.classList.remove('drag-over');
                    });
                    
                    e.stopPropagation();
                });
                
                subPanel.addEventListener('dragover', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    e.dataTransfer.dropEffect = 'move';
                    
                    if (this.draggedElement && 
                        this.draggedElement !== subPanel && 
                        this.draggedElement.classList.contains('sub-panel')) {
                        subPanel.classList.add('drag-over');
                    }
                });
                
                subPanel.addEventListener('dragleave', (e) => {
                    // Only remove if we're actually leaving the sub-panel
                    if (e.target === subPanel) {
                        subPanel.classList.remove('drag-over');
                    }
                    e.stopPropagation();
                });
                
                subPanel.addEventListener('drop', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    subPanel.classList.remove('drag-over');
                    
                    if (this.draggedElement && 
                        this.draggedElement !== subPanel && 
                        this.draggedElement.classList.contains('sub-panel')) {
                        
                        const draggedParentId = this.draggedElement.dataset.parentId;
                        const draggedSubPanelId = this.draggedElement.dataset.subPanelId;
                        const dropParentId = subPanel.dataset.parentId;
                        const dropSubPanelId = subPanel.dataset.subPanelId;
                        
                        // Only allow reordering within same parent
                        if (draggedParentId === dropParentId) {
                            const parentDef = this.panelDefinitions.find(p => p.id === draggedParentId);
                            if (parentDef && parentDef.subPanels) {
                                const draggedIndex = parentDef.subPanels.findIndex(sp => sp.id === draggedSubPanelId);
                                const dropIndex = parentDef.subPanels.findIndex(sp => sp.id === dropSubPanelId);
                                
                                const [draggedSubPanel] = parentDef.subPanels.splice(draggedIndex, 1);
                                parentDef.subPanels.splice(dropIndex, 0, draggedSubPanel);
                                
                                this.render();
                                window.STORAGE.save();
                            }
                        }
                    }
                });
            },
            
            showNotification: function(message) {
                // Simple notification (could be enhanced)
                console.log('ðŸ“¢', message);
                
                // Create a temporary notification element
                const notification = document.createElement('div');
                notification.style.cssText = `
                    position: fixed;
                    top: 20px;
                    right: 380px;
                    background: var(--bg-secondary);
                    color: var(--text-title);
                    padding: 12px 20px;
                    border-radius: 8px;
                    border: 1px solid var(--accent-primary);
                    box-shadow: var(--shadow-md);
                    z-index: 1000;
                    animation: slideIn 0.3s ease;
                `;
                notification.textContent = message;
                
                document.body.appendChild(notification);
                
                setTimeout(() => {
                    notification.style.animation = 'slideOut 0.3s ease';
                    setTimeout(() => notification.remove(), 300);
                }, 2000);
            },
            
            updateSelectedCylinderPanel: function(cylinder) {
                const selectedPanel = this.panelDefinitions.find(p => p.id === 'selected');
                if (!selectedPanel) return;
                
                if (cylinder) {
                    // Show panel
                    selectedPanel.hidden = false;
                    
                    // Check if multi-selection
                    if (cylinder.isMultiSelection) {
                        // Multi-selection mode
                        selectedPanel.title = `Selected (${cylinder.count})`;
                        
                        // Re-render to show panel with updated title
                        this.render();
                        
                        // Disable individual cylinder controls for multi-selection
                        setTimeout(() => {
                            // Disable width function controls (only applies to single cylinder)
                            const widthFuncSelect = document.getElementById('selected-width-function');
                            if (widthFuncSelect) widthFuncSelect.disabled = true;
                            
                            const steepnessInput = document.getElementById('selected-steepness');
                            if (steepnessInput) steepnessInput.disabled = true;
                            
                            const midpointInput = document.getElementById('selected-midpoint');
                            if (midpointInput) midpointInput.disabled = true;
                            
                            // Note: Keep radius and color enabled for batch editing
                        }, 0);
                        
                        return;
                    }
                    
                    // Single selection mode
                    selectedPanel.title = 'Selected Cylinder';
                    
                    const params = cylinder.metadata.parameters;
                    
                    // Re-render to show panel
                    this.render();
                    
                    // Then update control values
                    setTimeout(() => {
                        // Update width function
                        const widthFuncSelect = document.getElementById('selected-width-function');
                        if (widthFuncSelect) {
                            widthFuncSelect.value = params.widthFunction;
                            widthFuncSelect.disabled = false;
                        }
                        
                        // Update steepness
                        const steepnessInput = document.getElementById('selected-steepness');
                        const steepnessValue = document.getElementById('selected-steepness-value');
                        if (steepnessInput) {
                            steepnessInput.value = params.sCurveParams.steepness;
                            steepnessInput.disabled = false;
                            if (steepnessValue) steepnessValue.textContent = params.sCurveParams.steepness;
                        }
                        
                        // Update midpoint
                        const midpointInput = document.getElementById('selected-midpoint');
                        const midpointValue = document.getElementById('selected-midpoint-value');
                        if (midpointInput) {
                            midpointInput.value = params.sCurveParams.midpoint;
                            midpointInput.disabled = false;
                            if (midpointValue) midpointValue.textContent = params.sCurveParams.midpoint;
                        }
                        
                        // Update radius
                        const radiusInput = document.getElementById('selected-radius');
                        const radiusValue = document.getElementById('selected-radius-value');
                        if (radiusInput) {
                            radiusInput.value = params.radius;
                            if (radiusValue) radiusValue.textContent = params.radius;
                        }
                        
                        // Update color
                        const colorInput = document.getElementById('selected-color');
                        if (colorInput) colorInput.value = params.color;
                        
                        // Update visualization
                        this.updateCurveVisualization();
                    }, 0);
                } else {
                    // Hide panel
                    selectedPanel.hidden = true;
                    selectedPanel.title = 'Selected Cylinder'; // Reset title
                    
                    // Re-render to hide panel
                    this.render();
                }
            },
            
            updateCurveVisualization: function() {
                const canvas = document.getElementById('curve-visualization');
                if (!canvas) return;
                
                const selected = window.CYLINDER_MANAGER.getSelectedCylinders();
                if (selected.length === 0) return;
                
                // Use first selected cylinder for visualization
                const cylinder = selected[0];
                
                const ctx = canvas.getContext('2d');
                const width = canvas.width;
                const height = canvas.height;
                const padding = 20;
                
                // Clear canvas
                ctx.fillStyle = '#1a1a2e';
                ctx.fillRect(0, 0, width, height);
                
                // Get parameters
                const params = cylinder.metadata.parameters;
                const radiusFunc = window.CYLINDER_MANAGER.getRadiusFunction(params);
                
                // Draw grid
                ctx.strokeStyle = '#2a2a4a';
                ctx.lineWidth = 1;
                ctx.beginPath();
                for (let i = 0; i <= 4; i++) {
                    const y = padding + (height - 2 * padding) * (i / 4);
                    ctx.moveTo(padding, y);
                    ctx.lineTo(width - padding, y);
                }
                ctx.stroke();
                
                // Draw center line
                ctx.strokeStyle = '#3a3a5a';
                ctx.lineWidth = 1;
                ctx.beginPath();
                const centerY = height / 2;
                ctx.moveTo(padding, centerY);
                ctx.lineTo(width - padding, centerY);
                ctx.stroke();
                
                // Draw curve
                ctx.strokeStyle = '#e94560';
                ctx.lineWidth = 2;
                ctx.beginPath();
                
                const steps = 100;
                for (let i = 0; i <= steps; i++) {
                    const t = i / steps;
                    const radius = radiusFunc(t);
                    
                    // Normalize radius to canvas height
                    const maxRadius = params.radius * 1.5;
                    const normalizedRadius = radius / maxRadius;
                    
                    const x = padding + (width - 2 * padding) * t;
                    const y = centerY - (normalizedRadius * (height - 2 * padding) / 2 - (height - 2 * padding) / 4);
                    
                    if (i === 0) {
                        ctx.moveTo(x, y);
                    } else {
                        ctx.lineTo(x, y);
                    }
                }
                ctx.stroke();
                
                // Draw labels
                ctx.fillStyle = '#8a8aa0';
                ctx.font = '10px monospace';
                ctx.fillText('0', padding - 10, height - padding + 12);
                ctx.fillText('1', width - padding - 5, height - padding + 12);
                ctx.fillText('Width', 10, 15);
                
                // Draw function name
                const funcNames = {
                    'normal': 'Constant',
                    'growing': 'Growing',
                    'shrinking': 'Shrinking',
                    'inverted': 'Inverted'
                };
                ctx.fillStyle = '#e94560';
                ctx.font = 'bold 11px sans-serif';
                ctx.fillText(funcNames[params.widthFunction] || params.widthFunction, width - 70, 15);
                
                // Show multi-selection indicator
                if (selected.length > 1) {
                    ctx.fillStyle = '#8a8aa0';
                    ctx.font = '10px monospace';
                    ctx.fillText(`(${selected.length} selected)`, width - 70, 28);
                }
            },
            
            updateGroupsList: function() {
                const container = document.getElementById('groups-list-container');
                if (!container) return;
                
                container.innerHTML = '';
                
                // Get root groups (no parent)
                const rootGroups = window.GROUP_MANAGER.groups.filter(g => g.parentGroupId === null);
                
                if (rootGroups.length === 0) {
                    const emptyMsg = document.createElement('div');
                    emptyMsg.style.cssText = 'text-align: center; color: var(--text-secondary); font-size: 11px; padding: var(--space-3);';
                    emptyMsg.textContent = 'No groups yet';
                    container.appendChild(emptyMsg);
                    return;
                }
                
                // Render groups recursively
                const renderGroup = (group, level = 0) => {
                    const item = document.createElement('div');
                    item.className = 'group-item' + (level > 0 ? ' nested' : '');
                    if (window.GROUP_MANAGER.selectedGroup && window.GROUP_MANAGER.selectedGroup.id === group.id) {
                        item.classList.add('selected');
                    }
                    
                    const icon = document.createElement('span');
                    icon.className = 'group-icon';
                    icon.textContent = 'ðŸ“';
                    
                    const name = document.createElement('span');
                    name.className = 'group-name';
                    name.textContent = group.name;
                    
                    const count = document.createElement('span');
                    count.className = 'group-count';
                    const cylinderCount = window.GROUP_MANAGER.getGroupCylinders(group.id, false).length;
                    count.textContent = `(${cylinderCount})`;
                    
                    const actions = document.createElement('div');
                    actions.className = 'group-actions';
                    
                    const addBtn = document.createElement('button');
                    addBtn.className = 'group-action-btn';
                    addBtn.textContent = '+';
                    addBtn.title = 'Add selected cylinder';
                    addBtn.onclick = (e) => {
                        e.stopPropagation();
                        if (window.CYLINDER_MANAGER.selectedCylinder) {
                            window.GROUP_MANAGER.addCylinderToGroup(
                                window.CYLINDER_MANAGER.selectedCylinder.id,
                                group.id
                            );
                            this.updateGroupsList();
                        }
                    };
                    
                    const deleteBtn = document.createElement('button');
                    deleteBtn.className = 'group-action-btn';
                    deleteBtn.textContent = 'Ã—';
                    deleteBtn.title = 'Delete group';
                    deleteBtn.onclick = (e) => {
                        e.stopPropagation();
                        if (confirm(`Delete group "${group.name}"?`)) {
                            window.GROUP_MANAGER.deleteGroup(group.id);
                            this.updateGroupsList();
                        }
                    };
                    
                    actions.appendChild(addBtn);
                    actions.appendChild(deleteBtn);
                    
                    item.appendChild(icon);
                    item.appendChild(name);
                    item.appendChild(count);
                    item.appendChild(actions);
                    
                    item.onclick = (e) => {
                        if (e.target === item || e.target === name || e.target === icon || e.target === count) {
                            window.GROUP_MANAGER.selectedGroup = group;
                            this.updateGroupsList();
                        }
                    };
                    
                    container.appendChild(item);
                    
                    // Render child groups
                    group.childGroupIds.forEach(childId => {
                        const childGroup = window.GROUP_MANAGER.groups.find(g => g.id === childId);
                        if (childGroup) {
                            renderGroup(childGroup, level + 1);
                        }
                    });
                };
                
                rootGroups.forEach(group => renderGroup(group));
            },
            
            applyEditorProperties: function() {
                const target = this.editorTarget || 'selected';
                
                // Get property values from editor controls
                const properties = {
                    radius: parseFloat(document.getElementById('editor-radius').value),
                    segments: parseInt(document.getElementById('editor-segments').value),
                    metalness: parseFloat(document.getElementById('editor-metalness').value),
                    roughness: parseFloat(document.getElementById('editor-roughness').value)
                };
                
                // Apply based on target
                if (target === 'selected') {
                    if (window.CYLINDER_MANAGER.selectedCylinder) {
                        Object.assign(window.CYLINDER_MANAGER.selectedCylinder.metadata.parameters, properties);
                        window.CYLINDER_MANAGER.rebuildCylinder(window.CYLINDER_MANAGER.selectedCylinder.id);
                        this.showNotification('Properties applied to selected cylinder');
                    }
                }
                else if (target === 'all') {
                    window.CYLINDER_MANAGER.cylinders.forEach(cylinder => {
                        Object.assign(cylinder.metadata.parameters, properties);
                        window.CYLINDER_MANAGER.rebuildCylinder(cylinder.id);
                    });
                    this.showNotification('Properties applied to all cylinders');
                }
                else if (target === 'group') {
                    if (window.GROUP_MANAGER.selectedGroup) {
                        window.GROUP_MANAGER.applyPropertiesToGroup(
                            window.GROUP_MANAGER.selectedGroup.id,
                            properties,
                            false
                        );
                        this.showNotification(`Properties applied to group "${window.GROUP_MANAGER.selectedGroup.name}"`);
                    }
                }
                else if (target === 'group-recursive') {
                    if (window.GROUP_MANAGER.selectedGroup) {
                        window.GROUP_MANAGER.applyPropertiesToGroup(
                            window.GROUP_MANAGER.selectedGroup.id,
                            properties,
                            true
                        );
                        this.showNotification(`Properties applied to group "${window.GROUP_MANAGER.selectedGroup.name}" and nested groups`);
                    }
                }
            }
        };

        // HUD Module - Heads-up display for z-index and registration feedback
        window.HUD = {
            container: null,
            enabled: true,
            updateInterval: null,
            
            init: function() {
                this.createHUD();
                this.setupSubscriptions();
                this.startUpdates();
                
                console.log('ðŸŽ® HUD initialized');
            },
            
            createHUD: function() {
                this.container = document.createElement('div');
                this.container.id = 'hud-container';
                this.container.innerHTML = `
                    <div class="hud-panel">
                        <div class="hud-section">
                            <div class="hud-title">Z-Index Mapping</div>
                            <div class="hud-content">
                                <div class="hud-row">
                                    <span class="hud-label">Mode:</span>
                                    <span class="hud-value" id="hud-z-mode">linear</span>
                                </div>
                                <div class="hud-row">
                                    <span class="hud-label">Range:</span>
                                    <span class="hud-value" id="hud-z-range">-10 to 10</span>
                                </div>
                                <div class="hud-row">
                                    <span class="hud-label">Visible Z:</span>
                                    <span class="hud-value" id="hud-visible-z">calculating...</span>
                                </div>
                            </div>
                        </div>
                        
                        <div class="hud-section">
                            <div class="hud-title">Camera</div>
                            <div class="hud-content">
                                <div class="hud-row">
                                    <span class="hud-label">Distance:</span>
                                    <span class="hud-value" id="hud-cam-dist">15.0</span>
                                </div>
                                <div class="hud-row">
                                    <span class="hud-label">Rotation:</span>
                                    <span class="hud-value" id="hud-cam-rot">0Â°, 0Â°</span>
                                </div>
                            </div>
                        </div>
                        
                        <div class="hud-section">
                            <div class="hud-title">Registration</div>
                            <div class="hud-content">
                                <div class="hud-row">
                                    <span class="hud-label">Screen Scale:</span>
                                    <span class="hud-value" id="hud-screen-scale">0.02</span>
                                </div>
                                <div class="hud-row">
                                    <span class="hud-label">History:</span>
                                    <span class="hud-value" id="hud-history-count">0</span>
                                </div>
                                <div class="hud-row">
                                    <span class="hud-label">NN Active:</span>
                                    <span class="hud-value" id="hud-nn-status">No</span>
                                </div>
                            </div>
                        </div>
                        
                        <div class="hud-section">
                            <canvas id="hud-z-viz" width="200" height="80"></canvas>
                        </div>
                    </div>
                    <button class="hud-toggle" id="hud-toggle-btn">â—€</button>
                `;
                
                document.body.appendChild(this.container);
                
                // Setup toggle
                document.getElementById('hud-toggle-btn').addEventListener('click', () => {
                    this.toggle();
                });
            },
            
            setupSubscriptions: function() {
                window.PUBSUB.subscribe('zmapping:updated', (data) => {
                    this.updateZMapping(data);
                });
                
                window.PUBSUB.subscribe('registration:recorded', (data) => {
                    this.updateRegistration(data);
                });
                
                window.PUBSUB.subscribe('camera:moved', () => {
                    this.updateCamera();
                });
            },
            
            startUpdates: function() {
                // Update HUD every 500ms
                this.updateInterval = setInterval(() => {
                    this.update();
                }, 500);
            },
            
            update: function() {
                if (!this.enabled) return;
                
                this.updateZMapping();
                this.updateCamera();
                this.updateRegistration();
                this.drawZVisualization();
            },
            
            updateZMapping: function(data) {
                const reg = window.REGISTRATION;
                const zParams = reg.parameters.zIndex;
                
                document.getElementById('hud-z-mode').textContent = zParams.mode;
                document.getElementById('hud-z-range').textContent = 
                    `${zParams.min.toFixed(1)} to ${zParams.max.toFixed(1)}`;
                
                // Visible Z range
                const visibleZ = reg.getVisibleZRange();
                document.getElementById('hud-visible-z').textContent = 
                    `${visibleZ.near.toFixed(1)} to ${visibleZ.far.toFixed(1)}`;
            },
            
            updateCamera: function() {
                if (!window.CAMERA) return;
                
                const cam = window.CAMERA.controls;
                
                document.getElementById('hud-cam-dist').textContent = cam.distance.toFixed(1);
                
                const rotX = (cam.rotationX * 180 / Math.PI).toFixed(0);
                const rotY = (cam.rotationY * 180 / Math.PI).toFixed(0);
                document.getElementById('hud-cam-rot').textContent = `${rotY}Â°, ${rotX}Â°`;
            },
            
            updateRegistration: function() {
                if (!window.REGISTRATION) return;
                
                const reg = window.REGISTRATION;
                
                document.getElementById('hud-screen-scale').textContent = 
                    reg.parameters.screenScale.toFixed(3);
                
                document.getElementById('hud-history-count').textContent = 
                    reg.history.length;
                
                const nnActive = reg.neuralHooks.enabled && reg.parameters.nnWeight > 0;
                document.getElementById('hud-nn-status').textContent = 
                    nnActive ? `Yes (${(reg.parameters.nnWeight * 100).toFixed(0)}%)` : 'No';
            },
            
            drawZVisualization: function() {
                const canvas = document.getElementById('hud-z-viz');
                if (!canvas) return;
                
                const ctx = canvas.getContext('2d');
                const width = canvas.width;
                const height = canvas.height;
                const padding = 10;
                
                // Clear
                ctx.fillStyle = '#0d1b2a';
                ctx.fillRect(0, 0, width, height);
                
                if (!window.REGISTRATION) return;
                
                const reg = window.REGISTRATION;
                const zParams = reg.parameters.zIndex;
                
                // Draw background grid
                ctx.strokeStyle = '#2a2a4a';
                ctx.lineWidth = 1;
                ctx.setLineDash([2, 2]);
                ctx.beginPath();
                for (let i = 0; i <= 4; i++) {
                    const y = padding + (height - 2 * padding) * (i / 4);
                    ctx.moveTo(padding, y);
                    ctx.lineTo(width - padding, y);
                }
                ctx.stroke();
                ctx.setLineDash([]);
                
                // Draw zero line
                const zeroY = height / 2;
                ctx.strokeStyle = '#3a3a5a';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(padding, zeroY);
                ctx.lineTo(width - padding, zeroY);
                ctx.stroke();
                
                // Draw Z mapping curve
                ctx.strokeStyle = '#e94560';
                ctx.lineWidth = 2;
                ctx.beginPath();
                
                const steps = 50;
                for (let i = 0; i <= steps; i++) {
                    const t = i / steps;
                    const z = reg.calculateParametricZ(t, null, { primaryDirection: { isHorizontal: true } });
                    
                    // Normalize z to canvas
                    const zNorm = (z - zParams.min) / (zParams.max - zParams.min);
                    
                    const x = padding + (width - 2 * padding) * t;
                    const y = height - padding - (height - 2 * padding) * zNorm;
                    
                    if (i === 0) {
                        ctx.moveTo(x, y);
                    } else {
                        ctx.lineTo(x, y);
                    }
                }
                ctx.stroke();
                
                // Labels
                ctx.fillStyle = '#8a8aa0';
                ctx.font = '9px monospace';
                ctx.fillText('0', 5, height - 5);
                ctx.fillText('1', width - 15, height - 5);
                ctx.fillText('Z', 5, 12);
                
                // Show min/max
                ctx.fillStyle = '#e94560';
                ctx.font = '9px monospace';
                ctx.fillText(zParams.max.toFixed(1), width - 25, 12);
                ctx.fillText(zParams.min.toFixed(1), width - 25, height - 5);
            },
            
            toggle: function() {
                this.enabled = !this.enabled;
                const panel = this.container.querySelector('.hud-panel');
                const btn = document.getElementById('hud-toggle-btn');
                
                if (this.enabled) {
                    panel.style.transform = 'translateX(0)';
                    btn.textContent = 'â—€';
                } else {
                    panel.style.transform = 'translateX(-100%)';
                    btn.textContent = 'â–¶';
                }
            }
        };

        // Main Application Module
        window.APP = {
            animationId: null,
            
            init: function() {
                this.animate();
                console.log('â–¶ï¸ App started');
            },
            
            animate: function() {
                this.animationId = requestAnimationFrame(() => this.animate());
                window.RENDERER.render();
            },
            
            stop: function() {
                if (this.animationId) {
                    cancelAnimationFrame(this.animationId);
                }
            }
        };

        // Boot the application when DOM is ready
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', () => window.LOADER.boot());
        } else {
            window.LOADER.boot();
        }
    </script>
</body>
</html>
