VTMP-2400 Technical Summary

  VTMP-2400 (VecTerm MultiPlayer at 2400 baud) is a lightweight, in-memory
  multiplayer server for terminal-based 3D vector graphics games.

  Architecture

  Transport Layer

  - HTTP Server (port 2400) - Static file serving
  - WebSocket Server (port 2401) - Real-time bidirectional communication
  - Protocol - JSON message-based with type/payload structure
  - Keepalive - 30-second ping/pong with 60-second timeout

  Server Components

  In-Memory State:
  - lobbies Map - Active game lobbies (LobbyId → Lobby)
  - clients Map - Connected players (WebSocket → Client)
  - No persistence, no database - pure memory

  Lobby System:
  - Configurable max players (default 4)
  - States: waiting, playing, finished
  - Host-based authority model
  - Automatic cleanup on empty

  Player Management:
  - Unique player IDs (9-char alphanumeric)
  - Username tracking
  - Lobby membership
  - Connection state monitoring

  Network Model

  Host-Authoritative:
  - Lobby host owns canonical game state
  - Host broadcasts state updates to clients
  - Clients render host's state locally
  - Prevents desync, simplifies logic

  Input Relay:
  - All players send inputs to server
  - Server broadcasts to lobby peers
  - Enables client-side prediction + remote updates
  - Low latency (no server-side processing)

  Message Protocol

  Client → Server:
  { type: 'join', payload: { name: 'Player1' } }
  { type: 'create_lobby', payload: { name: 'Game', maxPlayers: 4 } }
  { type: 'join_lobby', payload: { lobbyId: 'abc123' } }
  { type: 'game_state', payload: { entities, transforms, camera } }
  { type: 'player_input', payload: { keys, mouse, gamepad } }

  Server → Client:
  { type: 'joined', payload: { playerId, name } }
  { type: 'lobby_list', payload: [...lobbies] }
  { type: 'player_joined', payload: { player, lobby } }
  { type: 'game_state', payload: { playerId, state } }
  { type: 'player_input', payload: { playerId, input } }

  Client Integration

  Redux State:
  state.network = {
    connected: boolean,
    playerId: string,
    playerName: string,
    currentLobby: Lobby | null,
    lobbies: Lobby[],
    players: Map<playerId, PlayerState>
  }

  CLI Commands:
  - connect <name> - Authenticate to server
  - lobby_create <name> <max> - Create lobby
  - lobby_list - Browse lobbies
  - lobby_join <id> - Join lobby
  - game_start - Host starts game
  - mp_status - Connection status

  Network Actions:
  - NETWORK_CONNECTED - Client connected
  - NETWORK_LOBBY_JOINED - Joined lobby
  - NETWORK_PLAYER_INPUT - Remote input received
  - NETWORK_GAME_STARTED - Game session begins

  Performance Characteristics

  Latency:
  - WebSocket: ~1-5ms local, ~20-100ms WAN
  - No server-side game logic (zero processing delay)
  - Direct relay model (minimal hops)

  Throughput:
  - State updates: Throttled to 20Hz (50ms)
  - Input updates: Unthrottled (real-time)
  - Lobby updates: Event-driven (on change)

  Scalability:
  - Limited by single-process Node.js
  - ~10k concurrent WebSocket connections (theoretical)
  - ~100 active lobbies (practical)
  - No clustering or load balancing

  Limitations (By Design)

  Security:
  - No authentication (trust-based)
  - No encryption (plaintext WebSocket)
  - No rate limiting
  - No input validation

  Reliability:
  - No persistence (lobbies lost on restart)
  - No reconnection recovery
  - No state snapshots
  - No crash recovery

  Features:
  - No matchmaking algorithm
  - No spectator mode
  - No chat system
  - No replay recording
  - No anti-cheat

  Use Cases

  Ideal For:
  - Local network multiplayer (LAN parties)
  - Development and prototyping
  - Trusted player groups
  - Educational/demo purposes
  - Low-stakes casual games

  Not Suitable For:
  - Production/public internet
  - Competitive gaming
  - Persistent world games
  - High player counts (>100)
  - Untrusted environments

  Technical Philosophy

  "2400 baud" Design Principles:

  1. Start Slow - Minimal viable multiplayer
  2. Simple First - No premature optimization
  3. Memory Only - Ephemeral state
  4. Trust Players - No adversarial model
  5. Host Authority - Simplest consistency model
  6. Direct Relay - Zero server logic
  7. CLI Driven - Terminal-native interface

  The name "2400 baud" reflects this deliberate simplicity - like early
  modems, it prioritizes clarity and reliability over speed and features.
  You can build up from here.

  Dependencies

  - ws (^8.14.2) - WebSocket implementation
  - Node.js built-ins (http, fs, path)
  - Zero client dependencies (vanilla JS)

  Future Evolution Path

  To scale beyond 2400:
  - vtmp-9600 - Add authentication, TLS, rate limiting
  - vtmp-56k - Add persistence, reconnection, matchmaking
  - vtmp-broadband - Add clustering, CDN, anti-cheat

  But VTMP-2400 stays pure: dead simple, in-memory, trust-based relay.

